<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="referrer" content="no-referrer">
    <link rel="icon" type="image/x-icon" href="./assets/privategpt128.png">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <title>PrivateGPT</title>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.3/dexie.min.js"></script> -->
    <script>(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).Dexie=t()})(this,function(){"use strict";var g=function(){return(g=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function i(e,t,n){if(n||2===arguments.length)for(var r,i=0,o=t.length;i<o;i++)!r&&i in t||((r=r||Array.prototype.slice.call(t,0,i))[i]=t[i]);return e.concat(r||Array.prototype.slice.call(t))}var h="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:global,x=Object.keys,b=Array.isArray;function u(t,n){return"object"!=typeof n||x(n).forEach(function(e){t[e]=n[e]}),t}"undefined"==typeof Promise||h.Promise||(h.Promise=Promise);var s=Object.getPrototypeOf,n={}.hasOwnProperty;function m(e,t){return n.call(e,t)}function r(t,n){"function"==typeof n&&(n=n(s(t))),("undefined"==typeof Reflect?x:Reflect.ownKeys)(n).forEach(function(e){c(t,e,n[e])})}var a=Object.defineProperty;function c(e,t,n,r){a(e,t,u(n&&m(n,"get")&&"function"==typeof n.get?{get:n.get,set:n.set,configurable:!0}:{value:n,configurable:!0,writable:!0},r))}function o(t){return{from:function(e){return t.prototype=Object.create(e.prototype),c(t.prototype,"constructor",t),{extend:r.bind(null,t.prototype)}}}}var l=Object.getOwnPropertyDescriptor;function f(e,t){return l(e,t)||(e=s(e))&&f(e,t)}var d=[].slice;function y(e,t,n){return d.call(e,t,n)}function p(e,t){return t(e)}function v(e){if(!e)throw new Error("Assertion Failed")}function _(e){h.setImmediate?setImmediate(e):setTimeout(e,0)}function w(e,r){return e.reduce(function(e,t,n){n=r(t,n);return n&&(e[n[0]]=n[1]),e},{})}function k(e,t){if(m(e,t))return e[t];if(!t)return e;if("string"!=typeof t){for(var n=[],r=0,i=t.length;r<i;++r){var o=k(e,t[r]);n.push(o)}return n}var a=t.indexOf(".");if(-1!==a){var u=e[t.substr(0,a)];return void 0===u?void 0:k(u,t.substr(a+1))}}function E(e,t,n){if(e&&void 0!==t&&!("isFrozen"in Object&&Object.isFrozen(e)))if("string"!=typeof t&&"length"in t){v("string"!=typeof n&&"length"in n);for(var r=0,i=t.length;r<i;++r)E(e,t[r],n[r])}else{var o,a,u=t.indexOf(".");-1!==u?(o=t.substr(0,u),""===(a=t.substr(u+1))?void 0===n?b(e)&&!isNaN(parseInt(o))?e.splice(o,1):delete e[o]:e[o]=n:E(u=!(u=e[o])||!m(e,o)?e[o]={}:u,a,n)):void 0===n?b(e)&&!isNaN(parseInt(t))?e.splice(t,1):delete e[t]:e[t]=n}}function P(e){var t,n={};for(t in e)m(e,t)&&(n[t]=e[t]);return n}var t=[].concat;function K(e){return t.apply([],e)}var e="Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(K([8,16,32,64].map(function(t){return["Int","Uint","Float"].map(function(e){return e+t+"Array"})}))).filter(function(e){return h[e]}),O=e.map(function(e){return h[e]});w(e,function(e){return[e,!0]});var S=null;function A(e){S="undefined"!=typeof WeakMap&&new WeakMap;e=function e(t){if(!t||"object"!=typeof t)return t;var n=S&&S.get(t);if(n)return n;if(b(t)){n=[],S&&S.set(t,n);for(var r=0,i=t.length;r<i;++r)n.push(e(t[r]))}else if(0<=O.indexOf(t.constructor))n=t;else{var o,a=s(t);for(o in n=a===Object.prototype?{}:Object.create(a),S&&S.set(t,n),t)m(t,o)&&(n[o]=e(t[o]))}return n}(e);return S=null,e}var C={}.toString;function j(e){return C.call(e).slice(8,-1)}var D="undefined"!=typeof Symbol?Symbol.iterator:"@@iterator",I="symbol"==typeof D?function(e){var t;return null!=e&&(t=e[D])&&t.apply(e)}:function(){return null},B={};function T(e){var t,n,r,i;if(1===arguments.length){if(b(e))return e.slice();if(this===B&&"string"==typeof e)return[e];if(i=I(e)){for(n=[];!(r=i.next()).done;)n.push(r.value);return n}if(null==e)return[e];if("number"!=typeof(t=e.length))return[e];for(n=new Array(t);t--;)n[t]=e[t];return n}for(t=arguments.length,n=new Array(t);t--;)n[t]=arguments[t];return n}var R="undefined"!=typeof Symbol?function(e){return"AsyncFunction"===e[Symbol.toStringTag]}:function(){return!1},F="undefined"!=typeof location&&/^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);function M(e,t){F=e,N=t}var N=function(){return!0},q=!new Error("").stack;function U(){if(q)try{throw new Error}catch(e){return e}return new Error}function L(e,t){var n=e.stack;return n?(t=t||0,0===n.indexOf(e.name)&&(t+=(e.name+e.message).split("\n").length),n.split("\n").slice(t).filter(N).map(function(e){return"\n"+e}).join("")):""}var V=["Unknown","Constraint","Data","TransactionInactive","ReadOnly","Version","NotFound","InvalidState","InvalidAccess","Abort","Timeout","QuotaExceeded","Syntax","DataClone"],e=["Modify","Bulk","OpenFailed","VersionChange","Schema","Upgrade","InvalidTable","MissingAPI","NoSuchDatabase","InvalidArgument","SubTransaction","Unsupported","Internal","DatabaseClosed","PrematureCommit","ForeignAwait"].concat(V),W={VersionChanged:"Database version changed by other database connection",DatabaseClosed:"Database has been closed",Abort:"Transaction aborted",TransactionInactive:"Transaction has already completed or failed",MissingAPI:"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"};function z(e,t){this._e=U(),this.name=e,this.message=t}function Y(e,t){return e+". Errors: "+Object.keys(t).map(function(e){return t[e].toString()}).filter(function(e,t,n){return n.indexOf(e)===t}).join("\n")}function G(e,t,n,r){this._e=U(),this.failures=t,this.failedKeys=r,this.successCount=n,this.message=Y(e,t)}function H(e,t){this._e=U(),this.name="BulkError",this.failures=Object.keys(t).map(function(e){return t[e]}),this.failuresByPos=t,this.message=Y(e,t)}o(z).from(Error).extend({stack:{get:function(){return this._stack||(this._stack=this.name+": "+this.message+L(this._e,2))}},toString:function(){return this.name+": "+this.message}}),o(G).from(z),o(H).from(z);var Q=e.reduce(function(e,t){return e[t]=t+"Error",e},{}),X=z,J=e.reduce(function(e,n){var r=n+"Error";function t(e,t){this._e=U(),this.name=r,e?"string"==typeof e?(this.message=e+(t?"\n "+t:""),this.inner=t||null):"object"==typeof e&&(this.message=e.name+" "+e.message,this.inner=e):(this.message=W[n]||r,this.inner=null)}return o(t).from(X),e[n]=t,e},{});J.Syntax=SyntaxError,J.Type=TypeError,J.Range=RangeError;var $=V.reduce(function(e,t){return e[t+"Error"]=J[t],e},{});V=e.reduce(function(e,t){return-1===["Syntax","Type","Range"].indexOf(t)&&(e[t+"Error"]=J[t]),e},{});function Z(){}function ee(e){return e}function te(t,n){return null==t||t===ee?n:function(e){return n(t(e))}}function ne(e,t){return function(){e.apply(this,arguments),t.apply(this,arguments)}}function re(i,o){return i===Z?o:function(){var e=i.apply(this,arguments);void 0!==e&&(arguments[0]=e);var t=this.onsuccess,n=this.onerror;this.onsuccess=null,this.onerror=null;var r=o.apply(this,arguments);return t&&(this.onsuccess=this.onsuccess?ne(t,this.onsuccess):t),n&&(this.onerror=this.onerror?ne(n,this.onerror):n),void 0!==r?r:e}}function ie(n,r){return n===Z?r:function(){n.apply(this,arguments);var e=this.onsuccess,t=this.onerror;this.onsuccess=this.onerror=null,r.apply(this,arguments),e&&(this.onsuccess=this.onsuccess?ne(e,this.onsuccess):e),t&&(this.onerror=this.onerror?ne(t,this.onerror):t)}}function oe(i,o){return i===Z?o:function(e){var t=i.apply(this,arguments);u(e,t);var n=this.onsuccess,r=this.onerror;this.onsuccess=null,this.onerror=null;e=o.apply(this,arguments);return n&&(this.onsuccess=this.onsuccess?ne(n,this.onsuccess):n),r&&(this.onerror=this.onerror?ne(r,this.onerror):r),void 0===t?void 0===e?void 0:e:u(t,e)}}function ae(e,t){return e===Z?t:function(){return!1!==t.apply(this,arguments)&&e.apply(this,arguments)}}function ue(i,o){return i===Z?o:function(){var e=i.apply(this,arguments);if(e&&"function"==typeof e.then){for(var t=this,n=arguments.length,r=new Array(n);n--;)r[n]=arguments[n];return e.then(function(){return o.apply(t,r)})}return o.apply(this,arguments)}}V.ModifyError=G,V.DexieError=z,V.BulkError=H;var se={},ce=100,le=100,e="undefined"==typeof Promise?[]:function(){var e=Promise.resolve();if("undefined"==typeof crypto||!crypto.subtle)return[e,s(e),e];var t=crypto.subtle.digest("SHA-512",new Uint8Array([0]));return[t,s(t),e]}(),fe=e[0],he=e[1],de=e[2],pe=he&&he.then,ye=fe&&fe.constructor,ve=!!de,me=!1,ge=de?function(){de.then(Ne)}:h.setImmediate?setImmediate.bind(null,Ne):h.MutationObserver?function(){var e=document.createElement("div");new MutationObserver(function(){Ne(),e=null}).observe(e,{attributes:!0}),e.setAttribute("i","1")}:function(){setTimeout(Ne,0)},be=function(e,t){Se.push([e,t]),we&&(ge(),we=!1)},_e=!0,we=!0,xe=[],ke=[],Ee=null,Pe=ee,Ke={id:"global",global:!0,ref:0,unhandleds:[],onunhandled:ct,pgp:!1,env:{},finalize:function(){this.unhandleds.forEach(function(e){try{ct(e[0],e[1])}catch(e){}})}},Oe=Ke,Se=[],Ae=0,Ce=[];function je(e){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");this._listeners=[],this.onuncatched=Z,this._lib=!1;var t=this._PSD=Oe;if(F&&(this._stackHolder=U(),this._prev=null,this._numPrev=0),"function"!=typeof e){if(e!==se)throw new TypeError("Not a function");return this._state=arguments[1],this._value=arguments[2],void(!1===this._state&&Be(this,this._value))}this._state=null,this._value=null,++t.ref,function t(r,e){try{e(function(n){if(null===r._state){if(n===r)throw new TypeError("A promise cannot be resolved with itself.");var e=r._lib&&qe();n&&"function"==typeof n.then?t(r,function(e,t){n instanceof je?n._then(e,t):n.then(e,t)}):(r._state=!0,r._value=n,Te(r)),e&&Ue()}},Be.bind(null,r))}catch(e){Be(r,e)}}(this,e)}var De={get:function(){var u=Oe,t=Qe;function e(n,r){var i=this,o=!u.global&&(u!==Oe||t!==Qe),a=o&&!Ze(),e=new je(function(e,t){Re(i,new Ie(at(n,u,o,a),at(r,u,o,a),e,t,u))});return F&&Me(e,this),e}return e.prototype=se,e},set:function(e){c(this,"then",e&&e.prototype===se?De:{get:function(){return e},set:De.set})}};function Ie(e,t,n,r,i){this.onFulfilled="function"==typeof e?e:null,this.onRejected="function"==typeof t?t:null,this.resolve=n,this.reject=r,this.psd=i}function Be(t,n){var e,r;ke.push(n),null===t._state&&(e=t._lib&&qe(),n=Pe(n),t._state=!1,t._value=n,F&&null!==n&&"object"==typeof n&&!n._promise&&function(e,t,n){try{e.apply(null,n)}catch(e){t&&t(e)}}(function(){var e=f(n,"stack");n._promise=t,c(n,"stack",{get:function(){return me?e&&(e.get?e.get.apply(n):e.value):t.stack}})}),r=t,xe.some(function(e){return e._value===r._value})||xe.push(r),Te(t),e&&Ue())}function Te(e){var t=e._listeners;e._listeners=[];for(var n=0,r=t.length;n<r;++n)Re(e,t[n]);var i=e._PSD;--i.ref||i.finalize(),0===Ae&&(++Ae,be(function(){0==--Ae&&Le()},[]))}function Re(e,t){if(null!==e._state){var n=e._state?t.onFulfilled:t.onRejected;if(null===n)return(e._state?t.resolve:t.reject)(e._value);++t.psd.ref,++Ae,be(Fe,[n,e,t])}else e._listeners.push(t)}function Fe(e,t,n){try{var r,i=(Ee=t)._value;t._state?r=e(i):(ke.length&&(ke=[]),r=e(i),-1===ke.indexOf(i)&&function(e){var t=xe.length;for(;t;)if(xe[--t]._value===e._value)return xe.splice(t,1)}(t)),n.resolve(r)}catch(e){n.reject(e)}finally{Ee=null,0==--Ae&&Le(),--n.psd.ref||n.psd.finalize()}}function Me(e,t){var n=t?t._numPrev+1:0;n<ce&&(e._prev=t,e._numPrev=n)}function Ne(){qe()&&Ue()}function qe(){var e=_e;return we=_e=!1,e}function Ue(){var e,t,n;do{for(;0<Se.length;)for(e=Se,Se=[],n=e.length,t=0;t<n;++t){var r=e[t];r[0].apply(null,r[1])}}while(0<Se.length);we=_e=!0}function Le(){var e=xe;xe=[],e.forEach(function(e){e._PSD.onunhandled.call(null,e._value,e)});for(var t=Ce.slice(0),n=t.length;n;)t[--n]()}function Ve(e){return new je(se,!1,e)}function We(n,r){var i=Oe;return function(){var e=qe(),t=Oe;try{return nt(i,!0),n.apply(this,arguments)}catch(e){r&&r(e)}finally{nt(t,!1),e&&Ue()}}}r(je.prototype,{then:De,_then:function(e,t){Re(this,new Ie(null,null,e,t,Oe))},catch:function(e){if(1===arguments.length)return this.then(null,e);var t=e,n=arguments[1];return"function"==typeof t?this.then(null,function(e){return(e instanceof t?n:Ve)(e)}):this.then(null,function(e){return(e&&e.name===t?n:Ve)(e)})},finally:function(t){return this.then(function(e){return t(),e},function(e){return t(),Ve(e)})},stack:{get:function(){if(this._stack)return this._stack;try{me=!0;var e=function e(t,n,r){if(n.length===r)return n;var i="";{var o,a,u;!1===t._state&&(null!=(o=t._value)?(a=o.name||"Error",u=o.message||o,i=L(o,0)):(a=o,u=""),n.push(a+(u?": "+u:"")+i))}F&&((i=L(t._stackHolder,2))&&-1===n.indexOf(i)&&n.push(i),t._prev&&e(t._prev,n,r));return n}(this,[],20).join("\nFrom previous: ");return null!==this._state&&(this._stack=e),e}finally{me=!1}}},timeout:function(r,i){var o=this;return r<1/0?new je(function(e,t){var n=setTimeout(function(){return t(new J.Timeout(i))},r);o.then(e,t).finally(clearTimeout.bind(null,n))}):this}}),"undefined"!=typeof Symbol&&Symbol.toStringTag&&c(je.prototype,Symbol.toStringTag,"Dexie.Promise"),Ke.env=rt(),r(je,{all:function(){var o=T.apply(null,arguments).map(et);return new je(function(n,r){0===o.length&&n([]);var i=o.length;o.forEach(function(e,t){return je.resolve(e).then(function(e){o[t]=e,--i||n(o)},r)})})},resolve:function(n){if(n instanceof je)return n;if(n&&"function"==typeof n.then)return new je(function(e,t){n.then(e,t)});var e=new je(se,!0,n);return Me(e,Ee),e},reject:Ve,race:function(){var e=T.apply(null,arguments).map(et);return new je(function(t,n){e.map(function(e){return je.resolve(e).then(t,n)})})},PSD:{get:function(){return Oe},set:function(e){return Oe=e}},totalEchoes:{get:function(){return Qe}},newPSD:Je,usePSD:it,scheduler:{get:function(){return be},set:function(e){be=e}},rejectionMapper:{get:function(){return Pe},set:function(e){Pe=e}},follow:function(i,n){return new je(function(e,t){return Je(function(n,r){var e=Oe;e.unhandleds=[],e.onunhandled=r,e.finalize=ne(function(){var t,e=this;t=function(){0===e.unhandleds.length?n():r(e.unhandleds[0])},Ce.push(function e(){t(),Ce.splice(Ce.indexOf(e),1)}),++Ae,be(function(){0==--Ae&&Le()},[])},e.finalize),i()},n,e,t)})}}),ye&&(ye.allSettled&&c(je,"allSettled",function(){var e=T.apply(null,arguments).map(et);return new je(function(n){0===e.length&&n([]);var r=e.length,i=new Array(r);e.forEach(function(e,t){return je.resolve(e).then(function(e){return i[t]={status:"fulfilled",value:e}},function(e){return i[t]={status:"rejected",reason:e}}).then(function(){return--r||n(i)})})})}),ye.any&&"undefined"!=typeof AggregateError&&c(je,"any",function(){var e=T.apply(null,arguments).map(et);return new je(function(n,r){0===e.length&&r(new AggregateError([]));var i=e.length,o=new Array(i);e.forEach(function(e,t){return je.resolve(e).then(function(e){return n(e)},function(e){o[t]=e,--i||r(new AggregateError(o))})})})}));var ze={awaits:0,echoes:0,id:0},Ye=0,Ge=[],He=0,Qe=0,Xe=0;function Je(e,t,n,r){var i=Oe,o=Object.create(i);o.parent=i,o.ref=0,o.global=!1,o.id=++Xe;var a=Ke.env;o.env=ve?{Promise:je,PromiseProp:{value:je,configurable:!0,writable:!0},all:je.all,race:je.race,allSettled:je.allSettled,any:je.any,resolve:je.resolve,reject:je.reject,nthen:ut(a.nthen,o),gthen:ut(a.gthen,o)}:{},t&&u(o,t),++i.ref,o.finalize=function(){--this.parent.ref||this.parent.finalize()};r=it(o,e,n,r);return 0===o.ref&&o.finalize(),r}function $e(){return ze.id||(ze.id=++Ye),++ze.awaits,ze.echoes+=le,ze.id}function Ze(){return!!ze.awaits&&(0==--ze.awaits&&(ze.id=0),ze.echoes=ze.awaits*le,!0)}function et(e){return ze.echoes&&e&&e.constructor===ye?($e(),e.then(function(e){return Ze(),e},function(e){return Ze(),lt(e)})):e}function tt(){var e=Ge[Ge.length-1];Ge.pop(),nt(e,!1)}function nt(e,t){var n,r=Oe;(t?!ze.echoes||He++&&e===Oe:!He||--He&&e===Oe)||ot(t?function(e){++Qe,ze.echoes&&0!=--ze.echoes||(ze.echoes=ze.id=0),Ge.push(Oe),nt(e,!0)}.bind(null,e):tt),e!==Oe&&(Oe=e,r===Ke&&(Ke.env=rt()),ve&&(n=Ke.env.Promise,t=e.env,he.then=t.nthen,n.prototype.then=t.gthen,(r.global||e.global)&&(Object.defineProperty(h,"Promise",t.PromiseProp),n.all=t.all,n.race=t.race,n.resolve=t.resolve,n.reject=t.reject,t.allSettled&&(n.allSettled=t.allSettled),t.any&&(n.any=t.any))))}function rt(){var e=h.Promise;return ve?{Promise:e,PromiseProp:Object.getOwnPropertyDescriptor(h,"Promise"),all:e.all,race:e.race,allSettled:e.allSettled,any:e.any,resolve:e.resolve,reject:e.reject,nthen:he.then,gthen:e.prototype.then}:{}}function it(e,t,n,r,i){var o=Oe;try{return nt(e,!0),t(n,r,i)}finally{nt(o,!1)}}function ot(e){pe.call(fe,e)}function at(t,n,r,i){return"function"!=typeof t?t:function(){var e=Oe;r&&$e(),nt(n,!0);try{return t.apply(this,arguments)}finally{nt(e,!1),i&&ot(Ze)}}}function ut(n,r){return function(e,t){return n.call(this,at(e,r),at(t,r))}}-1===(""+pe).indexOf("[native code]")&&($e=Ze=Z);var st="unhandledrejection";function ct(e,t){var n;try{n=t.onuncatched(e)}catch(e){}if(!1!==n)try{var r,i={promise:t,reason:e};if(h.document&&document.createEvent?((r=document.createEvent("Event")).initEvent(st,!0,!0),u(r,i)):h.CustomEvent&&u(r=new CustomEvent(st,{detail:i}),i),r&&h.dispatchEvent&&(dispatchEvent(r),!h.PromiseRejectionEvent&&h.onunhandledrejection))try{h.onunhandledrejection(r)}catch(e){}F&&r&&!r.defaultPrevented&&console.warn("Unhandled rejection: "+(e.stack||e))}catch(e){}}var lt=je.reject;function ft(e){return!/(dexie\.js|dexie\.min\.js)/.test(e)}var ht=String.fromCharCode(65535),dt="Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",pt="String expected.",yt=[],vt="undefined"!=typeof navigator&&/(MSIE|Trident|Edge)/.test(navigator.userAgent),mt=vt,gt=vt,bt="__dbnames",_t="readonly",wt="readwrite";function xt(e,t){return e?t?function(){return e.apply(this,arguments)&&t.apply(this,arguments)}:e:t}var kt={type:3,lower:-1/0,lowerOpen:!1,upper:[[]],upperOpen:!1};function Et(t){return"string"!=typeof t||/\./.test(t)?function(e){return e}:function(e){return void 0===e[t]&&t in e&&delete(e=A(e))[t],e}}var Pt=(Kt.prototype._trans=function(e,r,t){var n=this._tx||Oe.trans,i=this.name;function o(e,t,n){if(!n.schema[i])throw new J.NotFound("Table "+i+" not part of transaction");return r(n.idbtrans,n)}var a=qe();try{return n&&n.db===this.db?n===Oe.trans?n._promise(e,o,t):Je(function(){return n._promise(e,o,t)},{trans:n,transless:Oe.transless||Oe}):function t(n,r,i,o){if(n.idbdb&&(n._state.openComplete||Oe.letThrough||n._vip)){var a=n._createTransaction(r,i,n._dbSchema);try{a.create(),n._state.PR1398_maxLoop=3}catch(e){return e.name===Q.InvalidState&&n.isOpen()&&0<--n._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),n._close(),n.open().then(function(){return t(n,r,i,o)})):lt(e)}return a._promise(r,function(e,t){return Je(function(){return Oe.trans=a,o(e,t,a)})}).then(function(e){return a._completion.then(function(){return e})})}if(n._state.openComplete)return lt(new J.DatabaseClosed(n._state.dbOpenError));if(!n._state.isBeingOpened){if(!n._options.autoOpen)return lt(new J.DatabaseClosed);n.open().catch(Z)}return n._state.dbReadyPromise.then(function(){return t(n,r,i,o)})}(this.db,e,[this.name],o)}finally{a&&Ue()}},Kt.prototype.get=function(t,e){var n=this;return t&&t.constructor===Object?this.where(t).first(e):this._trans("readonly",function(e){return n.core.get({trans:e,key:t}).then(function(e){return n.hook.reading.fire(e)})}).then(e)},Kt.prototype.where=function(o){if("string"==typeof o)return new this.db.WhereClause(this,o);if(b(o))return new this.db.WhereClause(this,"["+o.join("+")+"]");var n=x(o);if(1===n.length)return this.where(n[0]).equals(o[n[0]]);var e=this.schema.indexes.concat(this.schema.primKey).filter(function(t){return t.compound&&n.every(function(e){return 0<=t.keyPath.indexOf(e)})&&t.keyPath.every(function(e){return 0<=n.indexOf(e)})})[0];if(e&&this.db._maxKey!==ht)return this.where(e.name).equals(e.keyPath.map(function(e){return o[e]}));!e&&F&&console.warn("The query "+JSON.stringify(o)+" on "+this.name+" would benefit of a compound index ["+n.join("+")+"]");var a=this.schema.idxByName,r=this.db._deps.indexedDB;function u(e,t){try{return 0===r.cmp(e,t)}catch(e){return!1}}var t=n.reduce(function(e,t){var n=e[0],r=e[1],e=a[t],i=o[t];return[n||e,n||!e?xt(r,e&&e.multi?function(e){e=k(e,t);return b(e)&&e.some(function(e){return u(i,e)})}:function(e){return u(i,k(e,t))}):r]},[null,null]),i=t[0],t=t[1];return i?this.where(i.name).equals(o[i.keyPath]).filter(t):e?this.filter(t):this.where(n).equals("")},Kt.prototype.filter=function(e){return this.toCollection().and(e)},Kt.prototype.count=function(e){return this.toCollection().count(e)},Kt.prototype.offset=function(e){return this.toCollection().offset(e)},Kt.prototype.limit=function(e){return this.toCollection().limit(e)},Kt.prototype.each=function(e){return this.toCollection().each(e)},Kt.prototype.toArray=function(e){return this.toCollection().toArray(e)},Kt.prototype.toCollection=function(){return new this.db.Collection(new this.db.WhereClause(this))},Kt.prototype.orderBy=function(e){return new this.db.Collection(new this.db.WhereClause(this,b(e)?"["+e.join("+")+"]":e))},Kt.prototype.reverse=function(){return this.toCollection().reverse()},Kt.prototype.mapToClass=function(r){this.schema.mappedClass=r;function e(e){if(!e)return e;var t,n=Object.create(r.prototype);for(t in e)if(m(e,t))try{n[t]=e[t]}catch(e){}return n}return this.schema.readHook&&this.hook.reading.unsubscribe(this.schema.readHook),this.schema.readHook=e,this.hook("reading",e),r},Kt.prototype.defineClass=function(){return this.mapToClass(function(e){u(this,e)})},Kt.prototype.add=function(t,n){var r=this,e=this.schema.primKey,i=e.auto,o=e.keyPath,a=t;return o&&i&&(a=Et(o)(t)),this._trans("readwrite",function(e){return r.core.mutate({trans:e,type:"add",keys:null!=n?[n]:null,values:[a]})}).then(function(e){return e.numFailures?je.reject(e.failures[0]):e.lastResult}).then(function(e){if(o)try{E(t,o,e)}catch(e){}return e})},Kt.prototype.update=function(t,n){if("object"!=typeof t||b(t))return this.where(":id").equals(t).modify(n);var e=k(t,this.schema.primKey.keyPath);if(void 0===e)return lt(new J.InvalidArgument("Given object does not contain its primary key"));try{"function"!=typeof n?x(n).forEach(function(e){E(t,e,n[e])}):n(t,{value:t,primKey:e})}catch(e){}return this.where(":id").equals(e).modify(n)},Kt.prototype.put=function(t,n){var r=this,e=this.schema.primKey,i=e.auto,o=e.keyPath,a=t;return o&&i&&(a=Et(o)(t)),this._trans("readwrite",function(e){return r.core.mutate({trans:e,type:"put",values:[a],keys:null!=n?[n]:null})}).then(function(e){return e.numFailures?je.reject(e.failures[0]):e.lastResult}).then(function(e){if(o)try{E(t,o,e)}catch(e){}return e})},Kt.prototype.delete=function(t){var n=this;return this._trans("readwrite",function(e){return n.core.mutate({trans:e,type:"delete",keys:[t]})}).then(function(e){return e.numFailures?je.reject(e.failures[0]):void 0})},Kt.prototype.clear=function(){var t=this;return this._trans("readwrite",function(e){return t.core.mutate({trans:e,type:"deleteRange",range:kt})}).then(function(e){return e.numFailures?je.reject(e.failures[0]):void 0})},Kt.prototype.bulkGet=function(t){var n=this;return this._trans("readonly",function(e){return n.core.getMany({keys:t,trans:e}).then(function(e){return e.map(function(e){return n.hook.reading.fire(e)})})})},Kt.prototype.bulkAdd=function(r,e,t){var o=this,a=Array.isArray(e)?e:void 0,u=(t=t||(a?void 0:e))?t.allKeys:void 0;return this._trans("readwrite",function(e){var t=o.schema.primKey,n=t.auto,t=t.keyPath;if(t&&a)throw new J.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");if(a&&a.length!==r.length)throw new J.InvalidArgument("Arguments objects and keys must have the same length");var i=r.length,t=t&&n?r.map(Et(t)):r;return o.core.mutate({trans:e,type:"add",keys:a,values:t,wantResults:u}).then(function(e){var t=e.numFailures,n=e.results,r=e.lastResult,e=e.failures;if(0===t)return u?n:r;throw new H(o.name+".bulkAdd(): "+t+" of "+i+" operations failed",e)})})},Kt.prototype.bulkPut=function(r,e,t){var o=this,a=Array.isArray(e)?e:void 0,u=(t=t||(a?void 0:e))?t.allKeys:void 0;return this._trans("readwrite",function(e){var t=o.schema.primKey,n=t.auto,t=t.keyPath;if(t&&a)throw new J.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");if(a&&a.length!==r.length)throw new J.InvalidArgument("Arguments objects and keys must have the same length");var i=r.length,t=t&&n?r.map(Et(t)):r;return o.core.mutate({trans:e,type:"put",keys:a,values:t,wantResults:u}).then(function(e){var t=e.numFailures,n=e.results,r=e.lastResult,e=e.failures;if(0===t)return u?n:r;throw new H(o.name+".bulkPut(): "+t+" of "+i+" operations failed",e)})})},Kt.prototype.bulkDelete=function(t){var r=this,i=t.length;return this._trans("readwrite",function(e){return r.core.mutate({trans:e,type:"delete",keys:t})}).then(function(e){var t=e.numFailures,n=e.lastResult,e=e.failures;if(0===t)return n;throw new H(r.name+".bulkDelete(): "+t+" of "+i+" operations failed",e)})},Kt);function Kt(){}function Ot(i){function t(e,t){if(t){for(var n=arguments.length,r=new Array(n-1);--n;)r[n-1]=arguments[n];return a[e].subscribe.apply(null,r),i}if("string"==typeof e)return a[e]}var a={};t.addEventType=u;for(var e=1,n=arguments.length;e<n;++e)u(arguments[e]);return t;function u(e,n,r){if("object"!=typeof e){var i;n=n||ae;var o={subscribers:[],fire:r=r||Z,subscribe:function(e){-1===o.subscribers.indexOf(e)&&(o.subscribers.push(e),o.fire=n(o.fire,e))},unsubscribe:function(t){o.subscribers=o.subscribers.filter(function(e){return e!==t}),o.fire=o.subscribers.reduce(n,r)}};return a[e]=t[e]=o}x(i=e).forEach(function(e){var t=i[e];if(b(t))u(e,i[e][0],i[e][1]);else{if("asap"!==t)throw new J.InvalidArgument("Invalid event config");var n=u(e,ee,function(){for(var e=arguments.length,t=new Array(e);e--;)t[e]=arguments[e];n.subscribers.forEach(function(e){_(function(){e.apply(null,t)})})})}})}}function St(e,t){return o(t).from({prototype:e}),t}function At(e,t){return!(e.filter||e.algorithm||e.or)&&(t?e.justLimit:!e.replayFilter)}function Ct(e,t){e.filter=xt(e.filter,t)}function jt(e,t,n){var r=e.replayFilter;e.replayFilter=r?function(){return xt(r(),t())}:t,e.justLimit=n&&!r}function Dt(e,t){if(e.isPrimKey)return t.primaryKey;var n=t.getIndexByKeyPath(e.index);if(!n)throw new J.Schema("KeyPath "+e.index+" on object store "+t.name+" is not indexed");return n}function It(e,t,n){var r=Dt(e,t.schema);return t.openCursor({trans:n,values:!e.keysOnly,reverse:"prev"===e.dir,unique:!!e.unique,query:{index:r,range:e.range}})}function Bt(e,o,t,n){var a=e.replayFilter?xt(e.filter,e.replayFilter()):e.filter;if(e.or){var u={},r=function(e,t,n){var r,i;a&&!a(t,n,function(e){return t.stop(e)},function(e){return t.fail(e)})||("[object ArrayBuffer]"===(i=""+(r=t.primaryKey))&&(i=""+new Uint8Array(r)),m(u,i)||(u[i]=!0,o(e,t,n)))};return Promise.all([e.or._iterate(r,t),Tt(It(e,n,t),e.algorithm,r,!e.keysOnly&&e.valueMapper)])}return Tt(It(e,n,t),xt(e.algorithm,a),o,!e.keysOnly&&e.valueMapper)}function Tt(e,r,i,o){var a=We(o?function(e,t,n){return i(o(e),t,n)}:i);return e.then(function(n){if(n)return n.start(function(){var t=function(){return n.continue()};r&&!r(n,function(e){return t=e},function(e){n.stop(e),t=Z},function(e){n.fail(e),t=Z})||a(n.value,n,function(e){return t=e}),t()})})}function Rt(e,t){try{var n=Ft(e),r=Ft(t);if(n!==r)return"Array"===n?1:"Array"===r?-1:"binary"===n?1:"binary"===r?-1:"string"===n?1:"string"===r?-1:"Date"===n?1:"Date"!==r?NaN:-1;switch(n){case"number":case"Date":case"string":return t<e?1:e<t?-1:0;case"binary":return function(e,t){for(var n=e.length,r=t.length,i=n<r?n:r,o=0;o<i;++o)if(e[o]!==t[o])return e[o]<t[o]?-1:1;return n===r?0:n<r?-1:1}(Mt(e),Mt(t));case"Array":return function(e,t){for(var n=e.length,r=t.length,i=n<r?n:r,o=0;o<i;++o){var a=Rt(e[o],t[o]);if(0!==a)return a}return n===r?0:n<r?-1:1}(e,t)}}catch(e){}return NaN}function Ft(e){var t=typeof e;if("object"!=t)return t;if(ArrayBuffer.isView(e))return"binary";e=j(e);return"ArrayBuffer"===e?"binary":e}function Mt(e){return e instanceof Uint8Array?e:ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):new Uint8Array(e)}var Nt=(qt.prototype._read=function(e,t){var n=this._ctx;return n.error?n.table._trans(null,lt.bind(null,n.error)):n.table._trans("readonly",e).then(t)},qt.prototype._write=function(e){var t=this._ctx;return t.error?t.table._trans(null,lt.bind(null,t.error)):t.table._trans("readwrite",e,"locked")},qt.prototype._addAlgorithm=function(e){var t=this._ctx;t.algorithm=xt(t.algorithm,e)},qt.prototype._iterate=function(e,t){return Bt(this._ctx,e,t,this._ctx.table.core)},qt.prototype.clone=function(e){var t=Object.create(this.constructor.prototype),n=Object.create(this._ctx);return e&&u(n,e),t._ctx=n,t},qt.prototype.raw=function(){return this._ctx.valueMapper=null,this},qt.prototype.each=function(t){var n=this._ctx;return this._read(function(e){return Bt(n,t,e,n.table.core)})},qt.prototype.count=function(e){var i=this;return this._read(function(e){var t=i._ctx,n=t.table.core;if(At(t,!0))return n.count({trans:e,query:{index:Dt(t,n.schema),range:t.range}}).then(function(e){return Math.min(e,t.limit)});var r=0;return Bt(t,function(){return++r,!1},e,n).then(function(){return r})}).then(e)},qt.prototype.sortBy=function(e,t){var n=e.split(".").reverse(),r=n[0],i=n.length-1;function o(e,t){return t?o(e[n[t]],t-1):e[r]}var a="next"===this._ctx.dir?1:-1;function u(e,t){e=o(e,i),t=o(t,i);return e<t?-a:t<e?a:0}return this.toArray(function(e){return e.sort(u)}).then(t)},qt.prototype.toArray=function(e){var o=this;return this._read(function(e){var t=o._ctx;if("next"===t.dir&&At(t,!0)&&0<t.limit){var n=t.valueMapper,r=Dt(t,t.table.core.schema);return t.table.core.query({trans:e,limit:t.limit,values:!0,query:{index:r,range:t.range}}).then(function(e){e=e.result;return n?e.map(n):e})}var i=[];return Bt(t,function(e){return i.push(e)},e,t.table.core).then(function(){return i})},e)},qt.prototype.offset=function(t){var e=this._ctx;return t<=0||(e.offset+=t,At(e)?jt(e,function(){var n=t;return function(e,t){return 0===n||(1===n?--n:t(function(){e.advance(n),n=0}),!1)}}):jt(e,function(){var e=t;return function(){return--e<0}})),this},qt.prototype.limit=function(e){return this._ctx.limit=Math.min(this._ctx.limit,e),jt(this._ctx,function(){var r=e;return function(e,t,n){return--r<=0&&t(n),0<=r}},!0),this},qt.prototype.until=function(r,i){return Ct(this._ctx,function(e,t,n){return!r(e.value)||(t(n),i)}),this},qt.prototype.first=function(e){return this.limit(1).toArray(function(e){return e[0]}).then(e)},qt.prototype.last=function(e){return this.reverse().first(e)},qt.prototype.filter=function(t){var e;return Ct(this._ctx,function(e){return t(e.value)}),(e=this._ctx).isMatch=xt(e.isMatch,t),this},qt.prototype.and=function(e){return this.filter(e)},qt.prototype.or=function(e){return new this.db.WhereClause(this._ctx.table,e,this)},qt.prototype.reverse=function(){return this._ctx.dir="prev"===this._ctx.dir?"next":"prev",this._ondirectionchange&&this._ondirectionchange(this._ctx.dir),this},qt.prototype.desc=function(){return this.reverse()},qt.prototype.eachKey=function(n){var e=this._ctx;return e.keysOnly=!e.isMatch,this.each(function(e,t){n(t.key,t)})},qt.prototype.eachUniqueKey=function(e){return this._ctx.unique="unique",this.eachKey(e)},qt.prototype.eachPrimaryKey=function(n){var e=this._ctx;return e.keysOnly=!e.isMatch,this.each(function(e,t){n(t.primaryKey,t)})},qt.prototype.keys=function(e){var t=this._ctx;t.keysOnly=!t.isMatch;var n=[];return this.each(function(e,t){n.push(t.key)}).then(function(){return n}).then(e)},qt.prototype.primaryKeys=function(e){var n=this._ctx;if("next"===n.dir&&At(n,!0)&&0<n.limit)return this._read(function(e){var t=Dt(n,n.table.core.schema);return n.table.core.query({trans:e,values:!1,limit:n.limit,query:{index:t,range:n.range}})}).then(function(e){return e.result}).then(e);n.keysOnly=!n.isMatch;var r=[];return this.each(function(e,t){r.push(t.primaryKey)}).then(function(){return r}).then(e)},qt.prototype.uniqueKeys=function(e){return this._ctx.unique="unique",this.keys(e)},qt.prototype.firstKey=function(e){return this.limit(1).keys(function(e){return e[0]}).then(e)},qt.prototype.lastKey=function(e){return this.reverse().firstKey(e)},qt.prototype.distinct=function(){var e=this._ctx,e=e.index&&e.table.schema.idxByName[e.index];if(!e||!e.multi)return this;var n={};return Ct(this._ctx,function(e){var t=e.primaryKey.toString(),e=m(n,t);return n[t]=!0,!e}),this},qt.prototype.modify=function(_){var n=this,w=this._ctx;return this._write(function(d){var o,a,p;p="function"==typeof _?_:(o=x(_),a=o.length,function(e){for(var t=!1,n=0;n<a;++n){var r=o[n],i=_[r];k(e,r)!==i&&(E(e,r,i),t=!0)}return t});function y(e,t){var n=t.failures,t=t.numFailures;s+=e-t;for(var r=0,i=x(n);r<i.length;r++){var o=i[r];u.push(n[o])}}var v=w.table.core,e=v.schema.primaryKey,m=e.outbound,g=e.extractKey,b=n.db._options.modifyChunkSize||200,u=[],s=0,t=[];return n.clone().primaryKeys().then(function(f){function h(c){var l=Math.min(b,f.length-c);return v.getMany({trans:d,keys:f.slice(c,c+l),cache:"immutable"}).then(function(e){for(var n=[],t=[],r=m?[]:null,i=[],o=0;o<l;++o){var a=e[o],u={value:A(a),primKey:f[c+o]};!1!==p.call(u,u.value,u)&&(null==u.value?i.push(f[c+o]):m||0===Rt(g(a),g(u.value))?(t.push(u.value),m&&r.push(f[c+o])):(i.push(f[c+o]),n.push(u.value)))}var s=At(w)&&w.limit===1/0&&("function"!=typeof _||_===Ut)&&{index:w.index,range:w.range};return Promise.resolve(0<n.length&&v.mutate({trans:d,type:"add",values:n}).then(function(e){for(var t in e.failures)i.splice(parseInt(t),1);y(n.length,e)})).then(function(){return(0<t.length||s&&"object"==typeof _)&&v.mutate({trans:d,type:"put",keys:r,values:t,criteria:s,changeSpec:"function"!=typeof _&&_}).then(function(e){return y(t.length,e)})}).then(function(){return(0<i.length||s&&_===Ut)&&v.mutate({trans:d,type:"delete",keys:i,criteria:s}).then(function(e){return y(i.length,e)})}).then(function(){return f.length>c+l&&h(c+b)})})}return h(0).then(function(){if(0<u.length)throw new G("Error modifying one or more objects",u,s,t);return f.length})})})},qt.prototype.delete=function(){var i=this._ctx,n=i.range;return At(i)&&(i.isPrimKey&&!gt||3===n.type)?this._write(function(e){var t=i.table.core.schema.primaryKey,r=n;return i.table.core.count({trans:e,query:{index:t,range:r}}).then(function(n){return i.table.core.mutate({trans:e,type:"deleteRange",range:r}).then(function(e){var t=e.failures;e.lastResult,e.results;e=e.numFailures;if(e)throw new G("Could not delete some values",Object.keys(t).map(function(e){return t[e]}),n-e);return n-e})})}):this.modify(Ut)},qt);function qt(){}var Ut=function(e,t){return t.value=null};function Lt(e,t){return e<t?-1:e===t?0:1}function Vt(e,t){return t<e?-1:e===t?0:1}function Wt(e,t,n){e=e instanceof Qt?new e.Collection(e):e;return e._ctx.error=new(n||TypeError)(t),e}function zt(e){return new e.Collection(e,function(){return Ht("")}).limit(0)}function Yt(e,s,n,r){var i,c,l,f,h,d,p,y=n.length;if(!n.every(function(e){return"string"==typeof e}))return Wt(e,pt);function t(e){i="next"===e?function(e){return e.toUpperCase()}:function(e){return e.toLowerCase()},c="next"===e?function(e){return e.toLowerCase()}:function(e){return e.toUpperCase()},l="next"===e?Lt:Vt;var t=n.map(function(e){return{lower:c(e),upper:i(e)}}).sort(function(e,t){return l(e.lower,t.lower)});f=t.map(function(e){return e.upper}),h=t.map(function(e){return e.lower}),p="next"===(d=e)?"":r}t("next");e=new e.Collection(e,function(){return Gt(f[0],h[y-1]+r)});e._ondirectionchange=function(e){t(e)};var v=0;return e._addAlgorithm(function(e,t,n){var r=e.key;if("string"!=typeof r)return!1;var i=c(r);if(s(i,h,v))return!0;for(var o=null,a=v;a<y;++a){var u=function(e,t,n,r,i,o){for(var a=Math.min(e.length,r.length),u=-1,s=0;s<a;++s){var c=t[s];if(c!==r[s])return i(e[s],n[s])<0?e.substr(0,s)+n[s]+n.substr(s+1):i(e[s],r[s])<0?e.substr(0,s)+r[s]+n.substr(s+1):0<=u?e.substr(0,u)+t[u]+n.substr(u+1):null;i(e[s],c)<0&&(u=s)}return a<r.length&&"next"===o?e+n.substr(e.length):a<e.length&&"prev"===o?e.substr(0,n.length):u<0?null:e.substr(0,u)+r[u]+n.substr(u+1)}(r,i,f[a],h[a],l,d);null===u&&null===o?v=a+1:(null===o||0<l(o,u))&&(o=u)}return t(null!==o?function(){e.continue(o+p)}:n),!1}),e}function Gt(e,t,n,r){return{type:2,lower:e,upper:t,lowerOpen:n,upperOpen:r}}function Ht(e){return{type:1,lower:e,upper:e}}var Qt=(Object.defineProperty(Xt.prototype,"Collection",{get:function(){return this._ctx.table.db.Collection},enumerable:!1,configurable:!0}),Xt.prototype.between=function(e,t,n,r){n=!1!==n,r=!0===r;try{return 0<this._cmp(e,t)||0===this._cmp(e,t)&&(n||r)&&(!n||!r)?zt(this):new this.Collection(this,function(){return Gt(e,t,!n,!r)})}catch(e){return Wt(this,dt)}},Xt.prototype.equals=function(e){return null==e?Wt(this,dt):new this.Collection(this,function(){return Ht(e)})},Xt.prototype.above=function(e){return null==e?Wt(this,dt):new this.Collection(this,function(){return Gt(e,void 0,!0)})},Xt.prototype.aboveOrEqual=function(e){return null==e?Wt(this,dt):new this.Collection(this,function(){return Gt(e,void 0,!1)})},Xt.prototype.below=function(e){return null==e?Wt(this,dt):new this.Collection(this,function(){return Gt(void 0,e,!1,!0)})},Xt.prototype.belowOrEqual=function(e){return null==e?Wt(this,dt):new this.Collection(this,function(){return Gt(void 0,e)})},Xt.prototype.startsWith=function(e){return"string"!=typeof e?Wt(this,pt):this.between(e,e+ht,!0,!0)},Xt.prototype.startsWithIgnoreCase=function(e){return""===e?this.startsWith(e):Yt(this,function(e,t){return 0===e.indexOf(t[0])},[e],ht)},Xt.prototype.equalsIgnoreCase=function(e){return Yt(this,function(e,t){return e===t[0]},[e],"")},Xt.prototype.anyOfIgnoreCase=function(){var e=T.apply(B,arguments);return 0===e.length?zt(this):Yt(this,function(e,t){return-1!==t.indexOf(e)},e,"")},Xt.prototype.startsWithAnyOfIgnoreCase=function(){var e=T.apply(B,arguments);return 0===e.length?zt(this):Yt(this,function(t,e){return e.some(function(e){return 0===t.indexOf(e)})},e,ht)},Xt.prototype.anyOf=function(){var t=this,i=T.apply(B,arguments),o=this._cmp;try{i.sort(o)}catch(e){return Wt(this,dt)}if(0===i.length)return zt(this);var e=new this.Collection(this,function(){return Gt(i[0],i[i.length-1])});e._ondirectionchange=function(e){o="next"===e?t._ascending:t._descending,i.sort(o)};var a=0;return e._addAlgorithm(function(e,t,n){for(var r=e.key;0<o(r,i[a]);)if(++a===i.length)return t(n),!1;return 0===o(r,i[a])||(t(function(){e.continue(i[a])}),!1)}),e},Xt.prototype.notEqual=function(e){return this.inAnyRange([[-1/0,e],[e,this.db._maxKey]],{includeLowers:!1,includeUppers:!1})},Xt.prototype.noneOf=function(){var e=T.apply(B,arguments);if(0===e.length)return new this.Collection(this);try{e.sort(this._ascending)}catch(e){return Wt(this,dt)}var t=e.reduce(function(e,t){return e?e.concat([[e[e.length-1][1],t]]):[[-1/0,t]]},null);return t.push([e[e.length-1],this.db._maxKey]),this.inAnyRange(t,{includeLowers:!1,includeUppers:!1})},Xt.prototype.inAnyRange=function(e,t){var o=this,a=this._cmp,u=this._ascending,n=this._descending,s=this._min,c=this._max;if(0===e.length)return zt(this);if(!e.every(function(e){return void 0!==e[0]&&void 0!==e[1]&&u(e[0],e[1])<=0}))return Wt(this,"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower",J.InvalidArgument);var r=!t||!1!==t.includeLowers,i=t&&!0===t.includeUppers;var l,f=u;function h(e,t){return f(e[0],t[0])}try{(l=e.reduce(function(e,t){for(var n=0,r=e.length;n<r;++n){var i=e[n];if(a(t[0],i[1])<0&&0<a(t[1],i[0])){i[0]=s(i[0],t[0]),i[1]=c(i[1],t[1]);break}}return n===r&&e.push(t),e},[])).sort(h)}catch(e){return Wt(this,dt)}var d=0,p=i?function(e){return 0<u(e,l[d][1])}:function(e){return 0<=u(e,l[d][1])},y=r?function(e){return 0<n(e,l[d][0])}:function(e){return 0<=n(e,l[d][0])};var v=p,e=new this.Collection(this,function(){return Gt(l[0][0],l[l.length-1][1],!r,!i)});return e._ondirectionchange=function(e){f="next"===e?(v=p,u):(v=y,n),l.sort(h)},e._addAlgorithm(function(e,t,n){for(var r,i=e.key;v(i);)if(++d===l.length)return t(n),!1;return!p(r=i)&&!y(r)||(0===o._cmp(i,l[d][1])||0===o._cmp(i,l[d][0])||t(function(){f===u?e.continue(l[d][0]):e.continue(l[d][1])}),!1)}),e},Xt.prototype.startsWithAnyOf=function(){var e=T.apply(B,arguments);return e.every(function(e){return"string"==typeof e})?0===e.length?zt(this):this.inAnyRange(e.map(function(e){return[e,e+ht]})):Wt(this,"startsWithAnyOf() only works with strings")},Xt);function Xt(){}function Jt(t){return We(function(e){return $t(e),t(e.target.error),!1})}function $t(e){e.stopPropagation&&e.stopPropagation(),e.preventDefault&&e.preventDefault()}var Zt="storagemutated",en="x-storagemutated-1",tn=Ot(null,Zt),nn=(rn.prototype._lock=function(){return v(!Oe.global),++this._reculock,1!==this._reculock||Oe.global||(Oe.lockOwnerFor=this),this},rn.prototype._unlock=function(){if(v(!Oe.global),0==--this._reculock)for(Oe.global||(Oe.lockOwnerFor=null);0<this._blockedFuncs.length&&!this._locked();){var e=this._blockedFuncs.shift();try{it(e[1],e[0])}catch(e){}}return this},rn.prototype._locked=function(){return this._reculock&&Oe.lockOwnerFor!==this},rn.prototype.create=function(t){var n=this;if(!this.mode)return this;var e=this.db.idbdb,r=this.db._state.dbOpenError;if(v(!this.idbtrans),!t&&!e)switch(r&&r.name){case"DatabaseClosedError":throw new J.DatabaseClosed(r);case"MissingAPIError":throw new J.MissingAPI(r.message,r);default:throw new J.OpenFailed(r)}if(!this.active)throw new J.TransactionInactive;return v(null===this._completion._state),(t=this.idbtrans=t||(this.db.core||e).transaction(this.storeNames,this.mode,{durability:this.chromeTransactionDurability})).onerror=We(function(e){$t(e),n._reject(t.error)}),t.onabort=We(function(e){$t(e),n.active&&n._reject(new J.Abort(t.error)),n.active=!1,n.on("abort").fire(e)}),t.oncomplete=We(function(){n.active=!1,n._resolve(),"mutatedParts"in t&&tn.storagemutated.fire(t.mutatedParts)}),this},rn.prototype._promise=function(n,r,i){var o=this;if("readwrite"===n&&"readwrite"!==this.mode)return lt(new J.ReadOnly("Transaction is readonly"));if(!this.active)return lt(new J.TransactionInactive);if(this._locked())return new je(function(e,t){o._blockedFuncs.push([function(){o._promise(n,r,i).then(e,t)},Oe])});if(i)return Je(function(){var e=new je(function(e,t){o._lock();var n=r(e,t,o);n&&n.then&&n.then(e,t)});return e.finally(function(){return o._unlock()}),e._lib=!0,e});var e=new je(function(e,t){var n=r(e,t,o);n&&n.then&&n.then(e,t)});return e._lib=!0,e},rn.prototype._root=function(){return this.parent?this.parent._root():this},rn.prototype.waitFor=function(e){var t,r=this._root(),i=je.resolve(e);r._waitingFor?r._waitingFor=r._waitingFor.then(function(){return i}):(r._waitingFor=i,r._waitingQueue=[],t=r.idbtrans.objectStore(r.storeNames[0]),function e(){for(++r._spinCount;r._waitingQueue.length;)r._waitingQueue.shift()();r._waitingFor&&(t.get(-1/0).onsuccess=e)}());var o=r._waitingFor;return new je(function(t,n){i.then(function(e){return r._waitingQueue.push(We(t.bind(null,e)))},function(e){return r._waitingQueue.push(We(n.bind(null,e)))}).finally(function(){r._waitingFor===o&&(r._waitingFor=null)})})},rn.prototype.abort=function(){this.active&&(this.active=!1,this.idbtrans&&this.idbtrans.abort(),this._reject(new J.Abort))},rn.prototype.table=function(e){var t=this._memoizedTables||(this._memoizedTables={});if(m(t,e))return t[e];var n=this.schema[e];if(!n)throw new J.NotFound("Table "+e+" not part of transaction");n=new this.db.Table(e,n,this);return n.core=this.db.core.table(e),t[e]=n},rn);function rn(){}function on(e,t,n,r,i,o,a){return{name:e,keyPath:t,unique:n,multi:r,auto:i,compound:o,src:(n&&!a?"&":"")+(r?"*":"")+(i?"++":"")+an(t)}}function an(e){return"string"==typeof e?e:e?"["+[].join.call(e,"+")+"]":""}function un(e,t,n){return{name:e,primKey:t,indexes:n,mappedClass:null,idxByName:w(n,function(e){return[e.name,e]})}}var sn=function(e){try{return e.only([[]]),sn=function(){return[[]]},[[]]}catch(e){return sn=function(){return ht},ht}};function cn(t){return null==t?function(){}:"string"==typeof t?1===(n=t).split(".").length?function(e){return e[n]}:function(e){return k(e,n)}:function(e){return k(e,t)};var n}function ln(e){return[].slice.call(e)}var fn=0;function hn(e){return null==e?":id":"string"==typeof e?e:"["+e.join("+")+"]"}function dn(e,i,t){function w(e){if(3===e.type)return null;if(4===e.type)throw new Error("Cannot convert never type to IDBKeyRange");var t=e.lower,n=e.upper,r=e.lowerOpen,e=e.upperOpen;return void 0===t?void 0===n?null:i.upperBound(n,!!e):void 0===n?i.lowerBound(t,!!r):i.bound(t,n,!!r,!!e)}function n(e){var h,_=e.name;return{name:_,schema:e,mutate:function(e){var y=e.trans,v=e.type,m=e.keys,g=e.values,b=e.range;return new Promise(function(t,e){t=We(t);var n=y.objectStore(_),r=null==n.keyPath,i="put"===v||"add"===v;if(!i&&"delete"!==v&&"deleteRange"!==v)throw new Error("Invalid operation type: "+v);var o,a=(m||g||{length:1}).length;if(m&&g&&m.length!==g.length)throw new Error("Given keys array must have same length as given values array.");if(0===a)return t({numFailures:0,failures:{},results:[],lastResult:void 0});function u(e){++l,$t(e)}var s=[],c=[],l=0;if("deleteRange"===v){if(4===b.type)return t({numFailures:l,failures:c,results:[],lastResult:void 0});3===b.type?s.push(o=n.clear()):s.push(o=n.delete(w(b)))}else{var r=i?r?[g,m]:[g,null]:[m,null],f=r[0],h=r[1];if(i)for(var d=0;d<a;++d)s.push(o=h&&void 0!==h[d]?n[v](f[d],h[d]):n[v](f[d])),o.onerror=u;else for(d=0;d<a;++d)s.push(o=n[v](f[d])),o.onerror=u}function p(e){e=e.target.result,s.forEach(function(e,t){return null!=e.error&&(c[t]=e.error)}),t({numFailures:l,failures:c,results:"delete"===v?m:s.map(function(e){return e.result}),lastResult:e})}o.onerror=function(e){u(e),p(e)},o.onsuccess=p})},getMany:function(e){var f=e.trans,h=e.keys;return new Promise(function(t,e){t=We(t);for(var n,r=f.objectStore(_),i=h.length,o=new Array(i),a=0,u=0,s=function(e){e=e.target;o[e._pos]=e.result,++u===a&&t(o)},c=Jt(e),l=0;l<i;++l)null!=h[l]&&((n=r.get(h[l]))._pos=l,n.onsuccess=s,n.onerror=c,++a);0===a&&t(o)})},get:function(e){var r=e.trans,i=e.key;return new Promise(function(t,e){t=We(t);var n=r.objectStore(_).get(i);n.onsuccess=function(e){return t(e.target.result)},n.onerror=Jt(e)})},query:(h=s,function(f){return new Promise(function(n,e){n=We(n);var r,i,o,t=f.trans,a=f.values,u=f.limit,s=f.query,c=u===1/0?void 0:u,l=s.index,s=s.range,t=t.objectStore(_),l=l.isPrimaryKey?t:t.index(l.name),s=w(s);if(0===u)return n({result:[]});h?((c=a?l.getAll(s,c):l.getAllKeys(s,c)).onsuccess=function(e){return n({result:e.target.result})},c.onerror=Jt(e)):(r=0,i=!a&&"openKeyCursor"in l?l.openKeyCursor(s):l.openCursor(s),o=[],i.onsuccess=function(e){var t=i.result;return t?(o.push(a?t.value:t.primaryKey),++r===u?n({result:o}):void t.continue()):n({result:o})},i.onerror=Jt(e))})}),openCursor:function(e){var c=e.trans,o=e.values,a=e.query,u=e.reverse,l=e.unique;return new Promise(function(t,n){t=We(t);var e=a.index,r=a.range,i=c.objectStore(_),i=e.isPrimaryKey?i:i.index(e.name),e=u?l?"prevunique":"prev":l?"nextunique":"next",s=!o&&"openKeyCursor"in i?i.openKeyCursor(w(r),e):i.openCursor(w(r),e);s.onerror=Jt(n),s.onsuccess=We(function(e){var r,i,o,a,u=s.result;u?(u.___id=++fn,u.done=!1,r=u.continue.bind(u),i=(i=u.continuePrimaryKey)&&i.bind(u),o=u.advance.bind(u),a=function(){throw new Error("Cursor not stopped")},u.trans=c,u.stop=u.continue=u.continuePrimaryKey=u.advance=function(){throw new Error("Cursor not started")},u.fail=We(n),u.next=function(){var e=this,t=1;return this.start(function(){return t--?e.continue():e.stop()}).then(function(){return e})},u.start=function(e){function t(){if(s.result)try{e()}catch(e){u.fail(e)}else u.done=!0,u.start=function(){throw new Error("Cursor behind last entry")},u.stop()}var n=new Promise(function(t,e){t=We(t),s.onerror=Jt(e),u.fail=e,u.stop=function(e){u.stop=u.continue=u.continuePrimaryKey=u.advance=a,t(e)}});return s.onsuccess=We(function(e){s.onsuccess=t,t()}),u.continue=r,u.continuePrimaryKey=i,u.advance=o,t(),n},t(u)):t(null)},n)})},count:function(e){var t=e.query,i=e.trans,o=t.index,a=t.range;return new Promise(function(t,e){var n=i.objectStore(_),r=o.isPrimaryKey?n:n.index(o.name),n=w(a),r=n?r.count(n):r.count();r.onsuccess=We(function(e){return t(e.target.result)}),r.onerror=Jt(e)})}}}var r,o,a,u=(o=t,a=ln((r=e).objectStoreNames),{schema:{name:r.name,tables:a.map(function(e){return o.objectStore(e)}).map(function(t){var e=t.keyPath,n=t.autoIncrement,r=b(e),i={},n={name:t.name,primaryKey:{name:null,isPrimaryKey:!0,outbound:null==e,compound:r,keyPath:e,autoIncrement:n,unique:!0,extractKey:cn(e)},indexes:ln(t.indexNames).map(function(e){return t.index(e)}).map(function(e){var t=e.name,n=e.unique,r=e.multiEntry,e=e.keyPath,r={name:t,compound:b(e),keyPath:e,unique:n,multiEntry:r,extractKey:cn(e)};return i[hn(e)]=r}),getIndexByKeyPath:function(e){return i[hn(e)]}};return i[":id"]=n.primaryKey,null!=e&&(i[hn(e)]=n.primaryKey),n})},hasGetAll:0<a.length&&"getAll"in o.objectStore(a[0])&&!("undefined"!=typeof navigator&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604)}),t=u.schema,s=u.hasGetAll,u=t.tables.map(n),c={};return u.forEach(function(e){return c[e.name]=e}),{stack:"dbcore",transaction:e.transaction.bind(e),table:function(e){if(!c[e])throw new Error("Table '"+e+"' not found");return c[e]},MIN_KEY:-1/0,MAX_KEY:sn(i),schema:t}}function pn(e,t,n,r){var i=n.IDBKeyRange;return n.indexedDB,{dbcore:(r=dn(t,i,r),e.dbcore.reduce(function(e,t){t=t.create;return g(g({},e),t(e))},r))}}function yn(e,t){var n=e._novip,e=t.db,t=pn(n._middlewares,e,n._deps,t);n.core=t.dbcore,n.tables.forEach(function(e){var t=e.name;n.core.schema.tables.some(function(e){return e.name===t})&&(e.core=n.core.table(t),n[t]instanceof n.Table&&(n[t].core=e.core))})}function vn(e,t,n,i){var o=e._novip;n.forEach(function(n){var r=i[n];t.forEach(function(e){var t=f(e,n);(!t||"value"in t&&void 0===t.value)&&(e===o.Transaction.prototype||e instanceof o.Transaction?c(e,n,{get:function(){return this.table(n)},set:function(e){a(this,n,{value:e,writable:!0,configurable:!0,enumerable:!0})}}):e[n]=new o.Table(n,r))})})}function mn(e,t){var n=e._novip;t.forEach(function(e){for(var t in e)e[t]instanceof n.Table&&delete e[t]})}function gn(e,t){return e._cfg.version-t._cfg.version}function bn(n,r,i,e){var o=n._dbSchema,a=n._createTransaction("readwrite",n._storeNames,o);a.create(i),a._completion.catch(e);var u=a._reject.bind(a),p=Oe.transless||Oe;Je(function(){var e,s,c,l,f,t,h,d;Oe.trans=a,Oe.transless=p,0===r?(x(o).forEach(function(e){wn(i,e,o[e].primKey,o[e].indexes)}),yn(n,i),je.follow(function(){return n.on.populate.fire(a)}).catch(u)):(s=r,c=a,l=i,f=(e=n)._novip,t=[],e=f._versions,h=f._dbSchema=kn(0,f.idbdb,l),d=!1,e.filter(function(e){return e._cfg.version>=s}).forEach(function(u){t.push(function(){var t=h,e=u._cfg.dbschema;En(f,t,l),En(f,e,l),h=f._dbSchema=e;var n=_n(t,e);n.add.forEach(function(e){wn(l,e[0],e[1].primKey,e[1].indexes)}),n.change.forEach(function(e){if(e.recreate)throw new J.Upgrade("Not yet support for changing primary key");var t=l.objectStore(e.name);e.add.forEach(function(e){return xn(t,e)}),e.change.forEach(function(e){t.deleteIndex(e.name),xn(t,e)}),e.del.forEach(function(e){return t.deleteIndex(e)})});var r=u._cfg.contentUpgrade;if(r&&u._cfg.version>s){yn(f,l),c._memoizedTables={},d=!0;var i=P(e);n.del.forEach(function(e){i[e]=t[e]}),mn(f,[f.Transaction.prototype]),vn(f,[f.Transaction.prototype],x(i),i),c.schema=i;var o,a=R(r);a&&$e();n=je.follow(function(){var e;(o=r(c))&&a&&(e=Ze.bind(null,null),o.then(e,e))});return o&&"function"==typeof o.then?je.resolve(o):n.then(function(){return o})}}),t.push(function(e){var t,n,r;d&&mt||(t=u._cfg.dbschema,n=t,r=e,[].slice.call(r.db.objectStoreNames).forEach(function(e){return null==n[e]&&r.db.deleteObjectStore(e)})),mn(f,[f.Transaction.prototype]),vn(f,[f.Transaction.prototype],f._storeNames,f._dbSchema),c.schema=f._dbSchema})}),function e(){return t.length?je.resolve(t.shift()(c.idbtrans)).then(e):je.resolve()}().then(function(){var t,n;n=l,x(t=h).forEach(function(e){n.db.objectStoreNames.contains(e)||wn(n,e,t[e].primKey,t[e].indexes)})}).catch(u))})}function _n(e,t){var n,r={del:[],add:[],change:[]};for(n in e)t[n]||r.del.push(n);for(n in t){var i=e[n],o=t[n];if(i){var a={name:n,def:o,recreate:!1,del:[],add:[],change:[]};if(""+(i.primKey.keyPath||"")!=""+(o.primKey.keyPath||"")||i.primKey.auto!==o.primKey.auto&&!vt)a.recreate=!0,r.change.push(a);else{var u=i.idxByName,s=o.idxByName,c=void 0;for(c in u)s[c]||a.del.push(c);for(c in s){var l=u[c],f=s[c];l?l.src!==f.src&&a.change.push(f):a.add.push(f)}(0<a.del.length||0<a.add.length||0<a.change.length)&&r.change.push(a)}}else r.add.push([n,o])}return r}function wn(e,t,n,r){var i=e.db.createObjectStore(t,n.keyPath?{keyPath:n.keyPath,autoIncrement:n.auto}:{autoIncrement:n.auto});return r.forEach(function(e){return xn(i,e)}),i}function xn(e,t){e.createIndex(t.name,t.keyPath,{unique:t.unique,multiEntry:t.multi})}function kn(e,t,u){var s={};return y(t.objectStoreNames,0).forEach(function(e){for(var t=u.objectStore(e),n=on(an(a=t.keyPath),a||"",!1,!1,!!t.autoIncrement,a&&"string"!=typeof a,!0),r=[],i=0;i<t.indexNames.length;++i){var o=t.index(t.indexNames[i]),a=o.keyPath,o=on(o.name,a,!!o.unique,!!o.multiEntry,!1,a&&"string"!=typeof a,!1);r.push(o)}s[e]=un(e,n,r)}),s}function En(e,t,n){for(var r=e._novip,i=n.db.objectStoreNames,o=0;o<i.length;++o){var a=i[o],u=n.objectStore(a);r._hasGetAll="getAll"in u;for(var s=0;s<u.indexNames.length;++s){var c=u.indexNames[s],l=u.index(c).keyPath,f="string"==typeof l?l:"["+y(l).join("+")+"]";!t[a]||(l=t[a].idxByName[f])&&(l.name=c,delete t[a].idxByName[f],t[a].idxByName[c]=l)}}"undefined"!=typeof navigator&&/Safari/.test(navigator.userAgent)&&!/(Chrome\/|Edge\/)/.test(navigator.userAgent)&&h.WorkerGlobalScope&&h instanceof h.WorkerGlobalScope&&[].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]<604&&(r._hasGetAll=!1)}var Pn=(Kn.prototype._parseStoresSpec=function(r,i){x(r).forEach(function(e){if(null!==r[e]){var t=r[e].split(",").map(function(e,t){var n=(e=e.trim()).replace(/([&*]|\+\+)/g,""),r=/^\[/.test(n)?n.match(/^\[(.*)\]$/)[1].split("+"):n;return on(n,r||null,/\&/.test(e),/\*/.test(e),/\+\+/.test(e),b(r),0===t)}),n=t.shift();if(n.multi)throw new J.Schema("Primary key cannot be multi-valued");t.forEach(function(e){if(e.auto)throw new J.Schema("Only primary key can be marked as autoIncrement (++)");if(!e.keyPath)throw new J.Schema("Index must have a name and cannot be an empty string")}),i[e]=un(e,n,t)}})},Kn.prototype.stores=function(e){var t=this.db;this._cfg.storesSource=this._cfg.storesSource?u(this._cfg.storesSource,e):e;var e=t._versions,n={},r={};return e.forEach(function(e){u(n,e._cfg.storesSource),r=e._cfg.dbschema={},e._parseStoresSpec(n,r)}),t._dbSchema=r,mn(t,[t._allTables,t,t.Transaction.prototype]),vn(t,[t._allTables,t,t.Transaction.prototype,this._cfg.tables],x(r),r),t._storeNames=x(r),this},Kn.prototype.upgrade=function(e){return this._cfg.contentUpgrade=ue(this._cfg.contentUpgrade||Z,e),this},Kn);function Kn(){}function On(e,t){var n=e._dbNamesDB;return n||(n=e._dbNamesDB=new Gn(bt,{addons:[],indexedDB:e,IDBKeyRange:t})).version(1).stores({dbnames:"name"}),n.table("dbnames")}function Sn(e){return e&&"function"==typeof e.databases}function An(e){return Je(function(){return Oe.letThrough=!0,e()})}function Cn(f){var h=f._state,r=f._deps.indexedDB;if(h.isBeingOpened||f.idbdb)return h.dbReadyPromise.then(function(){return h.dbOpenError?lt(h.dbOpenError):f});F&&(h.openCanceller._stackHolder=U()),h.isBeingOpened=!0,h.dbOpenError=null,h.openComplete=!1;var t=h.openCanceller;function e(){if(h.openCanceller!==t)throw new J.DatabaseClosed("db.open() was cancelled")}var n,i=h.dbReadyResolve,d=null,p=!1;return je.race([t,("undefined"==typeof navigator?je.resolve():!navigator.userAgentData&&/Safari\//.test(navigator.userAgent)&&!/Chrom(e|ium)\//.test(navigator.userAgent)&&indexedDB.databases?new Promise(function(e){function t(){return indexedDB.databases().finally(e)}n=setInterval(t,100),t()}).finally(function(){return clearInterval(n)}):Promise.resolve()).then(function(){return new je(function(s,n){if(e(),!r)throw new J.MissingAPI;var c=f.name,l=h.autoSchema?r.open(c):r.open(c,Math.round(10*f.verno));if(!l)throw new J.MissingAPI;l.onerror=Jt(n),l.onblocked=We(f._fireOnBlocked),l.onupgradeneeded=We(function(e){var t;d=l.transaction,h.autoSchema&&!f._options.allowEmptyDB?(l.onerror=$t,d.abort(),l.result.close(),(t=r.deleteDatabase(c)).onsuccess=t.onerror=We(function(){n(new J.NoSuchDatabase("Database "+c+" doesnt exist"))})):(d.onerror=Jt(n),e=e.oldVersion>Math.pow(2,62)?0:e.oldVersion,p=e<1,f._novip.idbdb=l.result,bn(f,e/10,d,n))},n),l.onsuccess=We(function(){d=null;var e,t,n,r,i,o=f._novip.idbdb=l.result,a=y(o.objectStoreNames);if(0<a.length)try{var u=o.transaction(1===(r=a).length?r[0]:r,"readonly");h.autoSchema?(t=o,n=u,(e=(e=f)._novip).verno=t.version/10,n=e._dbSchema=kn(0,t,n),e._storeNames=y(t.objectStoreNames,0),vn(e,[e._allTables],x(n),n)):(En(f,f._dbSchema,u),((i=_n(kn(0,(i=f).idbdb,u),i._dbSchema)).add.length||i.change.some(function(e){return e.add.length||e.change.length}))&&console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")),yn(f,u)}catch(e){}yt.push(f),o.onversionchange=We(function(e){h.vcFired=!0,f.on("versionchange").fire(e)}),o.onclose=We(function(e){f.on("close").fire(e)}),p&&(i=f._deps,u=c,o=i.indexedDB,i=i.IDBKeyRange,Sn(o)||u===bt||On(o,i).put({name:u}).catch(Z)),s()},n)})})]).then(function(){return e(),h.onReadyBeingFired=[],je.resolve(An(function(){return f.on.ready.fire(f.vip)})).then(function e(){if(0<h.onReadyBeingFired.length){var t=h.onReadyBeingFired.reduce(ue,Z);return h.onReadyBeingFired=[],je.resolve(An(function(){return t(f.vip)})).then(e)}})}).finally(function(){h.onReadyBeingFired=null,h.isBeingOpened=!1}).then(function(){return f}).catch(function(e){h.dbOpenError=e;try{d&&d.abort()}catch(e){}return t===h.openCanceller&&f._close(),lt(e)}).finally(function(){h.openComplete=!0,i()})}function jn(t){function e(e){return t.next(e)}var r=n(e),i=n(function(e){return t.throw(e)});function n(n){return function(e){var t=n(e),e=t.value;return t.done?e:e&&"function"==typeof e.then?e.then(r,i):b(e)?Promise.all(e).then(r,i):r(e)}}return n(e)()}function Dn(e,t,n){for(var r=b(e)?e.slice():[e],i=0;i<n;++i)r.push(t);return r}var In={stack:"dbcore",name:"VirtualIndexMiddleware",level:1,create:function(f){return g(g({},f),{table:function(e){var a=f.table(e),t=a.schema,u={},s=[];function c(e,t,n){var r=hn(e),i=u[r]=u[r]||[],o=null==e?0:"string"==typeof e?1:e.length,r=0<t,r=g(g({},n),{isVirtual:r,keyTail:t,keyLength:o,extractKey:cn(e),unique:!r&&n.unique});return i.push(r),r.isPrimaryKey||s.push(r),1<o&&c(2===o?e[0]:e.slice(0,o-1),t+1,n),i.sort(function(e,t){return e.keyTail-t.keyTail}),r}e=c(t.primaryKey.keyPath,0,t.primaryKey);u[":id"]=[e];for(var n=0,r=t.indexes;n<r.length;n++){var i=r[n];c(i.keyPath,0,i)}function l(e){var t,n=e.query.index;return n.isVirtual?g(g({},e),{query:{index:n,range:(t=e.query.range,n=n.keyTail,{type:1===t.type?2:t.type,lower:Dn(t.lower,t.lowerOpen?f.MAX_KEY:f.MIN_KEY,n),lowerOpen:!0,upper:Dn(t.upper,t.upperOpen?f.MIN_KEY:f.MAX_KEY,n),upperOpen:!0})}}):e}return g(g({},a),{schema:g(g({},t),{primaryKey:e,indexes:s,getIndexByKeyPath:function(e){return(e=u[hn(e)])&&e[0]}}),count:function(e){return a.count(l(e))},query:function(e){return a.query(l(e))},openCursor:function(t){var e=t.query.index,r=e.keyTail,n=e.isVirtual,i=e.keyLength;return n?a.openCursor(l(t)).then(function(e){return e&&o(e)}):a.openCursor(t);function o(n){return Object.create(n,{continue:{value:function(e){null!=e?n.continue(Dn(e,t.reverse?f.MAX_KEY:f.MIN_KEY,r)):t.unique?n.continue(n.key.slice(0,i).concat(t.reverse?f.MIN_KEY:f.MAX_KEY,r)):n.continue()}},continuePrimaryKey:{value:function(e,t){n.continuePrimaryKey(Dn(e,f.MAX_KEY,r),t)}},primaryKey:{get:function(){return n.primaryKey}},key:{get:function(){var e=n.key;return 1===i?e[0]:e.slice(0,i)}},value:{get:function(){return n.value}}})}}})}})}};function Bn(i,o,a,u){return a=a||{},u=u||"",x(i).forEach(function(e){var t,n,r;m(o,e)?(t=i[e],n=o[e],"object"==typeof t&&"object"==typeof n&&t&&n?(r=j(t))!==j(n)?a[u+e]=o[e]:"Object"===r?Bn(t,n,a,u+e+"."):t!==n&&(a[u+e]=o[e]):t!==n&&(a[u+e]=o[e])):a[u+e]=void 0}),x(o).forEach(function(e){m(i,e)||(a[u+e]=o[e])}),a}var Tn={stack:"dbcore",name:"HooksMiddleware",level:2,create:function(e){return g(g({},e),{table:function(r){var y=e.table(r),v=y.schema.primaryKey;return g(g({},y),{mutate:function(e){var t=Oe.trans,n=t.table(r).hook,h=n.deleting,d=n.creating,p=n.updating;switch(e.type){case"add":if(d.fire===Z)break;return t._promise("readwrite",function(){return a(e)},!0);case"put":if(d.fire===Z&&p.fire===Z)break;return t._promise("readwrite",function(){return a(e)},!0);case"delete":if(h.fire===Z)break;return t._promise("readwrite",function(){return a(e)},!0);case"deleteRange":if(h.fire===Z)break;return t._promise("readwrite",function(){return function n(r,i,o){return y.query({trans:r,values:!1,query:{index:v,range:i},limit:o}).then(function(e){var t=e.result;return a({type:"delete",keys:t,trans:r}).then(function(e){return 0<e.numFailures?Promise.reject(e.failures[0]):t.length<o?{failures:[],numFailures:0,lastResult:void 0}:n(r,g(g({},i),{lower:t[t.length-1],lowerOpen:!0}),o)})})}(e.trans,e.range,1e4)},!0)}return y.mutate(e);function a(c){var e,t,n,l=Oe.trans,f=c.keys||(t=v,"delete"===(n=c).type?n.keys:n.keys||n.values.map(t.extractKey));if(!f)throw new Error("Keys missing");return"delete"!==(c="add"===c.type||"put"===c.type?g(g({},c),{keys:f}):g({},c)).type&&(c.values=i([],c.values,!0)),c.keys&&(c.keys=i([],c.keys,!0)),e=y,n=f,("add"===(t=c).type?Promise.resolve([]):e.getMany({trans:t.trans,keys:n,cache:"immutable"})).then(function(u){var s=f.map(function(e,t){var n,r,i,o=u[t],a={onerror:null,onsuccess:null};return"delete"===c.type?h.fire.call(a,e,o,l):"add"===c.type||void 0===o?(n=d.fire.call(a,e,c.values[t],l),null==e&&null!=n&&(c.keys[t]=e=n,v.outbound||E(c.values[t],v.keyPath,e))):(n=Bn(o,c.values[t]),(r=p.fire.call(a,n,e,o,l))&&(i=c.values[t],Object.keys(r).forEach(function(e){m(i,e)?i[e]=r[e]:E(i,e,r[e])}))),a});return y.mutate(c).then(function(e){for(var t=e.failures,n=e.results,r=e.numFailures,e=e.lastResult,i=0;i<f.length;++i){var o=(n||f)[i],a=s[i];null==o?a.onerror&&a.onerror(t[i]):a.onsuccess&&a.onsuccess("put"===c.type&&u[i]?c.values[i]:o)}return{failures:t,results:n,numFailures:r,lastResult:e}}).catch(function(t){return s.forEach(function(e){return e.onerror&&e.onerror(t)}),Promise.reject(t)})})}}})}})}};function Rn(e,t,n){try{if(!t)return null;if(t.keys.length<e.length)return null;for(var r=[],i=0,o=0;i<t.keys.length&&o<e.length;++i)0===Rt(t.keys[i],e[o])&&(r.push(n?A(t.values[i]):t.values[i]),++o);return r.length===e.length?r:null}catch(e){return null}}var Fn={stack:"dbcore",level:-1,create:function(t){return{table:function(e){var n=t.table(e);return g(g({},n),{getMany:function(t){if(!t.cache)return n.getMany(t);var e=Rn(t.keys,t.trans._cache,"clone"===t.cache);return e?je.resolve(e):n.getMany(t).then(function(e){return t.trans._cache={keys:t.keys,values:"clone"===t.cache?A(e):e},e})},mutate:function(e){return"add"!==e.type&&(e.trans._cache=null),n.mutate(e)}})}}}};function Mn(e){return!("from"in e)}var Nn=function(e,t){if(!this){var n=new Nn;return e&&"d"in e&&u(n,e),n}u(this,arguments.length?{d:1,from:e,to:1<arguments.length?t:e}:{d:0})};function qn(e,t,n){var r=Rt(t,n);if(!isNaN(r)){if(0<r)throw RangeError();if(Mn(e))return u(e,{from:t,to:n,d:1});var i=e.l,r=e.r;if(Rt(n,e.from)<0)return i?qn(i,t,n):e.l={from:t,to:n,d:1,l:null,r:null},Wn(e);if(0<Rt(t,e.to))return r?qn(r,t,n):e.r={from:t,to:n,d:1,l:null,r:null},Wn(e);Rt(t,e.from)<0&&(e.from=t,e.l=null,e.d=r?r.d+1:1),0<Rt(n,e.to)&&(e.to=n,e.r=null,e.d=e.l?e.l.d+1:1);n=!e.r;i&&!e.l&&Un(e,i),r&&n&&Un(e,r)}}function Un(e,t){Mn(t)||function e(t,n){var r=n.from,i=n.to,o=n.l,n=n.r;qn(t,r,i),o&&e(t,o),n&&e(t,n)}(e,t)}function Ln(e,t){var n=Vn(t),r=n.next();if(r.done)return!1;for(var i=r.value,o=Vn(e),a=o.next(i.from),u=a.value;!r.done&&!a.done;){if(Rt(u.from,i.to)<=0&&0<=Rt(u.to,i.from))return!0;Rt(i.from,u.from)<0?i=(r=n.next(u.from)).value:u=(a=o.next(i.from)).value}return!1}function Vn(e){var n=Mn(e)?null:{s:0,n:e};return{next:function(e){for(var t=0<arguments.length;n;)switch(n.s){case 0:if(n.s=1,t)for(;n.n.l&&Rt(e,n.n.from)<0;)n={up:n,n:n.n.l,s:1};else for(;n.n.l;)n={up:n,n:n.n.l,s:1};case 1:if(n.s=2,!t||Rt(e,n.n.to)<=0)return{value:n.n,done:!1};case 2:if(n.n.r){n.s=3,n={up:n,n:n.n.r,s:0};continue}case 3:n=n.up}return{done:!0}}}}function Wn(e){var t,n,r=((null===(t=e.r)||void 0===t?void 0:t.d)||0)-((null===(n=e.l)||void 0===n?void 0:n.d)||0),i=1<r?"r":r<-1?"l":"";i&&(t="r"==i?"l":"r",n=g({},e),r=e[i],e.from=r.from,e.to=r.to,e[i]=r[i],n[i]=r[t],(e[t]=n).d=zn(n)),e.d=zn(e)}function zn(e){var t=e.r,e=e.l;return(t?e?Math.max(t.d,e.d):t.d:e?e.d:0)+1}r(Nn.prototype,((e={add:function(e){return Un(this,e),this},addKey:function(e){return qn(this,e,e),this},addKeys:function(e){var t=this;return e.forEach(function(e){return qn(t,e,e)}),this}})[D]=function(){return Vn(this)},e));var Yn={stack:"dbcore",level:0,create:function(r){var v=r.schema.name,m=new Nn(r.MIN_KEY,r.MAX_KEY);return g(g({},r),{table:function(d){function e(e){var e=(t=e.query).index,t=t.range;return[e,new Nn(null!==(e=t.lower)&&void 0!==e?e:r.MIN_KEY,null!==(t=t.upper)&&void 0!==t?t:r.MAX_KEY)]}var p=r.table(d),y=p.schema,t=y.primaryKey,c=t.extractKey,l=t.outbound,n=g(g({},p),{mutate:function(e){function n(e){return r[e="idb://"+v+"/"+d+"/"+e]||(r[e]=new Nn)}var t=e.trans,r=t.mutatedParts||(t.mutatedParts={}),i=n(""),s=n(":dels"),c=e.type,t="deleteRange"===e.type?[e.range]:"delete"===e.type?[e.keys]:e.values.length<50?[[],e.values]:[],l=t[0],f=t[1],h=e.trans._cache;return p.mutate(e).then(function(e){var t,o,a,u;return b(l)?("delete"!==c&&(l=e.results),i.addKeys(l),(t=Rn(l,h))||"add"===c||s.addKeys(l),(t||f)&&(o=n,a=t,u=f,y.indexes.forEach(function(t){var n=o(t.name||"");function r(e){return null!=e?t.extractKey(e):null}function i(e){return t.multiEntry&&b(e)?e.forEach(function(e){return n.addKey(e)}):n.addKey(e)}(a||u).forEach(function(e,t){var n=a&&r(a[t]),t=u&&r(u[t]);0!==Rt(n,t)&&(null!=n&&i(n),null!=t&&i(t))})}))):l?(t={from:l.lower,to:l.upper},s.add(t),i.add(t)):(i.add(m),s.add(m),y.indexes.forEach(function(e){return n(e.name).add(m)})),e})}}),f={get:function(e){return[t,new Nn(e.key)]},getMany:function(e){return[t,(new Nn).addKeys(e.keys)]},count:e,query:e,openCursor:e};return x(f).forEach(function(s){n[s]=function(i){var t=Oe.subscr;if(t){var e=function(e){e="idb://"+v+"/"+d+"/"+e;return t[e]||(t[e]=new Nn)},o=e(""),a=e(":dels"),n=f[s](i),r=n[0],n=n[1];if(e(r.name||"").add(n),!r.isPrimaryKey){if("count"!==s){var u="query"===s&&l&&i.values&&p.query(g(g({},i),{values:!1}));return p[s].apply(this,arguments).then(function(t){if("query"===s){if(l&&i.values)return u.then(function(e){e=e.result;return o.addKeys(e),t});var e=i.values?t.result.map(c):t.result;(i.values?o:a).addKeys(e)}else if("openCursor"===s){var n=t,r=i.values;return n&&Object.create(n,{key:{get:function(){return a.addKey(n.primaryKey),n.key}},primaryKey:{get:function(){var e=n.primaryKey;return a.addKey(e),e}},value:{get:function(){return r&&o.addKey(n.primaryKey),n.value}}})}return t})}a.add(m)}}return p[s].apply(this,arguments)}}),n}})}};var Gn=(Hn.prototype.version=function(t){if(isNaN(t)||t<.1)throw new J.Type("Given version is not a positive number");if(t=Math.round(10*t)/10,this.idbdb||this._state.isBeingOpened)throw new J.Schema("Cannot add version when database is open");this.verno=Math.max(this.verno,t);var e=this._versions,n=e.filter(function(e){return e._cfg.version===t})[0];return n||(n=new this.Version(t),e.push(n),e.sort(gn),n.stores({}),this._state.autoSchema=!1,n)},Hn.prototype._whenReady=function(e){var n=this;return this.idbdb&&(this._state.openComplete||Oe.letThrough||this._vip)?e():new je(function(e,t){if(n._state.openComplete)return t(new J.DatabaseClosed(n._state.dbOpenError));if(!n._state.isBeingOpened){if(!n._options.autoOpen)return void t(new J.DatabaseClosed);n.open().catch(Z)}n._state.dbReadyPromise.then(e,t)}).then(e)},Hn.prototype.use=function(e){var t=e.stack,n=e.create,r=e.level,i=e.name;i&&this.unuse({stack:t,name:i});e=this._middlewares[t]||(this._middlewares[t]=[]);return e.push({stack:t,create:n,level:null==r?10:r,name:i}),e.sort(function(e,t){return e.level-t.level}),this},Hn.prototype.unuse=function(e){var t=e.stack,n=e.name,r=e.create;return t&&this._middlewares[t]&&(this._middlewares[t]=this._middlewares[t].filter(function(e){return r?e.create!==r:!!n&&e.name!==n})),this},Hn.prototype.open=function(){return Cn(this)},Hn.prototype._close=function(){var n=this._state,e=yt.indexOf(this);if(0<=e&&yt.splice(e,1),this.idbdb){try{this.idbdb.close()}catch(e){}this._novip.idbdb=null}n.dbReadyPromise=new je(function(e){n.dbReadyResolve=e}),n.openCanceller=new je(function(e,t){n.cancelOpen=t})},Hn.prototype.close=function(){this._close();var e=this._state;this._options.autoOpen=!1,e.dbOpenError=new J.DatabaseClosed,e.isBeingOpened&&e.cancelOpen(e.dbOpenError)},Hn.prototype.delete=function(){var i=this,n=0<arguments.length,o=this._state;return new je(function(r,t){function e(){i.close();var e=i._deps.indexedDB.deleteDatabase(i.name);e.onsuccess=We(function(){var e,t,n;e=i._deps,t=i.name,n=e.indexedDB,e=e.IDBKeyRange,Sn(n)||t===bt||On(n,e).delete(t).catch(Z),r()}),e.onerror=Jt(t),e.onblocked=i._fireOnBlocked}if(n)throw new J.InvalidArgument("Arguments not allowed in db.delete()");o.isBeingOpened?o.dbReadyPromise.then(e):e()})},Hn.prototype.backendDB=function(){return this.idbdb},Hn.prototype.isOpen=function(){return null!==this.idbdb},Hn.prototype.hasBeenClosed=function(){var e=this._state.dbOpenError;return e&&"DatabaseClosed"===e.name},Hn.prototype.hasFailed=function(){return null!==this._state.dbOpenError},Hn.prototype.dynamicallyOpened=function(){return this._state.autoSchema},Object.defineProperty(Hn.prototype,"tables",{get:function(){var t=this;return x(this._allTables).map(function(e){return t._allTables[e]})},enumerable:!1,configurable:!0}),Hn.prototype.transaction=function(){var e=function(e,t,n){var r=arguments.length;if(r<2)throw new J.InvalidArgument("Too few arguments");for(var i=new Array(r-1);--r;)i[r-1]=arguments[r];return n=i.pop(),[e,K(i),n]}.apply(this,arguments);return this._transaction.apply(this,e)},Hn.prototype._transaction=function(e,t,n){var r=this,i=Oe.trans;i&&i.db===this&&-1===e.indexOf("!")||(i=null);var o,a,u=-1!==e.indexOf("?");e=e.replace("!","").replace("?","");try{if(a=t.map(function(e){e=e instanceof r.Table?e.name:e;if("string"!=typeof e)throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");return e}),"r"==e||e===_t)o=_t;else{if("rw"!=e&&e!=wt)throw new J.InvalidArgument("Invalid transaction mode: "+e);o=wt}if(i){if(i.mode===_t&&o===wt){if(!u)throw new J.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");i=null}i&&a.forEach(function(e){if(i&&-1===i.storeNames.indexOf(e)){if(!u)throw new J.SubTransaction("Table "+e+" not included in parent transaction.");i=null}}),u&&i&&!i.active&&(i=null)}}catch(n){return i?i._promise(null,function(e,t){t(n)}):lt(n)}var s=function i(o,a,u,s,c){return je.resolve().then(function(){var e=Oe.transless||Oe,t=o._createTransaction(a,u,o._dbSchema,s),e={trans:t,transless:e};if(s)t.idbtrans=s.idbtrans;else try{t.create(),o._state.PR1398_maxLoop=3}catch(e){return e.name===Q.InvalidState&&o.isOpen()&&0<--o._state.PR1398_maxLoop?(console.warn("Dexie: Need to reopen db"),o._close(),o.open().then(function(){return i(o,a,u,null,c)})):lt(e)}var n,r=R(c);return r&&$e(),e=je.follow(function(){var e;(n=c.call(t,t))&&(r?(e=Ze.bind(null,null),n.then(e,e)):"function"==typeof n.next&&"function"==typeof n.throw&&(n=jn(n)))},e),(n&&"function"==typeof n.then?je.resolve(n).then(function(e){return t.active?e:lt(new J.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))}):e.then(function(){return n})).then(function(e){return s&&t._resolve(),t._completion.then(function(){return e})}).catch(function(e){return t._reject(e),lt(e)})})}.bind(null,this,o,a,i,n);return i?i._promise(o,s,"lock"):Oe.trans?it(Oe.transless,function(){return r._whenReady(s)}):this._whenReady(s)},Hn.prototype.table=function(e){if(!m(this._allTables,e))throw new J.InvalidTable("Table "+e+" does not exist");return this._allTables[e]},Hn);function Hn(e,t){var o=this;this._middlewares={},this.verno=0;var n=Hn.dependencies;this._options=t=g({addons:Hn.addons,autoOpen:!0,indexedDB:n.indexedDB,IDBKeyRange:n.IDBKeyRange},t),this._deps={indexedDB:t.indexedDB,IDBKeyRange:t.IDBKeyRange};n=t.addons;this._dbSchema={},this._versions=[],this._storeNames=[],this._allTables={},this.idbdb=null,this._novip=this;var a,r,u,i,s,c={dbOpenError:null,isBeingOpened:!1,onReadyBeingFired:null,openComplete:!1,dbReadyResolve:Z,dbReadyPromise:null,cancelOpen:Z,openCanceller:null,autoSchema:!0,PR1398_maxLoop:3};c.dbReadyPromise=new je(function(e){c.dbReadyResolve=e}),c.openCanceller=new je(function(e,t){c.cancelOpen=t}),this._state=c,this.name=e,this.on=Ot(this,"populate","blocked","versionchange","close",{ready:[ue,Z]}),this.on.ready.subscribe=p(this.on.ready.subscribe,function(i){return function(n,r){Hn.vip(function(){var t,e=o._state;e.openComplete?(e.dbOpenError||je.resolve().then(n),r&&i(n)):e.onReadyBeingFired?(e.onReadyBeingFired.push(n),r&&i(n)):(i(n),t=o,r||i(function e(){t.on.ready.unsubscribe(n),t.on.ready.unsubscribe(e)}))})}}),this.Collection=(a=this,St(Nt.prototype,function(e,t){this.db=a;var n=kt,r=null;if(t)try{n=t()}catch(e){r=e}var i=e._ctx,t=i.table,e=t.hook.reading.fire;this._ctx={table:t,index:i.index,isPrimKey:!i.index||t.schema.primKey.keyPath&&i.index===t.schema.primKey.name,range:n,keysOnly:!1,dir:"next",unique:"",algorithm:null,filter:null,replayFilter:null,justLimit:!0,isMatch:null,offset:0,limit:1/0,error:r,or:i.or,valueMapper:e!==ee?e:null}})),this.Table=(r=this,St(Pt.prototype,function(e,t,n){this.db=r,this._tx=n,this.name=e,this.schema=t,this.hook=r._allTables[e]?r._allTables[e].hook:Ot(null,{creating:[re,Z],reading:[te,ee],updating:[oe,Z],deleting:[ie,Z]})})),this.Transaction=(u=this,St(nn.prototype,function(e,t,n,r,i){var o=this;this.db=u,this.mode=e,this.storeNames=t,this.schema=n,this.chromeTransactionDurability=r,this.idbtrans=null,this.on=Ot(this,"complete","error","abort"),this.parent=i||null,this.active=!0,this._reculock=0,this._blockedFuncs=[],this._resolve=null,this._reject=null,this._waitingFor=null,this._waitingQueue=null,this._spinCount=0,this._completion=new je(function(e,t){o._resolve=e,o._reject=t}),this._completion.then(function(){o.active=!1,o.on.complete.fire()},function(e){var t=o.active;return o.active=!1,o.on.error.fire(e),o.parent?o.parent._reject(e):t&&o.idbtrans&&o.idbtrans.abort(),lt(e)})})),this.Version=(i=this,St(Pn.prototype,function(e){this.db=i,this._cfg={version:e,storesSource:null,dbschema:{},tables:{},contentUpgrade:null}})),this.WhereClause=(s=this,St(Qt.prototype,function(e,t,n){this.db=s,this._ctx={table:e,index:":id"===t?null:t,or:n};var r=s._deps.indexedDB;if(!r)throw new J.MissingAPI;this._cmp=this._ascending=r.cmp.bind(r),this._descending=function(e,t){return r.cmp(t,e)},this._max=function(e,t){return 0<r.cmp(e,t)?e:t},this._min=function(e,t){return r.cmp(e,t)<0?e:t},this._IDBKeyRange=s._deps.IDBKeyRange})),this.on("versionchange",function(e){0<e.newVersion?console.warn("Another connection wants to upgrade database '"+o.name+"'. Closing db now to resume the upgrade."):console.warn("Another connection wants to delete database '"+o.name+"'. Closing db now to resume the delete request."),o.close()}),this.on("blocked",function(e){!e.newVersion||e.newVersion<e.oldVersion?console.warn("Dexie.delete('"+o.name+"') was blocked"):console.warn("Upgrade '"+o.name+"' blocked by other connection holding version "+e.oldVersion/10)}),this._maxKey=sn(t.IDBKeyRange),this._createTransaction=function(e,t,n,r){return new o.Transaction(e,t,n,o._options.chromeTransactionDurability,r)},this._fireOnBlocked=function(t){o.on("blocked").fire(t),yt.filter(function(e){return e.name===o.name&&e!==o&&!e._state.vcFired}).map(function(e){return e.on("versionchange").fire(t)})},this.use(In),this.use(Tn),this.use(Yn),this.use(Fn),this.vip=Object.create(this,{_vip:{value:!0}}),n.forEach(function(e){return e(o)})}var e="undefined"!=typeof Symbol&&"observable"in Symbol?Symbol.observable:"@@observable",Qn=(Xn.prototype.subscribe=function(e,t,n){return this._subscribe(e&&"function"!=typeof e?e:{next:e,error:t,complete:n})},Xn.prototype[e]=function(){return this},Xn);function Xn(e){this._subscribe=e}function Jn(t,n){return x(n).forEach(function(e){Un(t[e]||(t[e]=new Nn),n[e])}),t}function $n(d){return new Qn(function(n){var r=R(d);var i=!1,o={},a={},u={get closed(){return i},unsubscribe:function(){i=!0,tn.storagemutated.unsubscribe(f)}};n.start&&n.start(u);var s=!1,c=!1;function l(){return x(a).some(function(e){return o[e]&&Ln(o[e],a[e])})}var f=function(e){Jn(o,e),l()&&h()},h=function(){var t,e;s||i||(o={},e=function(e){r&&$e();var t=function(){return Je(d,{subscr:e,trans:null})},t=Oe.trans?it(Oe.transless,t):t();return r&&t.then(Ze,Ze),t}(t={}),c||(tn(Zt,f),c=!0),s=!0,Promise.resolve(e).then(function(e){s=!1,i||(l()?h():(o={},a=t,n.next&&n.next(e)))},function(e){s=!1,n.error&&n.error(e),u.unsubscribe()}))};return h(),u})}try{nr={indexedDB:h.indexedDB||h.mozIndexedDB||h.webkitIndexedDB||h.msIndexedDB,IDBKeyRange:h.IDBKeyRange||h.webkitIDBKeyRange}}catch(e){nr={indexedDB:null,IDBKeyRange:null}}var Zn=Gn;function er(e){var t=rr;try{rr=!0,tn.storagemutated.fire(e)}finally{rr=t}}r(Zn,g(g({},V),{delete:function(e){return new Zn(e,{addons:[]}).delete()},exists:function(e){return new Zn(e,{addons:[]}).open().then(function(e){return e.close(),!0}).catch("NoSuchDatabaseError",function(){return!1})},getDatabaseNames:function(e){try{return t=Zn.dependencies,n=t.indexedDB,t=t.IDBKeyRange,(Sn(n)?Promise.resolve(n.databases()).then(function(e){return e.map(function(e){return e.name}).filter(function(e){return e!==bt})}):On(n,t).toCollection().primaryKeys()).then(e)}catch(e){return lt(new J.MissingAPI)}var t,n},defineClass:function(){return function(e){u(this,e)}},ignoreTransaction:function(e){return Oe.trans?it(Oe.transless,e):e()},vip:An,async:function(t){return function(){try{var e=jn(t.apply(this,arguments));return e&&"function"==typeof e.then?e:je.resolve(e)}catch(e){return lt(e)}}},spawn:function(e,t,n){try{var r=jn(e.apply(n,t||[]));return r&&"function"==typeof r.then?r:je.resolve(r)}catch(e){return lt(e)}},currentTransaction:{get:function(){return Oe.trans||null}},waitFor:function(e,t){t=je.resolve("function"==typeof e?Zn.ignoreTransaction(e):e).timeout(t||6e4);return Oe.trans?Oe.trans.waitFor(t):t},Promise:je,debug:{get:function(){return F},set:function(e){M(e,"dexie"===e?function(){return!0}:ft)}},derive:o,extend:u,props:r,override:p,Events:Ot,on:tn,liveQuery:$n,extendObservabilitySet:Jn,getByKeyPath:k,setByKeyPath:E,delByKeyPath:function(t,e){"string"==typeof e?E(t,e,void 0):"length"in e&&[].map.call(e,function(e){E(t,e,void 0)})},shallowClone:P,deepClone:A,getObjectDiff:Bn,cmp:Rt,asap:_,minKey:-1/0,addons:[],connections:yt,errnames:Q,dependencies:nr,semVer:"3.2.3",version:"3.2.3".split(".").map(function(e){return parseInt(e)}).reduce(function(e,t,n){return e+t/Math.pow(10,2*n)})})),Zn.maxKey=sn(Zn.dependencies.IDBKeyRange),"undefined"!=typeof dispatchEvent&&"undefined"!=typeof addEventListener&&(tn(Zt,function(e){var t;rr||(vt?(t=document.createEvent("CustomEvent")).initCustomEvent(en,!0,!0,e):t=new CustomEvent(en,{detail:e}),rr=!0,dispatchEvent(t),rr=!1)}),addEventListener(en,function(e){e=e.detail;rr||er(e)}));var tr,nr,rr=!1;return"undefined"!=typeof BroadcastChannel?("function"==typeof(tr=new BroadcastChannel(en)).unref&&tr.unref(),tn(Zt,function(e){rr||tr.postMessage(e)}),tr.onmessage=function(e){e.data&&er(e.data)}):"undefined"!=typeof self&&"undefined"!=typeof navigator&&(tn(Zt,function(t){try{rr||("undefined"!=typeof localStorage&&localStorage.setItem(en,JSON.stringify({trig:Math.random(),changedParts:t})),"object"==typeof self.clients&&i([],self.clients.matchAll({includeUncontrolled:!0}),!0).forEach(function(e){return e.postMessage({type:en,changedParts:t})}))}catch(e){}}),"undefined"!=typeof addEventListener&&addEventListener("storage",function(e){e.key!==en||(e=JSON.parse(e.newValue))&&er(e.changedParts)}),(nr=self.document&&navigator.serviceWorker)&&nr.addEventListener("message",function(e){e=e.data;e&&e.type===en&&er(e.changedParts)})),je.rejectionMapper=function(e,t){return!e||e instanceof z||e instanceof TypeError||e instanceof SyntaxError||!e.name||!$[e.name]?e:(t=new $[e.name](t||e.message,e),"stack"in e&&c(t,"stack",{get:function(){return this.inner.stack}}),t)},M(F,ft),g(Gn,Object.freeze({__proto__:null,Dexie:Gn,liveQuery:$n,default:Gn,RangeSet:Nn,mergeRanges:Un,rangesOverlap:Ln}),{default:Gn}),Gn});</script>
    
    <!-- <script src="https://unpkg.com/dexie-export-import@4.0.6/dist/dexie-export-import.js"></script> -->
    <script>!function(e,t){"object"==typeof exports&&"undchat#editefined"!=typeof module?t(exports,require("dexie")):"function"==typeof define&&define.amd?define(["exports","dexie"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,t(e.DexieExportImport={},e.Dexie))}(this,function(e,t){"use strict";var n,r=(n=t)&&"object"==typeof n&&"default"in n?n:{default:n};function i(e,t,n,r){return new(n||(n=Promise))(function(i,o){function a(e){try{s(r.next(e))}catch(t){o(t)}}function u(e){try{s(r.throw(e))}catch(t){o(t)}}function s(e){var t;e.done?i(e.value):((t=e.value)instanceof n?t:new n(function(e){e(t)})).then(a,u)}s((r=r.apply(e,t||[])).next())})}function o(e,t){var n,r,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(o){return function(u){return function o(u){if(n)throw TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&u[0]?r.return:u[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,u[1])).done)return i;switch(r=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return a.label++,{value:u[1],done:!1};case 5:a.label++,r=u[1],u=[0];continue;case 7:u=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===u[0]||2===u[0])){a=0;continue}if(3===u[0]&&(!i||u[1]>i[0]&&u[1]<i[3])){a.label=u[1];break}if(6===u[0]&&a.label<i[1]){a.label=i[1],i=u;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(u);break}i[2]&&a.ops.pop(),a.trys.pop();continue}u=t.call(e,a)}catch(s){u=[6,s],r=0}finally{n=i=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([o,u])}}}function a(e,t){return new Promise(function(n,r){var i=new FileReader;i.onabort=function(e){return r(Error("file read aborted"))},i.onerror=function(e){return r(e.target.error)},i.onload=function(e){return n(e.target.result)},"binary"===t?i.readAsArrayBuffer(e):i.readAsText(e)})}function u(e,t){if("undefined"==typeof FileReaderSync)throw Error("FileReaderSync missing. Reading blobs synchronously requires code to run from within a web worker. Use TSON.encapsulateAsync() to do it from the main thread.");var n=new FileReaderSync;return"binary"===t?n.readAsArrayBuffer(e):n.readAsText(e)}var s="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function c(e,t){return e(t={exports:{}},t.exports),t.exports}for(var f=c(function(e,t){var n,r;r=function(){function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t,n,r,i,o,a){try{var u=e[o](a),s=u.value}catch(c){n(c);return}u.done?t(s):Promise.resolve(s).then(r,i)}function n(e){return function(){var n=this,r=arguments;return new Promise(function(i,o){var a=e.apply(n,r);function u(e){t(a,i,o,u,s,"next",e)}function s(e){t(a,i,o,u,s,"throw",e)}u(void 0)})}}function r(e,t){if(!(e instanceof t))throw TypeError("Cannot call a class as a function")}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return(t in e)?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach(function(t){o(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function s(e,t){return function e(t){if(Array.isArray(t))return t}(e)||function e(t,n){if((Symbol.iterator in Object(t))||"[object Arguments]"===Object.prototype.toString.call(t)){var r=[],i=!0,o=!1,a=void 0;try{for(var u,s=t[Symbol.iterator]();!(i=(u=s.next()).done)&&(r.push(u.value),!n||r.length!==n);i=!0);}catch(c){o=!0,a=c}finally{try{i||null==s.return||s.return()}finally{if(o)throw a}}return r}}(e,t)||function e(){throw TypeError("Invalid attempt to destructure non-iterable instance")}()}var c=function e(t){r(this,e),this.p=new Promise(t)};c.__typeson__type__="TypesonPromise","undefined"!=typeof Symbol&&(c.prototype[Symbol.toStringTag]="TypesonPromise"),c.prototype.then=function(e,t){var n=this;return new c(function(r,i){n.p.then(function(t){r(e?e(t):t)}).catch(function(e){return t?t(e):Promise.reject(e)}).then(r,i)})},c.prototype.catch=function(e){return this.then(null,e)},c.resolve=function(e){return new c(function(t){t(e)})},c.reject=function(e){return new c(function(t,n){n(e)})},["all","race"].forEach(function(e){c[e]=function(t){return new c(function(n,r){Promise[e](t.map(function(e){return e&&e.constructor&&"TypesonPromise"===e.constructor.__typeson__type__?e.p:e})).then(n,r)})}});var f={}.toString,l={}.hasOwnProperty,p=Object.getPrototypeOf,y=l.toString;function h(e,t){return $(e)&&"function"==typeof e.then&&(!t||"function"==typeof e.catch)}function d(e){return f.call(e).slice(8,-1)}function v(t,n){if(!t||"object"!==e(t))return!1;var r=p(t);if(!r)return null===n;var i=l.call(r,"constructor")&&r.constructor;return"function"!=typeof i?null===n:n===i||null!==n&&y.call(i)===y.call(n)||"function"==typeof n&&"string"==typeof i.__typeson__type__&&i.__typeson__type__===n.__typeson__type__}function b(e){return!!e&&"Object"===d(e)&&(!p(e)||v(e,Object))}function $(t){return t&&"object"===e(t)}function g(e){return e.replace(/~/g,"~0").replace(/\./g,"~1")}function m(e){return e.replace(/~1/g,".").replace(/~0/g,"~")}function w(e,t){if(""===t)return e;var n=t.indexOf(".");if(n>-1){var r=e[m(t.slice(0,n))];return void 0===r?void 0:w(r,t.slice(n+1))}return e[m(t)]}function _(e,t,n){if(""===t)return n;var r=t.indexOf(".");return r>-1?_(e[m(t.slice(0,r))],t.slice(r+1),n):(e[m(t)]=n,e)}var O=Object.keys,E=Array.isArray,T={}.hasOwnProperty,A=["type","replaced","iterateIn","iterateUnsetNumeric"];function N(e,t){if(""===e.keypath)return -1;var n=e.keypath.match(/\./g)||0,r=t.keypath.match(/\./g)||0;return n&&(n=n.length),r&&(r=r.length),n>r?-1:n<r?1:e.keypath<t.keypath?-1:e.keypath>t.keypath}var S=function(){var t,o,a;function f(e){r(this,f),this.options=e,this.plainObjectReplacers=[],this.nonplainObjectReplacers=[],this.revivers={},this.types={}}return t=f,o=[{key:"stringify",value:function e(t,n,r,i){i=u({},this.options,{},i,{stringification:!0});var o=this.encapsulate(t,null,i);return E(o)?JSON.stringify(o[0],n,r):o.then(function(e){return JSON.stringify(e,n,r)})}},{key:"stringifySync",value:function e(t,n,r,i){return this.stringify(t,n,r,u({throwOnBadSyncType:!0},i,{sync:!0}))}},{key:"stringifyAsync",value:function e(t,n,r,i){return this.stringify(t,n,r,u({throwOnBadSyncType:!0},i,{sync:!1}))}},{key:"parse",value:function e(t,n,r){return r=u({},this.options,{},r,{parse:!0}),this.revive(JSON.parse(t,n),r)}},{key:"parseSync",value:function e(t,n,r){return this.parse(t,n,u({throwOnBadSyncType:!0},r,{sync:!0}))}},{key:"parseAsync",value:function e(t,n,r){return this.parse(t,n,u({throwOnBadSyncType:!0},r,{sync:!1}))}},{key:"specialTypeNames",value:function e(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.returnTypeNames=!0,this.encapsulate(t,n,r)}},{key:"rootTypeName",value:function e(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.iterateNone=!0,this.encapsulate(t,n,r)}},{key:"encapsulate",value:function t(r,i,o){var a=(o=u({sync:!0},this.options,{},o)).sync,l=this,p={},y=[],h=[],d=[],m=!("cyclic"in o)||o.cyclic,w=o.encapsulateObserver,_=I("",r,m,i||{},d);function N(e){var t,n=Object.values(p);if(o.iterateNone)return n.length?n[0]:f.getJSONType(e);if(n.length){if(o.returnTypeNames)return function e(t){if(Array.isArray(t)){for(var n=0,r=Array(t.length);n<t.length;n++)r[n]=t[n];return r}}(t=new Set(n))||function e(t){if((Symbol.iterator in Object(t))||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function e(){throw TypeError("Invalid attempt to spread non-iterable instance")}();!e||!b(e)||T.call(e,"$types")?e={$:e,$types:{$:p}}:e.$types=p}else $(e)&&T.call(e,"$types")&&(e={$:e,$types:!0});return!o.returnTypeNames&&e}function S(e,t){return x.apply(this,arguments)}function x(){return(x=n(regeneratorRuntime.mark(function e(t,r){var i;return regeneratorRuntime.wrap(function e(o){for(;;)switch(o.prev=o.next){case 0:return o.next=2,Promise.all(r.map(function(e){return e[1].p}));case 2:return i=o.sent,o.next=5,Promise.all(i.map(function(){var e=n(regeneratorRuntime.mark(function e(n){var i,o,a,u,f,l,p,y,h,d,b,$,g,m;return regeneratorRuntime.wrap(function e(w){for(;;)switch(w.prev=w.next){case 0:if(i=[],u=(a=s(o=r.splice(0,1),1))[0],l=(f=s(u,7))[0],p=f[2],y=f[3],h=f[4],d=f[5],$=I(l,n,p,y,i,!0,b=f[6]),g=v($,c),!(l&&g)){w.next=11;break}return w.next=8,$.p;case 8:return m=w.sent,h[d]=m,w.abrupt("return",S(t,i));case 11:return l?h[d]=$:t=g?$.p:$,w.abrupt("return",S(t,i));case 13:case"end":return w.stop()}},e)}));return function(t){return e.apply(this,arguments)}}()));case 5:return o.abrupt("return",t);case 6:case"end":return o.stop()}},e)}))).apply(this,arguments)}function k(e,t,n){Object.assign(e,t);var r=A.map(function(t){var n=e[t];return delete e[t],n});n(),A.forEach(function(t,n){e[t]=r[n]})}function I(t,n,r,i,a,u,s){var d,$,m={},_=e(n),A=w?function(e){var o=s||i.type||f.getJSONType(n);w(Object.assign(e||m,{keypath:t,value:n,cyclic:r,stateObj:i,promisesData:a,resolvingTypesonPromise:u,awaitingTypesonPromise:v(n,c)},{type:o}))}:null;if(["string","boolean","number","undefined"].includes(_))return void 0===n||"number"===_&&(isNaN(n)||n===-1/0||n===1/0)?(d=i.replaced?n:P(t,n,i,a,!1,u,A))!==n&&(m={replaced:d}):d=n,A&&A(),d;if(null===n)return A&&A(),n;if(r&&!i.iterateIn&&!i.iterateUnsetNumeric&&n&&"object"===e(n)){var N=y.indexOf(n);if(!(N<0))return p[t]="#",A&&A({cyclicKeypath:h[N]}),"#"+h[N];!0===r&&(y.push(n),h.push(t))}var S=b(n),x=E(n),C=(S||x)&&(!l.plainObjectReplacers.length||i.replaced)||i.iterateIn?n:P(t,n,i,a,S||x,null,A);if(C!==n?(d=C,m={replaced:C}):""===t&&v(n,c)?(a.push([t,n,r,i,void 0,void 0,i.type]),d=n):x&&"object"!==i.iterateIn||"array"===i.iterateIn?m={clone:$=Array(n.length)}:(["function","symbol"].includes(e(n))||("toJSON"in n)||v(n,c)||v(n,Promise)||v(n,ArrayBuffer))&&!S&&"object"!==i.iterateIn?d=n:($={},i.addLength&&($.length=n.length),m={clone:$}),A&&A(),o.iterateNone)return $||d;if(!$)return d;if(i.iterateIn){var j=function e(o){var s={ownKeys:T.call(n,o)};k(i,s,function(){var e=t+(t?".":"")+g(o),s=I(e,n[o],Boolean(r),i,a,u);v(s,c)?a.push([e,s,Boolean(r),i,$,o,i.type]):void 0!==s&&($[o]=s)})};for(var B in n)j(B);A&&A({endIterateIn:!0,end:!0})}else O(n).forEach(function(e){var o=t+(t?".":"")+g(e);k(i,{ownKeys:!0},function(){var t=I(o,n[e],Boolean(r),i,a,u);v(t,c)?a.push([o,t,Boolean(r),i,$,e,i.type]):void 0!==t&&($[e]=t)})}),A&&A({endIterateOwn:!0,end:!0});if(i.iterateUnsetNumeric){for(var L=n.length,U=function e(o){if(!(o in n)){var s=t+(t?".":"")+o;k(i,{ownKeys:!1},function(){var e=I(s,void 0,Boolean(r),i,a,u);v(e,c)?a.push([s,e,Boolean(r),i,$,o,i.type]):void 0!==e&&($[o]=e)})}},R=0;R<L;R++)U(R);A&&A({endIterateUnsetNumeric:!0,end:!0})}return $}function P(e,t,n,r,i,o,u){for(var s=i?l.plainObjectReplacers:l.nonplainObjectReplacers,c=s.length;c--;){var f=s[c];if(f.test(t,n)){var y=f.type;if(l.revivers[y]){var h=p[e];p[e]=h?[y].concat(h):y}if(Object.assign(n,{type:y,replaced:!0}),(a||!f.replaceAsync)&&!f.replace)return u&&u({typeDetected:!0}),I(e,t,m&&"readonly",n,r,o,y);return u&&u({replacing:!0}),I(e,f[a||!f.replaceAsync?"replace":"replaceAsync"](t,n),m&&"readonly",n,r,o,y)}}return t}return d.length?a&&o.throwOnBadSyncType?function(){throw TypeError("Sync method requested but async result obtained")}():Promise.resolve(S(_,d)).then(N):!a&&o.throwOnBadSyncType?function(){throw TypeError("Async method requested but sync result obtained")}():o.stringification&&a?[N(_)]:a?N(_):Promise.resolve(N(_))}},{key:"encapsulateSync",value:function e(t,n,r){return this.encapsulate(t,n,u({throwOnBadSyncType:!0},r,{sync:!0}))}},{key:"encapsulateAsync",value:function e(t,n,r){return this.encapsulate(t,n,u({throwOnBadSyncType:!0},r,{sync:!1}))}},{key:"revive",value:function e(t,n){var r,i=t&&t.$types;if(!i)return t;if(!0===i)return t.$;var o=(n=u({sync:!0},this.options,{},n)).sync,a=[],f={},l=!0;i.$&&b(i.$)&&(t=t.$,i=i.$,l=!1);var p=this;function y(e,t){var n=s(p.revivers[e]||[],1)[0];if(!n)throw Error("Unregistered type: "+e);return!o||("revive"in n)?n[o&&n.revive?"revive":!o&&n.reviveAsync?"reviveAsync":"revive"](t,f):t}var d=[];function $(e){return v(e,x)?void 0:e}var m=function e(){var n=[];if(Object.entries(i).forEach(function(e){var t=s(e,2),r=t[0],o=t[1];"#"!==o&&[].concat(o).forEach(function(e){s(p.revivers[e]||[null,{}],2)[1].plain&&(n.push({keypath:r,type:e}),delete i[r])})}),n.length)return n.sort(N).reduce(function e(n,r){var i=r.keypath,o=r.type;if(h(n))return n.then(function(t){return e(t,{keypath:i,type:o})});var a=w(t,i);if(a=y(o,a),v(a,c))return a.then(function(e){var n=_(t,i,e);n===e&&(t=n)});var u=_(t,i,a);u===a&&(t=u)},void 0)}();return v(m,c)?r=m.then(function(){return t}):(r=function e(t,n,r,o,u){if(!l||"$types"!==t){var f=i[t],p=E(n);if(p||b(n)){var h=p?Array(n.length):{};for(O(n).forEach(function(i){var o=e(t+(t?".":"")+g(i),n[i],r||h,h,i),a=function e(t){return v(t,x)?h[i]=void 0:void 0!==t&&(h[i]=t),t};v(o,c)?d.push(o.then(function(e){return a(e)})):a(o)}),n=h;a.length;){var $=s(a[0],4),m=$[0],_=$[1],T=$[2],A=$[3],N=w(m,_);if(void 0!==N)T[A]=N;else break;a.splice(0,1)}}if(!f)return n;if("#"===f){var S=w(r,n.slice(1));return void 0===S&&a.push([r,n.slice(1),void 0,void 0]),S}return[].concat(f).reduce(function e(t,n){return v(t,c)?t.then(function(t){return e(t,n)}):y(n,t)},n)}}("",t,null),d.length&&(r=c.resolve(r).then(function(e){return c.all([e].concat(d))}).then(function(e){return s(e,1)[0]}))),h(r)?o&&n.throwOnBadSyncType?function(){throw TypeError("Sync method requested but async result obtained")}():v(r,c)?r.p.then($):r:!o&&n.throwOnBadSyncType?function(){throw TypeError("Async method requested but sync result obtained")}():o?$(r):Promise.resolve($(r))}},{key:"reviveSync",value:function e(t,n){return this.revive(t,u({throwOnBadSyncType:!0},n,{sync:!0}))}},{key:"reviveAsync",value:function e(t,n){return this.revive(t,u({throwOnBadSyncType:!0},n,{sync:!1}))}},{key:"register",value:function e(t,n){return n=n||{},[].concat(t).forEach(function e(t){var r=this;if(E(t))return t.map(function(t){return e.call(r,t)});t&&O(t).forEach(function(e){if("#"===e)throw TypeError("# cannot be used as a type name as it is reserved for cyclic objects");if(f.JSON_TYPES.includes(e))throw TypeError("Plain JSON object types are reserved as type names");var r=t[e],i=r&&r.testPlainObjects?this.plainObjectReplacers:this.nonplainObjectReplacers,o=i.filter(function(t){return t.type===e});if(o.length&&(i.splice(i.indexOf(o[0]),1),delete this.revivers[e],delete this.types[e]),"function"==typeof r){var a=r;r={test:function e(t){return t&&t.constructor===a},replace:function e(t){return u({},t)},revive:function e(t){return Object.assign(Object.create(a.prototype),t)}}}else if(E(r)){var c,l=r,p=s(l,3),y=p[0];r={test:y,replace:p[1],revive:p[2]}}if(r&&r.test){var h={type:e,test:r.test.bind(r)};r.replace&&(h.replace=r.replace.bind(r)),r.replaceAsync&&(h.replaceAsync=r.replaceAsync.bind(r));var d="number"==typeof n.fallback?n.fallback:n.fallback?0:1/0;if(r.testPlainObjects?this.plainObjectReplacers.splice(d,0,h):this.nonplainObjectReplacers.splice(d,0,h),r.revive||r.reviveAsync){var v={};r.revive&&(v.revive=r.revive.bind(r)),r.reviveAsync&&(v.reviveAsync=r.reviveAsync.bind(r)),this.revivers[e]=[v,{plain:r.testPlainObjects}]}this.types[e]=r}},this)},this),this}}],i(t.prototype,o),a&&i(t,a),f}(),x=function e(){r(this,e)};return x.__typeson__type__="TypesonUndefined",S.Undefined=x,S.Promise=c,S.isThenable=h,S.toStringTag=d,S.hasConstructorOf=v,S.isObject=$,S.isPlainObject=b,S.isUserObject=function e(t){if(!t||"Object"!==d(t))return!1;var n=p(t);return!n||v(t,Object)||e(n)},S.escapeKeyPathComponent=g,S.unescapeKeyPathComponent=m,S.getByKeyPath=w,S.getJSONType=function t(n){return null===n?"null":Array.isArray(n)?"array":e(n)},S.JSON_TYPES=["null","boolean","number","string","array","object"],S},e.exports=r()}),l=c(function(e,t){var n,r;r=function(){function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function n(e,t,n){return(t in e)?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function i(e){return function e(t){if(Array.isArray(t))return o(t)}(e)||function e(t){if("undefined"!=typeof Symbol&&(Symbol.iterator in Object(t)))return Array.from(t)}(e)||function e(t,n){if(t){if("string"==typeof t)return o(t,n);var r=Object.prototype.toString.call(t).slice(8,-1);if("Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r)return Array.from(t);if("Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))return o(t,n)}}(e)||function e(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function e(t){return typeof t}:function e(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(e)}function u(e,t){if(!(e instanceof t))throw TypeError("Cannot call a class as a function")}function c(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function f(e,t,n){return(t in e)?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,r)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach(function(t){f(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function y(e,t){return function e(t){if(Array.isArray(t))return t}(e)||function e(t,n){if("undefined"!=typeof Symbol&&(Symbol.iterator in Object(t))){var r=[],i=!0,o=!1,a=void 0;try{for(var u,s=t[Symbol.iterator]();!(i=(u=s.next()).done)&&(r.push(u.value),!n||r.length!==n);i=!0);}catch(c){o=!0,a=c}finally{try{i||null==s.return||s.return()}finally{if(o)throw a}}return r}}(e,t)||h(e,t)||function e(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function h(e,t){if(e){if("string"==typeof e)return d(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?d(e,t):void 0}}function d(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}var v=function e(t){u(this,e),this.p=new Promise(t)};v.__typeson__type__="TypesonPromise","undefined"!=typeof Symbol&&(v.prototype[Symbol.toStringTag]="TypesonPromise"),v.prototype.then=function(e,t){var n=this;return new v(function(r,i){n.p.then(function(t){r(e?e(t):t)}).catch(function(e){return t?t(e):Promise.reject(e)}).then(r,i)})},v.prototype.catch=function(e){return this.then(null,e)},v.resolve=function(e){return new v(function(t){t(e)})},v.reject=function(e){return new v(function(t,n){n(e)})},["all","race"].forEach(function(e){v[e]=function(t){return new v(function(n,r){Promise[e](t.map(function(e){return e&&e.constructor&&"TypesonPromise"===e.constructor.__typeson__type__?e.p:e})).then(n,r)})}});var b={}.toString,$={}.hasOwnProperty,g=Object.getPrototypeOf,m=$.toString;function w(e,t){return T(e)&&"function"==typeof e.then&&(!t||"function"==typeof e.catch)}function _(e){return b.call(e).slice(8,-1)}function O(e,t){if(!e||"object"!==a(e))return!1;var n=g(e);if(!n)return null===t;var r=$.call(n,"constructor")&&n.constructor;return"function"!=typeof r?null===t:t===r||null!==t&&m.call(r)===m.call(t)||"function"==typeof t&&"string"==typeof r.__typeson__type__&&r.__typeson__type__===t.__typeson__type__}function E(e){return!(!e||"Object"!==_(e))&&(!g(e)||O(e,Object))}function T(e){return e&&"object"===a(e)}function A(e){return e.replace(/~/g,"~0").replace(/\./g,"~1")}function N(e){return e.replace(/~1/g,".").replace(/~0/g,"~")}function S(e,t){if(""===t)return e;var n=t.indexOf(".");if(n>-1){var r=e[N(t.slice(0,n))];return void 0===r?void 0:S(r,t.slice(n+1))}return e[N(t)]}function x(e,t,n){if(""===t)return n;var r=t.indexOf(".");return r>-1?x(e[N(t.slice(0,r))],t.slice(r+1),n):(e[N(t)]=n,e)}function k(e,t,n){return n?t?t(e):e:(e&&e.then||(e=Promise.resolve(e)),t?e.then(t):e)}var I=Object.keys,P=Array.isArray,C={}.hasOwnProperty,j=["type","replaced","iterateIn","iterateUnsetNumeric"];function B(e){return function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];try{return Promise.resolve(e.apply(this,t))}catch(r){return Promise.reject(r)}}}function L(e,t){if(""===e.keypath)return -1;var n=e.keypath.match(/\./g)||0,r=t.keypath.match(/\./g)||0;return n&&(n=n.length),r&&(r=r.length),n>r?-1:n<r?1:e.keypath<t.keypath?-1:e.keypath>t.keypath}var U=function(){var e,t,n;function r(e){u(this,r),this.options=e,this.plainObjectReplacers=[],this.nonplainObjectReplacers=[],this.revivers={},this.types={}}return e=r,t=[{key:"stringify",value:function e(t,n,r,i){i=p(p(p({},this.options),i),{},{stringification:!0});var o=this.encapsulate(t,null,i);return P(o)?JSON.stringify(o[0],n,r):o.then(function(e){return JSON.stringify(e,n,r)})}},{key:"stringifySync",value:function e(t,n,r,i){return this.stringify(t,n,r,p(p({throwOnBadSyncType:!0},i),{},{sync:!0}))}},{key:"stringifyAsync",value:function e(t,n,r,i){return this.stringify(t,n,r,p(p({throwOnBadSyncType:!0},i),{},{sync:!1}))}},{key:"parse",value:function e(t,n,r){return r=p(p(p({},this.options),r),{},{parse:!0}),this.revive(JSON.parse(t,n),r)}},{key:"parseSync",value:function e(t,n,r){return this.parse(t,n,p(p({throwOnBadSyncType:!0},r),{},{sync:!0}))}},{key:"parseAsync",value:function e(t,n,r){return this.parse(t,n,p(p({throwOnBadSyncType:!0},r),{},{sync:!1}))}},{key:"specialTypeNames",value:function e(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.returnTypeNames=!0,this.encapsulate(t,n,r)}},{key:"rootTypeName",value:function e(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.iterateNone=!0,this.encapsulate(t,n,r)}},{key:"encapsulate",value:function e(t,n,i){var o=B(function(e,t){return k(Promise.all(t.map(function(e){return e[1].p})),function(n){return k(Promise.all(n.map(B(function(n){var r,i,a,u=!1,s=[],c=y(t.splice(0,1),1),f=y(c[0],7),l=f[0],p=f[2],h=f[3],d=f[4],b=f[5],$=N(l,n,p,h,s,!0,f[6]),g=O($,v);return r=function(){if(l&&g)return k($.p,function(t){return d[b]=t,u=!0,o(e,s)})},i=function(t){return u?t:(l?d[b]=$:e=g?$.p:$,o(e,s))},(a=r())&&a.then?a.then(i):i(a)}))),function(){return e})})}),u=(i=p(p({sync:!0},this.options),i)).sync,s=this,c={},f=[],l=[],b=[],$=!("cyclic"in i)||i.cyclic,g=i.encapsulateObserver,m=N("",t,$,n||{},b);function w(e){var t,n=Object.values(c);if(i.iterateNone)return n.length?n[0]:r.getJSONType(e);if(n.length){if(i.returnTypeNames)return function e(t){if(Array.isArray(t))return d(t)}(t=new Set(n))||function e(t){if("undefined"!=typeof Symbol&&(Symbol.iterator in Object(t)))return Array.from(t)}(t)||h(t)||function e(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}();e&&E(e)&&!C.call(e,"$types")?e.$types=c:e={$:e,$types:{$:c}}}else T(e)&&C.call(e,"$types")&&(e={$:e,$types:!0});return!i.returnTypeNames&&e}function _(e,t,n){Object.assign(e,t);var r=j.map(function(t){var n=e[t];return delete e[t],n});n(),j.forEach(function(t,n){e[t]=r[n]})}function N(e,t,n,o,u,p,y){var h,d={},b=a(t),$=g?function(i){var a=y||o.type||r.getJSONType(t);g(Object.assign(i||d,{keypath:e,value:t,cyclic:n,stateObj:o,promisesData:u,resolvingTypesonPromise:p,awaitingTypesonPromise:O(t,v)},{type:a}))}:null;if(["string","boolean","number","undefined"].includes(b))return void 0===t||Number.isNaN(t)||t===Number.NEGATIVE_INFINITY||t===Number.POSITIVE_INFINITY?(h=o.replaced?t:S(e,t,o,u,!1,p,$))!==t&&(d={replaced:h}):h=t,$&&$(),h;if(null===t)return $&&$(),t;if(n&&!o.iterateIn&&!o.iterateUnsetNumeric&&t&&"object"===a(t)){var m=f.indexOf(t);if(!(m<0))return c[e]="#",$&&$({cyclicKeypath:l[m]}),"#"+l[m];!0===n&&(f.push(t),l.push(e))}var w,T=E(t),x=P(t),k=(T||x)&&(!s.plainObjectReplacers.length||o.replaced)||o.iterateIn?t:S(e,t,o,u,T||x,null,$);if(k!==t?(h=k,d={replaced:k}):""===e&&O(t,v)?(u.push([e,t,n,o,void 0,void 0,o.type]),h=t):x&&"object"!==o.iterateIn||"array"===o.iterateIn?d={clone:w=Array(t.length)}:(["function","symbol"].includes(a(t))||("toJSON"in t)||O(t,v)||O(t,Promise)||O(t,ArrayBuffer))&&!T&&"object"!==o.iterateIn?h=t:(w={},o.addLength&&(w.length=t.length),d={clone:w}),$&&$(),i.iterateNone)return w||h;if(!w)return h;if(o.iterateIn){var j=function r(i){var a={ownKeys:C.call(t,i)};_(o,a,function(){var r=e+(e?".":"")+A(i),a=N(r,t[i],Boolean(n),o,u,p);O(a,v)?u.push([r,a,Boolean(n),o,w,i,o.type]):void 0!==a&&(w[i]=a)})};for(var B in t)j(B);$&&$({endIterateIn:!0,end:!0})}else I(t).forEach(function(r){var i=e+(e?".":"")+A(r);_(o,{ownKeys:!0},function(){var e=N(i,t[r],Boolean(n),o,u,p);O(e,v)?u.push([i,e,Boolean(n),o,w,r,o.type]):void 0!==e&&(w[r]=e)})}),$&&$({endIterateOwn:!0,end:!0});if(o.iterateUnsetNumeric){for(var L=t.length,U=function r(i){if(!(i in t)){var a=e+(e?".":"")+i;_(o,{ownKeys:!1},function(){var e=N(a,void 0,Boolean(n),o,u,p);O(e,v)?u.push([a,e,Boolean(n),o,w,i,o.type]):void 0!==e&&(w[i]=e)})}},R=0;R<L;R++)U(R);$&&$({endIterateUnsetNumeric:!0,end:!0})}return w}function S(e,t,n,r,i,o,a){for(var f=i?s.plainObjectReplacers:s.nonplainObjectReplacers,l=f.length;l--;){var p=f[l];if(p.test(t,n)){var y=p.type;if(s.revivers[y]){var h=c[e];c[e]=h?[y].concat(h):y}return Object.assign(n,{type:y,replaced:!0}),!u&&p.replaceAsync||p.replace?(a&&a({replacing:!0}),N(e,p[u||!p.replaceAsync?"replace":"replaceAsync"](t,n),$&&"readonly",n,r,o,y)):(a&&a({typeDetected:!0}),N(e,t,$&&"readonly",n,r,o,y))}}return t}return b.length?u&&i.throwOnBadSyncType?function(){throw TypeError("Sync method requested but async result obtained")}():Promise.resolve(o(m,b)).then(w):!u&&i.throwOnBadSyncType?function(){throw TypeError("Async method requested but sync result obtained")}():i.stringification&&u?[w(m)]:u?w(m):Promise.resolve(w(m))}},{key:"encapsulateSync",value:function e(t,n,r){return this.encapsulate(t,n,p(p({throwOnBadSyncType:!0},r),{},{sync:!0}))}},{key:"encapsulateAsync",value:function e(t,n,r){return this.encapsulate(t,n,p(p({throwOnBadSyncType:!0},r),{},{sync:!1}))}},{key:"revive",value:function e(t,n){var r=t&&t.$types;if(!r)return t;if(!0===r)return t.$;var i=(n=p(p({sync:!0},this.options),n)).sync,o=[],a={},u=!0;r.$&&E(r.$)&&(t=t.$,r=r.$,u=!1);var s=this;function c(e,t){var n=y(s.revivers[e]||[],1)[0];if(!n)throw Error("Unregistered type: "+e);return!i||("revive"in n)?n[i&&n.revive?"revive":!i&&n.reviveAsync?"reviveAsync":"revive"](t,a):t}var f=[];function l(e){return O(e,R)?void 0:e}var h,d=function e(){var n=[];if(Object.entries(r).forEach(function(e){var t=y(e,2),i=t[0],o=t[1];"#"!==o&&[].concat(o).forEach(function(e){y(s.revivers[e]||[null,{}],2)[1].plain&&(n.push({keypath:i,type:e}),delete r[i])})}),n.length)return n.sort(L).reduce(function e(n,r){var i=r.keypath,o=r.type;if(w(n))return n.then(function(t){return e(t,{keypath:i,type:o})});var a=S(t,i);if(O(a=c(o,a),v))return a.then(function(e){var n=x(t,i,e);n===e&&(t=n)});var u=x(t,i,a);u===a&&(t=u)},void 0)}();return O(d,v)?h=d.then(function(){return t}):(h=function e(t,n,i,a,s){if(!u||"$types"!==t){var l=r[t],p=P(n);if(p||E(n)){var h=p?Array(n.length):{};for(I(n).forEach(function(r){var o=e(t+(t?".":"")+A(r),n[r],i||h,h,r),a=function e(t){return O(t,R)?h[r]=void 0:void 0!==t&&(h[r]=t),t};O(o,v)?f.push(o.then(function(e){return a(e)})):a(o)}),n=h;o.length;){var d=y(o[0],4),b=d[0],$=d[1],g=d[2],m=d[3],w=S(b,$);if(void 0===w)break;g[m]=w,o.splice(0,1)}}if(!l)return n;if("#"===l){var _=S(i,n.slice(1));return void 0===_&&o.push([i,n.slice(1),void 0,void 0]),_}return[].concat(l).reduce(function e(t,n){return O(t,v)?t.then(function(t){return e(t,n)}):c(n,t)},n)}}("",t,null),f.length&&(h=v.resolve(h).then(function(e){return v.all([e].concat(f))}).then(function(e){return y(e,1)[0]}))),w(h)?i&&n.throwOnBadSyncType?function(){throw TypeError("Sync method requested but async result obtained")}():O(h,v)?h.p.then(l):h:!i&&n.throwOnBadSyncType?function(){throw TypeError("Async method requested but sync result obtained")}():i?l(h):Promise.resolve(l(h))}},{key:"reviveSync",value:function e(t,n){return this.revive(t,p(p({throwOnBadSyncType:!0},n),{},{sync:!0}))}},{key:"reviveAsync",value:function e(t,n){return this.revive(t,p(p({throwOnBadSyncType:!0},n),{},{sync:!1}))}},{key:"register",value:function e(t,n){return n=n||{},[].concat(t).forEach(function e(t){var i=this;if(P(t))return t.map(function(t){return e.call(i,t)});t&&I(t).forEach(function(e){if("#"===e)throw TypeError("# cannot be used as a type name as it is reserved for cyclic objects");if(r.JSON_TYPES.includes(e))throw TypeError("Plain JSON object types are reserved as type names");var i=t[e],o=i&&i.testPlainObjects?this.plainObjectReplacers:this.nonplainObjectReplacers,a=o.filter(function(t){return t.type===e});if(a.length&&(o.splice(o.indexOf(a[0]),1),delete this.revivers[e],delete this.types[e]),"function"==typeof i){var u=i;i={test:function e(t){return t&&t.constructor===u},replace:function e(t){return p({},t)},revive:function e(t){return Object.assign(Object.create(u.prototype),t)}}}else if(P(i)){var s=y(i,3);i={test:s[0],replace:s[1],revive:s[2]}}if(i&&i.test){var c={type:e,test:i.test.bind(i)};i.replace&&(c.replace=i.replace.bind(i)),i.replaceAsync&&(c.replaceAsync=i.replaceAsync.bind(i));var f="number"==typeof n.fallback?n.fallback:n.fallback?0:Number.POSITIVE_INFINITY;if(i.testPlainObjects?this.plainObjectReplacers.splice(f,0,c):this.nonplainObjectReplacers.splice(f,0,c),i.revive||i.reviveAsync){var l={};i.revive&&(l.revive=i.revive.bind(i)),i.reviveAsync&&(l.reviveAsync=i.reviveAsync.bind(i)),this.revivers[e]=[l,{plain:i.testPlainObjects}]}this.types[e]=i}},this)},this),this}}],c(e.prototype,t),n&&c(e,n),r}(),R=function e(){u(this,e)};R.__typeson__type__="TypesonUndefined",U.Undefined=R,U.Promise=v,U.isThenable=w,U.toStringTag=_,U.hasConstructorOf=O,U.isObject=T,U.isPlainObject=E,U.isUserObject=function e(t){if(!t||"Object"!==_(t))return!1;var n=g(t);return!n||O(t,Object)||e(n)},U.escapeKeyPathComponent=A,U.unescapeKeyPathComponent=N,U.getByKeyPath=S,U.getJSONType=function e(t){return null===t?"null":Array.isArray(t)?"array":a(t)},U.JSON_TYPES=["null","boolean","number","string","array","object"];for(var F=[{arrayNonindexKeys:{testPlainObjects:!0,test:function e(t,n){return!!Array.isArray(t)&&(Object.keys(t).some(function(e){return String(Number.parseInt(e))!==e})&&(n.iterateIn="object",n.addLength=!0),!0)},replace:function e(t,n){return n.iterateUnsetNumeric=!0,t},revive:function e(t){if(Array.isArray(t))return t;var n=[];return Object.keys(t).forEach(function(e){var r=t[e];n[e]=r}),n}}},{sparseUndefined:{test:function e(t,n){return void 0===t&&!1===n.ownKeys},replace:function e(t){return 0},revive:function e(t){}}}],D="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",K=new Uint8Array(256),V=0;V<D.length;V++)K[D.charCodeAt(V)]=V;var M=function e(t,n,r){null==r&&(r=t.byteLength);for(var i=new Uint8Array(t,n||0,r),o=i.length,a="",u=0;u<o;u+=3)a+=D[i[u]>>2],a+=D[(3&i[u])<<4|i[u+1]>>4],a+=D[(15&i[u+1])<<2|i[u+2]>>6],a+=D[63&i[u+2]];return o%3==2?a=a.slice(0,-1)+"=":o%3==1&&(a=a.slice(0,-2)+"=="),a},G=function e(t){var n,r,i,o,a=t.length,u=.75*t.length,s=0;"="===t[t.length-1]&&(u--,"="===t[t.length-2]&&u--);for(var c=new ArrayBuffer(u),f=new Uint8Array(c),l=0;l<a;l+=4)n=K[t.charCodeAt(l)],r=K[t.charCodeAt(l+1)],i=K[t.charCodeAt(l+2)],o=K[t.charCodeAt(l+3)],f[s++]=n<<2|r>>4,f[s++]=(15&r)<<4|i>>2,f[s++]=(3&i)<<6|63&o;return c},Y="undefined"==typeof self?s:self,J={};function q(e){for(var t=new Uint8Array(e.length),n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t.buffer}["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"].forEach(function(e){var t=e,n=Y[t];n&&(J[e.toLowerCase()]={test:function e(n){return U.toStringTag(n)===t},replace:function e(t,n){var r=t.buffer,i=t.byteOffset,o=t.length;n.buffers||(n.buffers=[]);var a=n.buffers.indexOf(r);return a>-1?{index:a,byteOffset:i,length:o}:(n.buffers.push(r),{encoded:M(r),byteOffset:i,length:o})},revive:function e(t,r){r.buffers||(r.buffers=[]);var i,o=t.byteOffset,a=t.length,u=t.encoded,s=t.index;return("index"in t)?i=r.buffers[s]:(i=G(u),r.buffers.push(i)),new n(i,o,a)}})});var z={file:{test:function e(t){return"File"===U.toStringTag(t)},replace:function e(t){var n=new XMLHttpRequest;if(n.overrideMimeType("text/plain; charset=x-user-defined"),n.open("GET",URL.createObjectURL(t),!1),n.send(),200!==n.status&&0!==n.status)throw Error("Bad File access: "+n.status);return{type:t.type,stringContents:n.responseText,name:t.name,lastModified:t.lastModified}},revive:function e(t){var n=t.name,r=t.type,i=t.stringContents,o=t.lastModified;return new File([q(i)],n,{type:r,lastModified:o})},replaceAsync:function e(t){return new U.Promise(function(e,n){var r=new FileReader;r.addEventListener("load",function(){e({type:t.type,stringContents:r.result,name:t.name,lastModified:t.lastModified})}),r.addEventListener("error",function(){n(r.error)}),r.readAsBinaryString(t)})}}};return[{userObject:{test:function e(t,n){return U.isUserObject(t)},replace:function e(t){return function e(t){for(var i=1;i<arguments.length;i++){var o=null!=arguments[i]?arguments[i]:{};i%2?r(Object(o),!0).forEach(function(e){n(t,e,o[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(o,e))})}return t}({},t)},revive:function e(t){return t}}},{undef:{test:function e(t,n){return void 0===t&&(n.ownKeys||!("ownKeys"in n))},replace:function e(t){return 0},revive:function e(t){return new U.Undefined}}},F,{StringObject:{test:function t(n){return"String"===U.toStringTag(n)&&"object"===e(n)},replace:function e(t){return String(t)},revive:function e(t){return new String(t)}},BooleanObject:{test:function t(n){return"Boolean"===U.toStringTag(n)&&"object"===e(n)},replace:function e(t){return Boolean(t)},revive:function e(t){return new Boolean(t)}},NumberObject:{test:function t(n){return"Number"===U.toStringTag(n)&&"object"===e(n)},replace:function e(t){return Number(t)},revive:function e(t){return new Number(t)}}},[{nan:{test:function e(t){return Number.isNaN(t)},replace:function e(t){return"NaN"},revive:function e(t){return Number.NaN}}},{infinity:{test:function e(t){return t===Number.POSITIVE_INFINITY},replace:function e(t){return"Infinity"},revive:function e(t){return Number.POSITIVE_INFINITY}}},{negativeInfinity:{test:function e(t){return t===Number.NEGATIVE_INFINITY},replace:function e(t){return"-Infinity"},revive:function e(t){return Number.NEGATIVE_INFINITY}}}],{date:{test:function e(t){return"Date"===U.toStringTag(t)},replace:function e(t){var n=t.getTime();return Number.isNaN(n)?"NaN":n},revive:function e(t){return new Date("NaN"===t?Number.NaN:t)}}},{regexp:{test:function e(t){return"RegExp"===U.toStringTag(t)},replace:function e(t){return{source:t.source,flags:(t.global?"g":"")+(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.sticky?"y":"")+(t.unicode?"u":"")}},revive:function e(t){var n;return RegExp(t.source,t.flags)}}},{imagedata:{test:function e(t){return"ImageData"===U.toStringTag(t)},replace:function e(t){return{array:i(t.data),width:t.width,height:t.height}},revive:function e(t){return new ImageData(new Uint8ClampedArray(t.array),t.width,t.height)}}},{imagebitmap:{test:function e(t){return"ImageBitmap"===U.toStringTag(t)||t&&t.dataset&&"ImageBitmap"===t.dataset.toStringTag},replace:function e(t){var n=document.createElement("canvas");return n.getContext("2d").drawImage(t,0,0),n.toDataURL()},revive:function e(t){var n=document.createElement("canvas"),r=n.getContext("2d"),i=document.createElement("img");return i.addEventListener("load",function(){r.drawImage(i,0,0)}),i.src=t,n},reviveAsync:function e(t){var n=document.createElement("canvas"),r=n.getContext("2d"),i=document.createElement("img");return i.addEventListener("load",function(){r.drawImage(i,0,0)}),i.src=t,createImageBitmap(n)}}},z,{file:z.file,filelist:{test:function e(t){return"FileList"===U.toStringTag(t)},replace:function e(t){for(var n=[],r=0;r<t.length;r++)n[r]=t.item(r);return n},revive:function e(n){return new(function(){var e,n,r;function i(){(function e(t,n){if(!(t instanceof n))throw TypeError("Cannot call a class as a function")})(this,i),this._files=arguments[0],this.length=this._files.length}return e=i,n=[{key:"item",value:function e(t){return this._files[t]}},{key:Symbol.toStringTag,get:function e(){return"FileList"}}],t(e.prototype,n),r&&t(e,r),i}())(n)}}},{blob:{test:function e(t){return"Blob"===U.toStringTag(t)},replace:function e(t){var n=new XMLHttpRequest;if(n.overrideMimeType("text/plain; charset=x-user-defined"),n.open("GET",URL.createObjectURL(t),!1),n.send(),200!==n.status&&0!==n.status)throw Error("Bad Blob access: "+n.status);return{type:t.type,stringContents:n.responseText}},revive:function e(t){var n=t.type,r=t.stringContents;return new Blob([q(r)],{type:n})},replaceAsync:function e(t){return new U.Promise(function(e,n){var r=new FileReader;r.addEventListener("load",function(){e({type:t.type,stringContents:r.result})}),r.addEventListener("error",function(){n(r.error)}),r.readAsBinaryString(t)})}}}].concat("function"==typeof Map?{map:{test:function e(t){return"Map"===U.toStringTag(t)},replace:function e(t){return i(t.entries())},revive:function e(t){return new Map(t)}}}:[],"function"==typeof Set?{set:{test:function e(t){return"Set"===U.toStringTag(t)},replace:function e(t){return i(t.values())},revive:function e(t){return new Set(t)}}}:[],"function"==typeof ArrayBuffer?{arraybuffer:{test:function e(t){return"ArrayBuffer"===U.toStringTag(t)},replace:function e(t,n){n.buffers||(n.buffers=[]);var r=n.buffers.indexOf(t);return r>-1?{index:r}:(n.buffers.push(t),M(t))},revive:function t(n,r){if(r.buffers||(r.buffers=[]),"object"===e(n))return r.buffers[n.index];var i=G(n);return r.buffers.push(i),i}}}:[],"function"==typeof Uint8Array?J:[],"function"==typeof DataView?{dataview:{test:function e(t){return"DataView"===U.toStringTag(t)},replace:function e(t,n){var r=t.buffer,i=t.byteOffset,o=t.byteLength;n.buffers||(n.buffers=[]);var a=n.buffers.indexOf(r);return a>-1?{index:a,byteOffset:i,byteLength:o}:(n.buffers.push(r),{encoded:M(r),byteOffset:i,byteLength:o})},revive:function e(t,n){n.buffers||(n.buffers=[]);var r,i=t.byteOffset,o=t.byteLength,a=t.encoded,u=t.index;return("index"in t)?r=n.buffers[u]:(r=G(a),n.buffers.push(r)),new DataView(r,i,o)}}}:[],"undefined"!=typeof Intl?{IntlCollator:{test:function e(t){return U.hasConstructorOf(t,Intl.Collator)},replace:function e(t){return t.resolvedOptions()},revive:function e(t){return new Intl.Collator(t.locale,t)}},IntlDateTimeFormat:{test:function e(t){return U.hasConstructorOf(t,Intl.DateTimeFormat)},replace:function e(t){return t.resolvedOptions()},revive:function e(t){return new Intl.DateTimeFormat(t.locale,t)}},IntlNumberFormat:{test:function e(t){return U.hasConstructorOf(t,Intl.NumberFormat)},replace:function e(t){return t.resolvedOptions()},revive:function e(t){return new Intl.NumberFormat(t.locale,t)}}}:[],"undefined"!=typeof crypto?{cryptokey:{test:function e(t){return"CryptoKey"===U.toStringTag(t)&&t.extractable},replaceAsync:function e(t){return new U.Promise(function(e,n){crypto.subtle.exportKey("jwk",t).catch(function(e){n(e)}).then(function(n){e({jwk:n,algorithm:t.algorithm,usages:t.usages})})})},revive:function e(t){var n=t.jwk,r=t.algorithm,i=t.usages;return crypto.subtle.importKey("jwk",n,r,!0,i)}}}:[],"undefined"!=typeof BigInt?[{bigint:{test:function e(t){return"bigint"==typeof t},replace:function e(t){return String(t)},revive:function e(t){return BigInt(t)}}},{bigintObject:{test:function t(n){return"object"===e(n)&&U.hasConstructorOf(n,BigInt)},replace:function e(t){return String(t)},revive:function e(t){return Object(BigInt(t))}}}]:[])},e.exports=r()}),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",y=new Uint8Array(256),h=0;h<p.length;h++)y[p.codePointAt(h)]=h;var d=function e(t,n,r){null==r&&(r=t.byteLength);for(var i=new Uint8Array(t,n||0,r),o=i.length,a="",u=0;u<o;u+=3)a+=p[i[u]>>2],a+=p[(3&i[u])<<4|i[u+1]>>4],a+=p[(15&i[u+1])<<2|i[u+2]>>6],a+=p[63&i[u+2]];return o%3==2?a=a.slice(0,-1)+"=":o%3==1&&(a=a.slice(0,-2)+"=="),a},v=function e(t){var n,r,i,o,a=t.length,u=.75*t.length,s=0;"="===t[t.length-1]&&(u--,"="===t[t.length-2]&&u--);for(var c=new ArrayBuffer(u),f=new Uint8Array(c),l=0;l<a;l+=4)n=y[t.codePointAt(l)],r=y[t.codePointAt(l+1)],i=y[t.codePointAt(l+2)],o=y[t.codePointAt(l+3)],f[s++]=n<<2|r>>4,f[s++]=(15&r)<<4|i>>2,f[s++]=(3&i)<<6|63&o;return c},b="undefined"==typeof self?global:self,$={};["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"].forEach(function(e){var t=e,n=b[t];n&&($[e.toLowerCase()+"2"]={test:function(e){return f.toStringTag(e)===t},replace:function(e){var t,n=e.buffer;return{buffer:n,byteOffset:e.byteOffset,length:e.length}},revive:function(e){var t=e.buffer,r=e.byteOffset,i=e.length;return new n(t,r,i)}})});var g=new f().register(l),m="FileReaderSync"in self,w=[],_=0;function O(e,t){return i(this,void 0,void 0,function(){var n,a,u,s,c,f;function l(){return i(this,void 0,void 0,function(){var i,l,p,y,h,d,v,b,$;return o(this,function(m){switch(m.label){case 0:return[4,Promise.all(e.tables.map(function(e){return e.count()}))];case 1:(i=m.sent()).forEach(function(e,t){return a[t].rowCount=e}),f.totalRows=i.reduce(function(e,t){return e+t}),p=(l=JSON.stringify(s,void 0,u?2:void 0)).lastIndexOf("]"),y=l.substring(0,p),n.push(y),h=t.filter,d=function(i){var a,s,l,p,y,d,v,b,$,m,w,_;return o(this,function(O){switch(O.label){case 0:l=!!(s=(a=e.table(i)).schema.primKey).keyPath,p=t.numRowsPerChunk||2e3,d=JSON.stringify(y=l?{tableName:a.name,inbound:!0,rows:[]}:{tableName:a.name,inbound:!1,rows:[]},void 0,u?2:void 0),u&&(d=d.split("\n").join("\n    ")),v=d.lastIndexOf("]"),n.push(d.substring(0,v)),b=null,$=0,m=!0,w=function(){var e,t,y,d,v,w,_,O;return o(this,function(o){switch(o.label){case 0:return c&&r.default.ignoreTransaction(function(){return c(f)}),[4,(e=null==b?a.limit(p):a.where(":id").above(b).limit(p)).toArray()];case 1:if(0===(t=o.sent()).length)return[2,"break"];if(null!=b&&$>0&&(n.push(","),u&&n.push("\n      ")),m=t.length===p,!l)return[3,4];if(d=(y=h?t.filter(function(e){return h(i,e)}):t).map(function(e){return g.encapsulate(e)}),!g.mustFinalize())return[3,3];return[4,r.default.waitFor(g.finalize(d))];case 2:o.sent(),o.label=3;case 3:return v=JSON.stringify(d,void 0,u?2:void 0),u&&(v=v.split("\n").join("\n      ")),n.push(new Blob([v.substring(1,v.length-1)])),$=y.length,b=t.length>0?r.default.getByKeyPath(t[t.length-1],s.keyPath):null,[3,8];case 4:return[4,e.primaryKeys()];case 5:if(_=(w=o.sent()).map(function(e,n){return[e,t[n]]}),h&&(_=_.filter(function(e){var t=e[0];return h(i,e[1],t)})),O=_.map(function(e){return g.encapsulate(e)}),!g.mustFinalize())return[3,7];return[4,r.default.waitFor(g.finalize(O))];case 6:o.sent(),o.label=7;case 7:v=JSON.stringify(O,void 0,u?2:void 0),u&&(v=v.split("\n").join("\n      ")),n.push(new Blob([v.substring(1,v.length-1)])),$=_.length,b=w.length>0?w[w.length-1]:null,o.label=8;case 8:return f.completedRows+=t.length,[2]}})},O.label=1;case 1:if(!m)return[3,3];return[5,w()];case 2:if("break"===(_=O.sent()))return[3,3];return[3,1];case 3:return n.push(d.substr(v)),f.completedTables+=1,f.completedTables<f.totalTables&&n.push(","),[2]}})},v=0,b=a,m.label=2;case 2:if(!(v<b.length))return[3,5];return[5,d($=b[v].name)];case 3:m.sent(),m.label=4;case 4:return v++,[3,2];case 5:return n.push(l.substr(p)),f.done=!0,c&&r.default.ignoreTransaction(function(){return c(f)}),[2]}})})}return o(this,function(i){switch(i.label){case 0:t=t||{},n=[],a=e.tables.map(function(e){var t;return{name:e.name,schema:[(t=e).schema.primKey].concat(t.schema.indexes).map(function(e){return e.src}).join(","),rowCount:0}}),u=t.prettyJson,s={formatName:"dexie",formatVersion:1,data:{databaseName:e.name,databaseVersion:e.verno,tables:a,data:[]}},c=t.progressCallback,f={done:!1,completedRows:0,completedTables:0,totalRows:NaN,totalTables:e.tables.length},i.label=1;case 1:if(i.trys.push([1,,6,7]),!t.noTransaction)return[3,3];return[4,l()];case 2:return i.sent(),[3,5];case 3:return[4,e.transaction("r",e.tables,l)];case 4:i.sent(),i.label=5;case 5:return[3,7];case 6:return g.finalize(),[7];case 7:return c&&r.default.ignoreTransaction(function(){return c(f)}),[2,new Blob(n,{type:"text/json"})]}})})}g.register([{arraybuffer:{test:function(e){return"ArrayBuffer"===f.toStringTag(e)},replace:function(e){return d(e,0,e.byteLength)},revive:function(e){return v(e)}}},$,{blob2:{test:function(e){return"Blob"===f.toStringTag(e)},replace:function(e){if(e.isClosed)throw Error("The Blob is closed");if(m){var t=u(e,"binary"),n=d(t,0,t.byteLength);return{type:e.type,data:n}}w.push(e);var r={type:e.type,data:{start:_,end:_+e.size}};return _+=e.size,r},finalize:function(e,t){e.data=d(t,0,t.byteLength)},revive:function(e){var t=e.type,n=e.data;return new Blob([v(n)],{type:t})}}}]),g.mustFinalize=function(){return w.length>0},g.finalize=function(e){return i(void 0,void 0,void 0,function(){var t,n,i,u,s,c,f,l,p,y;return o(this,function(o){switch(o.label){case 0:return[4,a(new Blob(w),"binary")];case 1:if(t=o.sent(),e){for(n=0,i=e;n<i.length;n++)if((u=i[n]).$types)for(f in(c=(s=u.$types).$)&&(s=s.$),s)l=s[f],(p=g.types[l])&&p.finalize&&(y=r.default.getByKeyPath(u,c?"$."+f:f),p.finalize(y,t.slice(y.start,y.end)))}return w=[],[2]}})})};var E={Stream:function(){}},T=c(function(e,t){!function(e){var t="object"==typeof process&&process.env?process.env:self;e.parser=function(e){return new f(e)},e.CParser=f,e.CStream=p,e.createStream=function e(t){return new p(t)},e.MAX_BUFFER_LENGTH=10485760,e.DEBUG="debug"===t.CDEBUG,e.INFO="debug"===t.CDEBUG||"info"===t.CDEBUG,e.EVENTS=["value","string","key","openobject","closeobject","openarray","closearray","error","end","ready"];var n,r={textNode:void 0,numberNode:""},i=e.EVENTS.filter(function(e){return"error"!==e&&"end"!==e}),o=0;for(var a in e.STATE={BEGIN:o++,VALUE:o++,OPEN_OBJECT:o++,CLOSE_OBJECT:o++,OPEN_ARRAY:o++,CLOSE_ARRAY:o++,TEXT_ESCAPE:o++,STRING:o++,BACKSLASH:o++,END:o++,OPEN_KEY:o++,CLOSE_KEY:o++,TRUE:o++,TRUE2:o++,TRUE3:o++,FALSE:o++,FALSE2:o++,FALSE3:o++,FALSE4:o++,NULL:o++,NULL2:o++,NULL3:o++,NUMBER_DECIMAL_POINT:o++,NUMBER_DIGIT:o++},e.STATE)e.STATE[e.STATE[a]]=a;o=e.STATE;let u={tab:9,lineFeed:10,carriageReturn:13,space:32,doubleQuote:34,plus:43,comma:44,minus:45,period:46,_0:48,_9:57,colon:58,E:69,openBracket:91,backslash:92,closeBracket:93,a:97,b:98,e:101,f:102,l:108,n:110,r:114,s:115,t:116,u:117,openBrace:123,closeBrace:125};function s(e){for(var t in r)e[t]=r[t]}Object.create||(Object.create=function(e){function t(){this.__proto__=e}return t.prototype=e,new t}),Object.getPrototypeOf||(Object.getPrototypeOf=function(e){return e.__proto__}),Object.keys||(Object.keys=function(e){var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(n);return t});var c=/[\\"\n]/g;function f(t){if(!(this instanceof f))return new f(t);var n=this;s(n),n.bufferCheckPosition=e.MAX_BUFFER_LENGTH,n.q=n.c=n.p="",n.opt=t||{},n.closed=n.closedRoot=n.sawRoot=!1,n.tag=n.error=null,n.state=o.BEGIN,n.stack=[],n.position=n.column=0,n.line=1,n.slashed=!1,n.unicodeI=0,n.unicodeS=null,n.depth=0,y(n,"onready")}f.prototype={end:function(){$(this)},write:function t(n){var i=this;if(this.error)throw this.error;if(i.closed)return b(i,"Cannot write after close. Assign an onready handler.");if(null===n)return $(i);var a=0,s=n.charCodeAt(0),f=i.p;for(e.DEBUG&&console.log("write -> ["+n+"]");s&&(f=s,i.c=s=n.charCodeAt(a++),f!==s?i.p=f:f=i.p,s);)switch(e.DEBUG&&console.log(a,s,e.STATE[i.state]),i.position++,s===u.lineFeed?(i.line++,i.column=0):i.column++,i.state){case o.BEGIN:s===u.openBrace?i.state=o.OPEN_OBJECT:s===u.openBracket?i.state=o.OPEN_ARRAY:g(s)||b(i,"Non-whitespace before {[.");continue;case o.OPEN_KEY:case o.OPEN_OBJECT:if(g(s))continue;if(i.state===o.OPEN_KEY)i.stack.push(o.CLOSE_KEY);else{if(s===u.closeBrace){y(i,"onopenobject"),this.depth++,y(i,"oncloseobject"),this.depth--,i.state=i.stack.pop()||o.VALUE;continue}i.stack.push(o.CLOSE_OBJECT)}s===u.doubleQuote?i.state=o.STRING:b(i,'Malformed object key should start with "');continue;case o.CLOSE_KEY:case o.CLOSE_OBJECT:if(g(s))continue;i.state,o.CLOSE_KEY,s===u.colon?(i.state===o.CLOSE_OBJECT?(i.stack.push(o.CLOSE_OBJECT),d(i,"onopenobject"),this.depth++):d(i,"onkey"),i.state=o.VALUE):s===u.closeBrace?(h(i,"oncloseobject"),this.depth--,i.state=i.stack.pop()||o.VALUE):s===u.comma?(i.state===o.CLOSE_OBJECT&&i.stack.push(o.CLOSE_OBJECT),d(i),i.state=o.OPEN_KEY):b(i,"Bad object");continue;case o.OPEN_ARRAY:case o.VALUE:if(g(s))continue;if(i.state===o.OPEN_ARRAY){if(y(i,"onopenarray"),this.depth++,i.state=o.VALUE,s===u.closeBracket){y(i,"onclosearray"),this.depth--,i.state=i.stack.pop()||o.VALUE;continue}i.stack.push(o.CLOSE_ARRAY)}s===u.doubleQuote?i.state=o.STRING:s===u.openBrace?i.state=o.OPEN_OBJECT:s===u.openBracket?i.state=o.OPEN_ARRAY:s===u.t?i.state=o.TRUE:s===u.f?i.state=o.FALSE:s===u.n?i.state=o.NULL:s===u.minus?i.numberNode+="-":u._0<=s&&s<=u._9?(i.numberNode+=String.fromCharCode(s),i.state=o.NUMBER_DIGIT):b(i,"Bad value");continue;case o.CLOSE_ARRAY:if(s===u.comma)i.stack.push(o.CLOSE_ARRAY),d(i,"onvalue"),i.state=o.VALUE;else if(s===u.closeBracket)h(i,"onclosearray"),this.depth--,i.state=i.stack.pop()||o.VALUE;else{if(g(s))continue;b(i,"Bad array")}continue;case o.STRING:void 0===i.textNode&&(i.textNode="");var l=a-1,p=i.slashed,m=i.unicodeI;STRING_BIGLOOP:for(;;){for(e.DEBUG&&console.log(a,s,e.STATE[i.state],p);m>0;)if(i.unicodeS+=String.fromCharCode(s),s=n.charCodeAt(a++),i.position++,4===m?(i.textNode+=String.fromCharCode(parseInt(i.unicodeS,16)),m=0,l=a-1):m++,!s)break STRING_BIGLOOP;if(s===u.doubleQuote&&!p){i.state=i.stack.pop()||o.VALUE,i.textNode+=n.substring(l,a-1),i.position+=a-1-l;break}if(s===u.backslash&&!p&&(p=!0,i.textNode+=n.substring(l,a-1),i.position+=a-1-l,s=n.charCodeAt(a++),i.position++,!s))break;if(p){if(p=!1,s===u.n?i.textNode+="\n":s===u.r?i.textNode+="\r":s===u.t?i.textNode+="	":s===u.f?i.textNode+="\f":s===u.b?i.textNode+="\b":s===u.u?(m=1,i.unicodeS=""):i.textNode+=String.fromCharCode(s),s=n.charCodeAt(a++),i.position++,l=a-1,s)continue;break}c.lastIndex=a;var w=c.exec(n);if(null===w){a=n.length+1,i.textNode+=n.substring(l,a-1),i.position+=a-1-l;break}if(a=w.index+1,!(s=n.charCodeAt(w.index))){i.textNode+=n.substring(l,a-1),i.position+=a-1-l;break}}i.slashed=p,i.unicodeI=m;continue;case o.TRUE:s===u.r?i.state=o.TRUE2:b(i,"Invalid true started with t"+s);continue;case o.TRUE2:s===u.u?i.state=o.TRUE3:b(i,"Invalid true started with tr"+s);continue;case o.TRUE3:s===u.e?(y(i,"onvalue",!0),i.state=i.stack.pop()||o.VALUE):b(i,"Invalid true started with tru"+s);continue;case o.FALSE:s===u.a?i.state=o.FALSE2:b(i,"Invalid false started with f"+s);continue;case o.FALSE2:s===u.l?i.state=o.FALSE3:b(i,"Invalid false started with fa"+s);continue;case o.FALSE3:s===u.s?i.state=o.FALSE4:b(i,"Invalid false started with fal"+s);continue;case o.FALSE4:s===u.e?(y(i,"onvalue",!1),i.state=i.stack.pop()||o.VALUE):b(i,"Invalid false started with fals"+s);continue;case o.NULL:s===u.u?i.state=o.NULL2:b(i,"Invalid null started with n"+s);continue;case o.NULL2:s===u.l?i.state=o.NULL3:b(i,"Invalid null started with nu"+s);continue;case o.NULL3:s===u.l?(y(i,"onvalue",null),i.state=i.stack.pop()||o.VALUE):b(i,"Invalid null started with nul"+s);continue;case o.NUMBER_DECIMAL_POINT:s===u.period?(i.numberNode+=".",i.state=o.NUMBER_DIGIT):b(i,"Leading zero not followed by .");continue;case o.NUMBER_DIGIT:u._0<=s&&s<=u._9?i.numberNode+=String.fromCharCode(s):s===u.period?(-1!==i.numberNode.indexOf(".")&&b(i,"Invalid number has two dots"),i.numberNode+="."):s===u.e||s===u.E?((-1!==i.numberNode.indexOf("e")||-1!==i.numberNode.indexOf("E"))&&b(i,"Invalid number has two exponential"),i.numberNode+="e"):s===u.plus||s===u.minus?(f===u.e||f===u.E||b(i,"Invalid symbol in number"),i.numberNode+=String.fromCharCode(s)):(v(i),a--,i.state=i.stack.pop()||o.VALUE);continue;default:b(i,"Unknown state: "+i.state)}return i.position>=i.bufferCheckPosition&&function t(n){var i=Math.max(e.MAX_BUFFER_LENGTH,10),o=0;for(var a in r){var u=void 0===n[a]?0:n[a].length;u>i&&("text"===a?closeText(n):b(n,"Max buffer length exceeded: "+a)),o=Math.max(o,u)}n.bufferCheckPosition=e.MAX_BUFFER_LENGTH-o+n.position}(i),i},resume:function(){return this.error=null,this},close:function(){return this.write(null)}};try{n=E.Stream}catch(l){n=function(){}}function p(e){if(!(this instanceof p))return new p(e);this._parser=new f(e),this.writable=!0,this.readable=!0,this.bytes_remaining=0,this.bytes_in_sequence=0,this.temp_buffs={2:new Buffer(2),3:new Buffer(3),4:new Buffer(4)},this.string="";var t=this;n.apply(t),this._parser.onend=function(){t.emit("end")},this._parser.onerror=function(e){t.emit("error",e),t._parser.error=null},i.forEach(function(e){Object.defineProperty(t,"on"+e,{get:function(){return t._parser["on"+e]},set:function(n){if(!n)return t.removeAllListeners(e),t._parser["on"+e]=n,n;t.on(e,n)},enumerable:!0,configurable:!1})})}function y(t,n,r){e.INFO&&console.log("-- emit",n,r),t[n]&&t[n](r)}function h(e,t,n){d(e),y(e,t,n)}function d(e,t){var n,r;e.textNode=(n=e.opt,r=e.textNode,void 0===r||(n.trim&&(r=r.trim()),n.normalize&&(r=r.replace(/\s+/g," "))),r),void 0!==e.textNode&&y(e,t||"onvalue",e.textNode),e.textNode=void 0}function v(e){e.numberNode&&y(e,"onvalue",parseFloat(e.numberNode)),e.numberNode=""}function b(e,t){return d(e),t+="\nLine: "+e.line+"\nColumn: "+e.column+"\nChar: "+e.c,t=Error(t),e.error=t,y(e,"onerror",t),e}function $(e){return(e.state!==o.VALUE||0!==e.depth)&&b(e,"Unexpected end"),d(e),e.c="",e.closed=!0,y(e,"onend"),f.call(e,e.opt),e}function g(e){return e===u.carriageReturn||e===u.lineFeed||e===u.space||e===u.tab}p.prototype=Object.create(n.prototype,{constructor:{value:p}}),p.prototype.write=function(e){e=new Buffer(e);for(var t=0;t<e.length;t++){var n=e[t];if(this.bytes_remaining>0){for(var r=0;r<this.bytes_remaining;r++)this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence-this.bytes_remaining+r]=e[r];this.string=this.temp_buffs[this.bytes_in_sequence].toString(),this.bytes_in_sequence=this.bytes_remaining=0,t=t+r-1,this._parser.write(this.string),this.emit("data",this.string);continue}if(0===this.bytes_remaining&&n>=128){if(n>=194&&n<=223&&(this.bytes_in_sequence=2),n>=224&&n<=239&&(this.bytes_in_sequence=3),n>=240&&n<=244&&(this.bytes_in_sequence=4),this.bytes_in_sequence+t>e.length){for(var i=0;i<=e.length-1-t;i++)this.temp_buffs[this.bytes_in_sequence][i]=e[t+i];return this.bytes_remaining=t+this.bytes_in_sequence-e.length,!0}this.string=e.slice(t,t+this.bytes_in_sequence).toString(),t=t+this.bytes_in_sequence-1,this._parser.write(this.string),this.emit("data",this.string);continue}for(var o=t;o<e.length&&!(e[o]>=128);o++);this.string=e.slice(t,o).toString(),this._parser.write(this.string),this.emit("data",this.string),t=o-1}},p.prototype.end=function(e){return e&&e.length&&this._parser.write(e.toString()),this._parser.end(),!0},p.prototype.on=function(e,t){var r=this;return r._parser["on"+e]||-1===i.indexOf(e)||(r._parser["on"+e]=function(){var t=1===arguments.length?[arguments[0]]:Array.apply(null,arguments);t.splice(0,0,e),r.emit.apply(r,t)}),n.prototype.on.call(r,e,t)},p.prototype.destroy=function(){s(this._parser),this.emit("close")}}(t)});function A(e){var t,n,r,s,c,f,l,p,y,h=0,d=(t=!0,c=T.parser(),f=0,l=[],p=!1,y=!1,c.onopenobject=function(e){var i={};i.incomplete=!0,n||(n=i),r&&(l.push([s,r,y]),t&&(y?r.push(i):r[s]=i)),r=i,s=e,y=!1,++f},c.onkey=function(e){return s=e},c.onvalue=function(e){return y?r.push(e):r[s]=e},c.oncloseobject=function(){var e;if(delete r.incomplete,s=null,0==--f)p=!0;else{var n=r;s=(e=l.pop())[0],r=e[1],y=e[2],t||(y?r.push(n):r[s]=n)}},c.onopenarray=function(){var e=[];e.incomplete=!0,n||(n=e),r&&(l.push([s,r,y]),t&&(y?r.push(e):r[s]=e)),r=e,y=!0,s=null,++f},c.onclosearray=function(){var e;if(delete r.incomplete,s=null,0==--f)p=!0;else{var n=r;s=(e=l.pop())[0],r=e[1],y=e[2],t||(y?r.push(n):r[s]=n)}},{write:function(e){return c.write(e),n},done:function(){return p}}),v={pullAsync:function(t){return i(this,void 0,void 0,function(){var n,r,i;return o(this,function(o){switch(o.label){case 0:return n=e.slice(h,h+t),h+=t,[4,a(n,"text")];case 1:return r=o.sent(),i=d.write(r),v.result=i||{},[2,i]}})})},pullSync:function(t){var n=e.slice(h,h+t);h+=t;var r=u(n,"text"),i=d.write(r);return v.result=i||{},i},done:function(){return d.done()},eof:function(){return h>=e.size},result:{}};return v}function N(e,t){return i(this,void 0,void 0,function(){var n,i,a,u;return o(this,function(o){switch(o.label){case 0:return[4,x(e,n=(t=t||{}).chunkSizeBytes||1048576)];case 1:return a=(i=o.sent()).result.data,(u=new r.default(a.databaseName)).version(a.databaseVersion).stores(function e(t){for(var n={},r=0,i=t.tables;r<i.length;r++){var o=i[r];n[o.name]=o.schema}return n}(a)),[4,S(u,i,t)];case 2:return o.sent(),[2,u]}})})}function S(e,t,n){return i(this,void 0,void 0,function(){var a,u,s,c,f,l,p,y,h,d;function v(){return i(this,void 0,void 0,function(){var t,i,s,y,h;return o(this,function(d){switch(d.label){case 0:t=function(t){var i,a,u,s,c,y,h,d,v,b,$,m;return o(this,function(o){switch(o.label){case 0:if(!t.rows)return[2,"break"];if(!t.rows.incomplete&&0===t.rows.length)return[2,"continue"];if(l&&r.default.ignoreTransaction(function(){return l(p)}),i=t.tableName,a=e.table(i),u=f.tables.filter(function(e){return e.name===i})[0].schema,!a){if(n.acceptMissingTables)return[2,"continue"];throw Error("Exported table ".concat(t.tableName," is missing in installed database"))}if(!n.acceptChangedPrimaryKey&&u.split(",")[0]!=a.schema.primKey.src)throw Error("Primary key differs for table ".concat(t.tableName,". "));for(y=0,s=t.rows,c=[];y<s.length&&!(h=s[y]).incomplete;y++)c.push(g.revive(h));if(v=(d=n.filter)?t.inbound?c.filter(function(e){return d(i,e)}):c.filter(function(e){var t=e[0];return d(i,e[1],t)}):c,$=(b=t.inbound?[void 0,v]:[v.map(function(e){return e[0]}),c.map(function(e){return e[1]})])[0],m=b[1],!n.overwriteValues)return[3,2];return[4,a.bulkPut(m,$)];case 1:return o.sent(),[3,4];case 2:return[4,a.bulkAdd(m,$)];case 3:o.sent(),o.label=4;case 4:return p.completedRows+=c.length,c.incomplete||(p.completedTables+=1),s.splice(0,c.length),[2]}})},i=0,s=f.data,d.label=1;case 1:if(!(i<s.length))return[3,4];return[5,t(y=s[i])];case 2:if("break"===(h=d.sent()))return[3,4];d.label=3;case 3:return i++,[3,1];case 4:for(;f.data.length>0&&f.data[0].rows&&!f.data[0].rows.incomplete;)f.data.splice(0,1);if(!(!u.done()&&!u.eof()))return[3,8];if(!c)return[3,5];return u.pullSync(a),[3,7];case 5:return[4,r.default.waitFor(u.pullAsync(a))];case 6:d.sent(),d.label=7;case 7:return[3,9];case 8:return[3,10];case 9:return[3,0];case 10:return[2]}})})}return o(this,function(i){switch(i.label){case 0:return[4,x(t,a=(n=n||{}).chunkSizeBytes||1048576)];case 1:if(s=(u=i.sent()).result,c="FileReaderSync"in self,f=s.data,!n.acceptNameDiff&&e.name!==f.databaseName)throw Error("Name differs. Current database name is ".concat(e.name," but export is ").concat(f.databaseName));if(!n.acceptVersionDiff&&e.verno!==f.databaseVersion)throw Error("Database version differs. Current database is in version ".concat(e.verno," but export is ").concat(f.databaseVersion));if(l=n.progressCallback,p={done:!1,completedRows:0,completedTables:0,totalRows:f.tables.reduce(function(e,t){return e+t.rowCount},0),totalTables:f.tables.length},l&&r.default.ignoreTransaction(function(){return l(p)}),!n.clearTablesBeforeImport)return[3,5];y=0,h=e.tables,i.label=2;case 2:if(!(y<h.length))return[3,5];return[4,(d=h[y]).clear()];case 3:i.sent(),i.label=4;case 4:return y++,[3,2];case 5:if(!n.noTransaction)return[3,7];return[4,v()];case 6:return i.sent(),[3,9];case 7:return[4,e.transaction("rw",e.tables,v)];case 8:i.sent(),i.label=9;case 9:return p.done=!0,l&&r.default.ignoreTransaction(function(){return l(p)}),[2]}})})}function x(e,t){return i(this,void 0,void 0,function(){var n,r;return o(this,function(i){switch(i.label){case 0:n="slice"in e?A(e):e,i.label=1;case 1:if(n.eof())return[3,3];return[4,n.pullAsync(t)];case 2:if(i.sent(),n.result.data&&n.result.data.data)return[3,3];return[3,1];case 3:if(!(r=n.result)||"dexie"!=r.formatName)throw Error("Given file is not a dexie export");if(r.formatVersion>1)throw Error("Format version ".concat(r.formatVersion," not supported"));if(!r.data)throw Error("No data in export file");if(!r.data.databaseName)throw Error("Missing databaseName in export file");if(!r.data.databaseVersion)throw Error("Missing databaseVersion in export file");if(!r.data.tables)throw Error("Missing tables in export file");return[2,n]}})})}r.default.prototype.export=function(e){return O(this,e)},r.default.prototype.import=function(e,t){return S(this,e,t)},r.default.import=function(e,t){return N(e,t)};var k=function(){throw Error("This addon extends Dexie.prototype globally and does not have be included in Dexie constructor's addons options.")};e.default=k,e.exportDB=O,e.importDB=N,e.importInto=S,e.peakImportFile=function e(t){return i(this,void 0,void 0,function(){var e;return o(this,function(n){switch(n.label){case 0:e=A(t),n.label=1;case 1:if(e.eof())return[3,3];return[4,e.pullAsync(5120)];case 2:if(n.sent(),e.result.data&&e.result.data.data)return delete e.result.data.data,[3,3];return[3,1];case 3:return[2,e.result]}})})},Object.defineProperty(e,"__esModule",{value:!0})});</script>
    
    <!-- <script src="https://cdn.jsdelivr.net/npm/marked@4.2.12/marked.min.js"></script> -->
    <script>!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).marked={})}(this,function(r){"use strict";function i(e,t){for(var u=0;u<t.length;u++){var n=t[u];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,function(e){e=function(e,t){if("object"!=typeof e||null===e)return e;var u=e[Symbol.toPrimitive];if(void 0===u)return("string"===t?String:Number)(e);u=u.call(e,t||"default");if("object"!=typeof u)return u;throw new TypeError("@@toPrimitive must return a primitive value.")}(e,"string");return"symbol"==typeof e?e:String(e)}(n.key),n)}}function s(e,t){(null==t||t>e.length)&&(t=e.length);for(var u=0,n=new Array(t);u<t;u++)n[u]=e[u];return n}function D(e,t){var u,n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,t){var u;if(e)return"string"==typeof e?s(e,t):"Map"===(u="Object"===(u=Object.prototype.toString.call(e).slice(8,-1))&&e.constructor?e.constructor.name:u)||"Set"===u?Array.from(e):"Arguments"===u||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u)?s(e,t):void 0}(e))||t&&e&&"number"==typeof e.length)return n&&(e=n),u=0,function(){return u>=e.length?{done:!0}:{done:!1,value:e[u++]}};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function e(){return{async:!1,baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}r.defaults=e();function u(e){return t[e]}var n=/[&<>"']/,l=new RegExp(n.source,"g"),a=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,o=new RegExp(a.source,"g"),t={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};function c(e,t){if(t){if(n.test(e))return e.replace(l,u)}else if(a.test(e))return e.replace(o,u);return e}var h=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;function x(e){return e.replace(h,function(e,t){return"colon"===(t=t.toLowerCase())?":":"#"===t.charAt(0)?"x"===t.charAt(1)?String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring(1)):""})}var p=/(^|[^\[])\^/g;function f(u,e){u="string"==typeof u?u:u.source,e=e||"";var n={replace:function(e,t){return t=(t=t.source||t).replace(p,"$1"),u=u.replace(e,t),n},getRegex:function(){return new RegExp(u,e)}};return n}var g=/[^\w:]/g,Z=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function F(e,t,u){if(e){try{n=decodeURIComponent(x(u)).replace(g,"").toLowerCase()}catch(e){return null}if(0===n.indexOf("javascript:")||0===n.indexOf("vbscript:")||0===n.indexOf("data:"))return null}var n;t&&!Z.test(u)&&(e=u,A[" "+(n=t)]||(q.test(n)?A[" "+n]=n+"/":A[" "+n]=E(n,"/",!0)),t=-1===(n=A[" "+n]).indexOf(":"),u="//"===e.substring(0,2)?t?e:n.replace(O,"$1")+e:"/"===e.charAt(0)?t?e:n.replace(j,"$1")+e:n+e);try{u=encodeURI(u).replace(/%25/g,"%")}catch(e){return null}return u}var A={},q=/^[^:]+:\/*[^/]*$/,O=/^([^:]+:)[\s\S]*$/,j=/^([^:]+:\/*[^/]*)[\s\S]*$/;var d={exec:function(){}};function C(e){for(var t,u,n=1;n<arguments.length;n++)for(u in t=arguments[n])Object.prototype.hasOwnProperty.call(t,u)&&(e[u]=t[u]);return e}function k(e,t){var u=e.replace(/\|/g,function(e,t,u){for(var n=!1,r=t;0<=--r&&"\\"===u[r];)n=!n;return n?"|":" |"}).split(/ \|/),n=0;if(u[0].trim()||u.shift(),0<u.length&&!u[u.length-1].trim()&&u.pop(),u.length>t)u.splice(t);else for(;u.length<t;)u.push("");for(;n<u.length;n++)u[n]=u[n].trim().replace(/\\\|/g,"|");return u}function E(e,t,u){var n=e.length;if(0===n)return"";for(var r=0;r<n;){var i=e.charAt(n-r-1);if((i!==t||u)&&(i===t||!u))break;r++}return e.slice(0,n-r)}function m(e){e&&e.sanitize&&!e.silent&&console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options")}function b(e,t){if(t<1)return"";for(var u="";1<t;)1&t&&(u+=e),t>>=1,e+=e;return u+e}function B(e,t,u,n){var r=t.href,t=t.title?c(t.title):null,i=e[1].replace(/\\([\[\]])/g,"$1");return"!"!==e[0].charAt(0)?(n.state.inLink=!0,e={type:"link",raw:u,href:r,title:t,text:i,tokens:n.inlineTokens(i)},n.state.inLink=!1,e):{type:"image",raw:u,href:r,title:t,text:c(i)}}var w=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.space=function(e){e=this.rules.block.newline.exec(e);if(e&&0<e[0].length)return{type:"space",raw:e[0]}},t.code=function(e){var t,e=this.rules.block.code.exec(e);if(e)return t=e[0].replace(/^ {1,4}/gm,""),{type:"code",raw:e[0],codeBlockStyle:"indented",text:this.options.pedantic?t:E(t,"\n")}},t.fences=function(e){var t,u,n,r,e=this.rules.block.fences.exec(e);if(e)return t=e[0],u=t,n=e[3]||"",u=null===(u=t.match(/^(\s+)(?:```)/))?n:(r=u[1],n.split("\n").map(function(e){var t=e.match(/^\s+/);return null!==t&&t[0].length>=r.length?e.slice(r.length):e}).join("\n")),{type:"code",raw:t,lang:e[2]&&e[2].trim().replace(this.rules.inline._escapes,"$1"),text:u}},t.heading=function(e){var t,u,e=this.rules.block.heading.exec(e);if(e)return t=e[2].trim(),/#$/.test(t)&&(u=E(t,"#"),!this.options.pedantic&&u&&!/ $/.test(u)||(t=u.trim())),{type:"heading",raw:e[0],depth:e[1].length,text:t,tokens:this.lexer.inline(t)}},t.hr=function(e){e=this.rules.block.hr.exec(e);if(e)return{type:"hr",raw:e[0]}},t.blockquote=function(e){var t,u,n,e=this.rules.block.blockquote.exec(e);if(e)return t=e[0].replace(/^ *>[ \t]?/gm,""),u=this.lexer.state.top,this.lexer.state.top=!0,n=this.lexer.blockTokens(t),this.lexer.state.top=u,{type:"blockquote",raw:e[0],tokens:n,text:t}},t.list=function(e){var t=this.rules.block.list.exec(e);if(t){var u,n,r,i,s,l,a,o,D,c,h,p=1<(g=t[1].trim()).length,f={type:"list",raw:"",ordered:p,start:p?+g.slice(0,-1):"",loose:!1,items:[]},g=p?"\\d{1,9}\\"+g.slice(-1):"\\"+g;this.options.pedantic&&(g=p?g:"[*+-]");for(var F=new RegExp("^( {0,3}"+g+")((?:[\t ][^\\n]*)?(?:\\n|$))");e&&(h=!1,t=F.exec(e))&&!this.rules.block.hr.test(e);){if(u=t[0],e=e.substring(u.length),a=t[2].split("\n",1)[0].replace(/^\t+/,function(e){return" ".repeat(3*e.length)}),o=e.split("\n",1)[0],this.options.pedantic?(i=2,c=a.trimLeft()):(i=t[2].search(/[^ ]/),c=a.slice(i=4<i?1:i),i+=t[1].length),s=!1,!a&&/^ *$/.test(o)&&(u+=o+"\n",e=e.substring(o.length+1),h=!0),!h)for(var A=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))"),d=new RegExp("^ {0,"+Math.min(3,i-1)+"}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)"),C=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:```|~~~)"),k=new RegExp("^ {0,"+Math.min(3,i-1)+"}#");e&&(o=D=e.split("\n",1)[0],this.options.pedantic&&(o=o.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!C.test(o))&&!k.test(o)&&!A.test(o)&&!d.test(e);){if(o.search(/[^ ]/)>=i||!o.trim())c+="\n"+o.slice(i);else{if(s)break;if(4<=a.search(/[^ ]/))break;if(C.test(a))break;if(k.test(a))break;if(d.test(a))break;c+="\n"+o}s||o.trim()||(s=!0),u+=D+"\n",e=e.substring(D.length+1),a=o.slice(i)}f.loose||(l?f.loose=!0:/\n *\n *$/.test(u)&&(l=!0)),this.options.gfm&&(n=/^\[[ xX]\] /.exec(c))&&(r="[ ] "!==n[0],c=c.replace(/^\[[ xX]\] +/,"")),f.items.push({type:"list_item",raw:u,task:!!n,checked:r,loose:!1,text:c}),f.raw+=u}f.items[f.items.length-1].raw=u.trimRight(),f.items[f.items.length-1].text=c.trimRight(),f.raw=f.raw.trimRight();for(var E,x=f.items.length,m=0;m<x;m++)this.lexer.state.top=!1,f.items[m].tokens=this.lexer.blockTokens(f.items[m].text,[]),f.loose||(E=0<(E=f.items[m].tokens.filter(function(e){return"space"===e.type})).length&&E.some(function(e){return/\n.*\n/.test(e.raw)}),f.loose=E);if(f.loose)for(m=0;m<x;m++)f.items[m].loose=!0;return f}},t.html=function(e){var t,e=this.rules.block.html.exec(e);if(e)return t={type:"html",raw:e[0],pre:!this.options.sanitizer&&("pre"===e[1]||"script"===e[1]||"style"===e[1]),text:e[0]},this.options.sanitize&&(e=this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]),t.type="paragraph",t.text=e,t.tokens=this.lexer.inline(e)),t},t.def=function(e){var t,u,n,e=this.rules.block.def.exec(e);if(e)return t=e[1].toLowerCase().replace(/\s+/g," "),u=e[2]?e[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline._escapes,"$1"):"",n=e[3]&&e[3].substring(1,e[3].length-1).replace(this.rules.inline._escapes,"$1"),{type:"def",tag:t,raw:e[0],href:u,title:n}},t.table=function(e){e=this.rules.block.table.exec(e);if(e){var t={type:"table",header:k(e[1]).map(function(e){return{text:e}}),align:e[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:e[3]&&e[3].trim()?e[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(t.header.length===t.align.length){t.raw=e[0];for(var u,n,r,i=t.align.length,s=0;s<i;s++)/^ *-+: *$/.test(t.align[s])?t.align[s]="right":/^ *:-+: *$/.test(t.align[s])?t.align[s]="center":/^ *:-+ *$/.test(t.align[s])?t.align[s]="left":t.align[s]=null;for(i=t.rows.length,s=0;s<i;s++)t.rows[s]=k(t.rows[s],t.header.length).map(function(e){return{text:e}});for(i=t.header.length,u=0;u<i;u++)t.header[u].tokens=this.lexer.inline(t.header[u].text);for(i=t.rows.length,u=0;u<i;u++)for(r=t.rows[u],n=0;n<r.length;n++)r[n].tokens=this.lexer.inline(r[n].text);return t}}},t.lheading=function(e){e=this.rules.block.lheading.exec(e);if(e)return{type:"heading",raw:e[0],depth:"="===e[2].charAt(0)?1:2,text:e[1],tokens:this.lexer.inline(e[1])}},t.paragraph=function(e){var t,e=this.rules.block.paragraph.exec(e);if(e)return t="\n"===e[1].charAt(e[1].length-1)?e[1].slice(0,-1):e[1],{type:"paragraph",raw:e[0],text:t,tokens:this.lexer.inline(t)}},t.text=function(e){e=this.rules.block.text.exec(e);if(e)return{type:"text",raw:e[0],text:e[0],tokens:this.lexer.inline(e[0])}},t.escape=function(e){e=this.rules.inline.escape.exec(e);if(e)return{type:"escape",raw:e[0],text:c(e[1])}},t.tag=function(e){e=this.rules.inline.tag.exec(e);if(e)return!this.lexer.state.inLink&&/^<a /i.test(e[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(e[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(e[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:e[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]):e[0]}},t.link=function(e){e=this.rules.inline.link.exec(e);if(e){var t=e[2].trim();if(!this.options.pedantic&&/^</.test(t)){if(!/>$/.test(t))return;var u=E(t.slice(0,-1),"\\");if((t.length-u.length)%2==0)return}else{u=function(e,t){if(-1!==e.indexOf(t[1]))for(var u=e.length,n=0,r=0;r<u;r++)if("\\"===e[r])r++;else if(e[r]===t[0])n++;else if(e[r]===t[1]&&--n<0)return r;return-1}(e[2],"()");-1<u&&(r=(0===e[0].indexOf("!")?5:4)+e[1].length+u,e[2]=e[2].substring(0,u),e[0]=e[0].substring(0,r).trim(),e[3]="")}var n,u=e[2],r="";return this.options.pedantic?(n=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(u))&&(u=n[1],r=n[3]):r=e[3]?e[3].slice(1,-1):"",u=u.trim(),B(e,{href:(u=/^</.test(u)?this.options.pedantic&&!/>$/.test(t)?u.slice(1):u.slice(1,-1):u)&&u.replace(this.rules.inline._escapes,"$1"),title:r&&r.replace(this.rules.inline._escapes,"$1")},e[0],this.lexer)}},t.reflink=function(e,t){var u;if(u=(u=this.rules.inline.reflink.exec(e))||this.rules.inline.nolink.exec(e))return(e=t[(e=(u[2]||u[1]).replace(/\s+/g," ")).toLowerCase()])?B(u,e,u[0],this.lexer):{type:"text",raw:t=u[0].charAt(0),text:t}},t.emStrong=function(e,t,u){void 0===u&&(u="");var n=this.rules.inline.emStrong.lDelim.exec(e);if(n&&(!n[3]||!u.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))){var r=n[1]||n[2]||"";if(!r||""===u||this.rules.inline.punctuation.exec(u)){var i=n[0].length-1,s=i,l=0,a="*"===n[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(a.lastIndex=0,t=t.slice(-1*e.length+i);null!=(n=a.exec(t));){var o,D=n[1]||n[2]||n[3]||n[4]||n[5]||n[6];if(D)if(o=D.length,n[3]||n[4])s+=o;else if((n[5]||n[6])&&i%3&&!((i+o)%3))l+=o;else if(!(0<(s-=o)))return o=Math.min(o,o+s+l),D=e.slice(0,i+n.index+(n[0].length-D.length)+o),Math.min(i,o)%2?(o=D.slice(1,-1),{type:"em",raw:D,text:o,tokens:this.lexer.inlineTokens(o)}):(o=D.slice(2,-2),{type:"strong",raw:D,text:o,tokens:this.lexer.inlineTokens(o)})}}}},t.codespan=function(e){var t,u,n,e=this.rules.inline.code.exec(e);if(e)return n=e[2].replace(/\n/g," "),t=/[^ ]/.test(n),u=/^ /.test(n)&&/ $/.test(n),n=c(n=t&&u?n.substring(1,n.length-1):n,!0),{type:"codespan",raw:e[0],text:n}},t.br=function(e){e=this.rules.inline.br.exec(e);if(e)return{type:"br",raw:e[0]}},t.del=function(e){e=this.rules.inline.del.exec(e);if(e)return{type:"del",raw:e[0],text:e[2],tokens:this.lexer.inlineTokens(e[2])}},t.autolink=function(e,t){var u,e=this.rules.inline.autolink.exec(e);if(e)return t="@"===e[2]?"mailto:"+(u=c(this.options.mangle?t(e[1]):e[1])):u=c(e[1]),{type:"link",raw:e[0],text:u,href:t,tokens:[{type:"text",raw:u,text:u}]}},t.url=function(e,t){var u,n,r,i;if(u=this.rules.inline.url.exec(e)){if("@"===u[2])r="mailto:"+(n=c(this.options.mangle?t(u[0]):u[0]));else{for(;i=u[0],u[0]=this.rules.inline._backpedal.exec(u[0])[0],i!==u[0];);n=c(u[0]),r="www."===u[1]?"http://"+u[0]:u[0]}return{type:"link",raw:u[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}},t.inlineText=function(e,t){e=this.rules.inline.text.exec(e);if(e)return t=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(e[0]):c(e[0]):e[0]:c(this.options.smartypants?t(e[0]):e[0]),{type:"text",raw:e[0],text:t}},e}(),y={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:d,lheading:/^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/},v=(y.def=f(y.def).replace("label",y._label).replace("title",y._title).getRegex(),y.bullet=/(?:[*+-]|\d{1,9}[.)])/,y.listItemStart=f(/^( *)(bull) */).replace("bull",y.bullet).getRegex(),y.list=f(y.list).replace(/bull/g,y.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+y.def.source+")").getRegex(),y._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",y._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,y.html=f(y.html,"i").replace("comment",y._comment).replace("tag",y._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),y.paragraph=f(y._paragraph).replace("hr",y.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",y._tag).getRegex(),y.blockquote=f(y.blockquote).replace("paragraph",y.paragraph).getRegex(),y.normal=C({},y),y.gfm=C({},y.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),y.gfm.table=f(y.gfm.table).replace("hr",y.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",y._tag).getRegex(),y.gfm.paragraph=f(y._paragraph).replace("hr",y.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",y.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",y._tag).getRegex(),y.pedantic=C({},y.normal,{html:f("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",y._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:d,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:f(y.normal._paragraph).replace("hr",y.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",y.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()}),{escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:d,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,rDelimUnd:/^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:d,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/});function L(e){return e.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…")}function _(e){for(var t,u="",n=e.length,r=0;r<n;r++)t=e.charCodeAt(r),u+="&#"+(t=.5<Math.random()?"x"+t.toString(16):t)+";";return u}v._punctuation="!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~",v.punctuation=f(v.punctuation).replace(/punctuation/g,v._punctuation).getRegex(),v.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,v.escapedEmSt=/(?:^|[^\\])(?:\\\\)*\\[*_]/g,v._comment=f(y._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),v.emStrong.lDelim=f(v.emStrong.lDelim).replace(/punct/g,v._punctuation).getRegex(),v.emStrong.rDelimAst=f(v.emStrong.rDelimAst,"g").replace(/punct/g,v._punctuation).getRegex(),v.emStrong.rDelimUnd=f(v.emStrong.rDelimUnd,"g").replace(/punct/g,v._punctuation).getRegex(),v._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,v._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,v._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,v.autolink=f(v.autolink).replace("scheme",v._scheme).replace("email",v._email).getRegex(),v._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,v.tag=f(v.tag).replace("comment",v._comment).replace("attribute",v._attribute).getRegex(),v._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,v._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,v._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,v.link=f(v.link).replace("label",v._label).replace("href",v._href).replace("title",v._title).getRegex(),v.reflink=f(v.reflink).replace("label",v._label).replace("ref",y._label).getRegex(),v.nolink=f(v.nolink).replace("ref",y._label).getRegex(),v.reflinkSearch=f(v.reflinkSearch,"g").replace("reflink",v.reflink).replace("nolink",v.nolink).getRegex(),v.normal=C({},v),v.pedantic=C({},v.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:f(/^!?\[(label)\]\((.*?)\)/).replace("label",v._label).getRegex(),reflink:f(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",v._label).getRegex()}),v.gfm=C({},v.normal,{escape:f(v.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),v.gfm.url=f(v.gfm.url,"i").replace("email",v.gfm._extended_email).getRegex(),v.breaks=C({},v.gfm,{br:f(v.br).replace("{2,}","*").getRegex(),text:f(v.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()});var z=function(){function u(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||r.defaults,this.options.tokenizer=this.options.tokenizer||new w,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,(this.tokenizer.lexer=this).inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};e={block:y.normal,inline:v.normal};this.options.pedantic?(e.block=y.pedantic,e.inline=v.pedantic):this.options.gfm&&(e.block=y.gfm,this.options.breaks?e.inline=v.breaks:e.inline=v.gfm),this.tokenizer.rules=e}u.lex=function(e,t){return new u(t).lex(e)},u.lexInline=function(e,t){return new u(t).inlineTokens(e)};var e,t,n=u.prototype;return n.lex=function(e){var t;for(e=e.replace(/\r\n|\r/g,"\n"),this.blockTokens(e,this.tokens);t=this.inlineQueue.shift();)this.inlineTokens(t.src,t.tokens);return this.tokens},n.blockTokens=function(r,t){var u,e,i,n,s=this;for(void 0===t&&(t=[]),r=this.options.pedantic?r.replace(/\t/g,"    ").replace(/^ +$/gm,""):r.replace(/^( *)(\t+)/gm,function(e,t,u){return t+"    ".repeat(u.length)});r;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(function(e){return!!(u=e.call({lexer:s},r,t))&&(r=r.substring(u.raw.length),t.push(u),!0)})))if(u=this.tokenizer.space(r))r=r.substring(u.raw.length),1===u.raw.length&&0<t.length?t[t.length-1].raw+="\n":t.push(u);else if(u=this.tokenizer.code(r))r=r.substring(u.raw.length),!(e=t[t.length-1])||"paragraph"!==e.type&&"text"!==e.type?t.push(u):(e.raw+="\n"+u.raw,e.text+="\n"+u.text,this.inlineQueue[this.inlineQueue.length-1].src=e.text);else if(u=this.tokenizer.fences(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.heading(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.hr(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.blockquote(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.list(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.html(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.def(r))r=r.substring(u.raw.length),!(e=t[t.length-1])||"paragraph"!==e.type&&"text"!==e.type?this.tokens.links[u.tag]||(this.tokens.links[u.tag]={href:u.href,title:u.title}):(e.raw+="\n"+u.raw,e.text+="\n"+u.raw,this.inlineQueue[this.inlineQueue.length-1].src=e.text);else if(u=this.tokenizer.table(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.lheading(r))r=r.substring(u.raw.length),t.push(u);else if(i=r,this.options.extensions&&this.options.extensions.startBlock&&!function(){var t=1/0,u=r.slice(1),n=void 0;s.options.extensions.startBlock.forEach(function(e){"number"==typeof(n=e.call({lexer:this},u))&&0<=n&&(t=Math.min(t,n))}),t<1/0&&0<=t&&(i=r.substring(0,t+1))}(),this.state.top&&(u=this.tokenizer.paragraph(i)))e=t[t.length-1],n&&"paragraph"===e.type?(e.raw+="\n"+u.raw,e.text+="\n"+u.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=e.text):t.push(u),n=i.length!==r.length,r=r.substring(u.raw.length);else if(u=this.tokenizer.text(r))r=r.substring(u.raw.length),(e=t[t.length-1])&&"text"===e.type?(e.raw+="\n"+u.raw,e.text+="\n"+u.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=e.text):t.push(u);else if(r){var l="Infinite loop on byte: "+r.charCodeAt(0);if(this.options.silent){console.error(l);break}throw new Error(l)}return this.state.top=!0,t},n.inline=function(e,t){return this.inlineQueue.push({src:e,tokens:t=void 0===t?[]:t}),t},n.inlineTokens=function(r,t){var u,e,i,n,s,l,a=this,o=(void 0===t&&(t=[]),r);if(this.tokens.links){var D=Object.keys(this.tokens.links);if(0<D.length)for(;null!=(n=this.tokenizer.rules.inline.reflinkSearch.exec(o));)D.includes(n[0].slice(n[0].lastIndexOf("[")+1,-1))&&(o=o.slice(0,n.index)+"["+b("a",n[0].length-2)+"]"+o.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(n=this.tokenizer.rules.inline.blockSkip.exec(o));)o=o.slice(0,n.index)+"["+b("a",n[0].length-2)+"]"+o.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(n=this.tokenizer.rules.inline.escapedEmSt.exec(o));)o=o.slice(0,n.index+n[0].length-2)+"++"+o.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex),this.tokenizer.rules.inline.escapedEmSt.lastIndex--;for(;r;)if(s||(l=""),s=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some(function(e){return!!(u=e.call({lexer:a},r,t))&&(r=r.substring(u.raw.length),t.push(u),!0)})))if(u=this.tokenizer.escape(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.tag(r))r=r.substring(u.raw.length),(e=t[t.length-1])&&"text"===u.type&&"text"===e.type?(e.raw+=u.raw,e.text+=u.text):t.push(u);else if(u=this.tokenizer.link(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.reflink(r,this.tokens.links))r=r.substring(u.raw.length),(e=t[t.length-1])&&"text"===u.type&&"text"===e.type?(e.raw+=u.raw,e.text+=u.text):t.push(u);else if(u=this.tokenizer.emStrong(r,o,l))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.codespan(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.br(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.del(r))r=r.substring(u.raw.length),t.push(u);else if(u=this.tokenizer.autolink(r,_))r=r.substring(u.raw.length),t.push(u);else if(!this.state.inLink&&(u=this.tokenizer.url(r,_)))r=r.substring(u.raw.length),t.push(u);else if(i=r,this.options.extensions&&this.options.extensions.startInline&&!function(){var t=1/0,u=r.slice(1),n=void 0;a.options.extensions.startInline.forEach(function(e){"number"==typeof(n=e.call({lexer:this},u))&&0<=n&&(t=Math.min(t,n))}),t<1/0&&0<=t&&(i=r.substring(0,t+1))}(),u=this.tokenizer.inlineText(i,L))r=r.substring(u.raw.length),"_"!==u.raw.slice(-1)&&(l=u.raw.slice(-1)),s=!0,(e=t[t.length-1])&&"text"===e.type?(e.raw+=u.raw,e.text+=u.text):t.push(u);else if(r){var c="Infinite loop on byte: "+r.charCodeAt(0);if(this.options.silent){console.error(c);break}throw new Error(c)}return t},n=u,t=[{key:"rules",get:function(){return{block:y,inline:v}}}],(e=null)&&i(n.prototype,e),t&&i(n,t),Object.defineProperty(n,"prototype",{writable:!1}),u}(),$=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.code=function(e,t,u){var n,t=(t||"").match(/\S*/)[0];return this.options.highlight&&null!=(n=this.options.highlight(e,t))&&n!==e&&(u=!0,e=n),e=e.replace(/\n$/,"")+"\n",t?'<pre><code class="'+this.options.langPrefix+c(t)+'">'+(u?e:c(e,!0))+"</code></pre>\n":"<pre><code>"+(u?e:c(e,!0))+"</code></pre>\n"},t.blockquote=function(e){return"<blockquote>\n"+e+"</blockquote>\n"},t.html=function(e){return e},t.heading=function(e,t,u,n){return this.options.headerIds?"<h"+t+' id="'+(this.options.headerPrefix+n.slug(u))+'">'+e+"</h"+t+">\n":"<h"+t+">"+e+"</h"+t+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(e,t,u){var n=t?"ol":"ul";return"<"+n+(t&&1!==u?' start="'+u+'"':"")+">\n"+e+"</"+n+">\n"},t.listitem=function(e){return"<li>"+e+"</li>\n"},t.checkbox=function(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(e){return"<p>"+e+"</p>\n"},t.table=function(e,t){return"<table>\n<thead>\n"+e+"</thead>\n"+(t=t&&"<tbody>"+t+"</tbody>")+"</table>\n"},t.tablerow=function(e){return"<tr>\n"+e+"</tr>\n"},t.tablecell=function(e,t){var u=t.header?"th":"td";return(t.align?"<"+u+' align="'+t.align+'">':"<"+u+">")+e+"</"+u+">\n"},t.strong=function(e){return"<strong>"+e+"</strong>"},t.em=function(e){return"<em>"+e+"</em>"},t.codespan=function(e){return"<code>"+e+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(e){return"<del>"+e+"</del>"},t.link=function(e,t,u){return null===(e=F(this.options.sanitize,this.options.baseUrl,e))?u:(e='<a href="'+e+'"',t&&(e+=' title="'+t+'"'),e+">"+u+"</a>")},t.image=function(e,t,u){return null===(e=F(this.options.sanitize,this.options.baseUrl,e))?u:(e='<img src="'+e+'" alt="'+u+'"',t&&(e+=' title="'+t+'"'),e+(this.options.xhtml?"/>":">"))},t.text=function(e){return e},e}(),S=function(){function e(){}var t=e.prototype;return t.strong=function(e){return e},t.em=function(e){return e},t.codespan=function(e){return e},t.del=function(e){return e},t.html=function(e){return e},t.text=function(e){return e},t.link=function(e,t,u){return""+u},t.image=function(e,t,u){return""+u},t.br=function(){return""},e}(),T=function(){function e(){this.seen={}}var t=e.prototype;return t.serialize=function(e){return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},t.getNextSafeSlug=function(e,t){var u=e,n=0;if(this.seen.hasOwnProperty(u))for(n=this.seen[e];u=e+"-"+ ++n,this.seen.hasOwnProperty(u););return t||(this.seen[e]=n,this.seen[u]=0),u},t.slug=function(e,t){void 0===t&&(t={});e=this.serialize(e);return this.getNextSafeSlug(e,t.dryrun)},e}(),R=function(){function u(e){this.options=e||r.defaults,this.options.renderer=this.options.renderer||new $,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new S,this.slugger=new T}u.parse=function(e,t){return new u(t).parse(e)},u.parseInline=function(e,t){return new u(t).parseInline(e)};var e=u.prototype;return e.parse=function(e,t){void 0===t&&(t=!0);for(var u,n,r,i,s,l,a,o,D,c,h,p,f,g,F,A,d="",C=e.length,k=0;k<C;k++)if(o=e[k],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[o.type]&&(!1!==(A=this.options.extensions.renderers[o.type].call({parser:this},o))||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(o.type)))d+=A||"";else switch(o.type){case"space":continue;case"hr":d+=this.renderer.hr();continue;case"heading":d+=this.renderer.heading(this.parseInline(o.tokens),o.depth,x(this.parseInline(o.tokens,this.textRenderer)),this.slugger);continue;case"code":d+=this.renderer.code(o.text,o.lang,o.escaped);continue;case"table":for(l=D="",r=o.header.length,u=0;u<r;u++)l+=this.renderer.tablecell(this.parseInline(o.header[u].tokens),{header:!0,align:o.align[u]});for(D+=this.renderer.tablerow(l),a="",r=o.rows.length,u=0;u<r;u++){for(l="",i=(s=o.rows[u]).length,n=0;n<i;n++)l+=this.renderer.tablecell(this.parseInline(s[n].tokens),{header:!1,align:o.align[n]});a+=this.renderer.tablerow(l)}d+=this.renderer.table(D,a);continue;case"blockquote":a=this.parse(o.tokens),d+=this.renderer.blockquote(a);continue;case"list":for(D=o.ordered,E=o.start,c=o.loose,r=o.items.length,a="",u=0;u<r;u++)f=(p=o.items[u]).checked,g=p.task,h="",p.task&&(F=this.renderer.checkbox(f),c?0<p.tokens.length&&"paragraph"===p.tokens[0].type?(p.tokens[0].text=F+" "+p.tokens[0].text,p.tokens[0].tokens&&0<p.tokens[0].tokens.length&&"text"===p.tokens[0].tokens[0].type&&(p.tokens[0].tokens[0].text=F+" "+p.tokens[0].tokens[0].text)):p.tokens.unshift({type:"text",text:F}):h+=F),h+=this.parse(p.tokens,c),a+=this.renderer.listitem(h,g,f);d+=this.renderer.list(a,D,E);continue;case"html":d+=this.renderer.html(o.text);continue;case"paragraph":d+=this.renderer.paragraph(this.parseInline(o.tokens));continue;case"text":for(a=o.tokens?this.parseInline(o.tokens):o.text;k+1<C&&"text"===e[k+1].type;)a+="\n"+((o=e[++k]).tokens?this.parseInline(o.tokens):o.text);d+=t?this.renderer.paragraph(a):a;continue;default:var E='Token with "'+o.type+'" type was not found.';if(this.options.silent)return void console.error(E);throw new Error(E)}return d},e.parseInline=function(e,t){t=t||this.renderer;for(var u,n,r="",i=e.length,s=0;s<i;s++)if(u=e[s],this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[u.type]&&(!1!==(n=this.options.extensions.renderers[u.type].call({parser:this},u))||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(u.type)))r+=n||"";else switch(u.type){case"escape":r+=t.text(u.text);break;case"html":r+=t.html(u.text);break;case"link":r+=t.link(u.href,u.title,this.parseInline(u.tokens,t));break;case"image":r+=t.image(u.href,u.title,u.text);break;case"strong":r+=t.strong(this.parseInline(u.tokens,t));break;case"em":r+=t.em(this.parseInline(u.tokens,t));break;case"codespan":r+=t.codespan(u.text);break;case"br":r+=t.br();break;case"del":r+=t.del(this.parseInline(u.tokens,t));break;case"text":r+=t.text(u.text);break;default:var l='Token with "'+u.type+'" type was not found.';if(this.options.silent)return void console.error(l);throw new Error(l)}return r},u}();function I(e,u,n){if(null==e)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");if("function"==typeof u&&(n=u,u=null),m(u=C({},I.defaults,u||{})),n){var r,i=u.highlight;try{r=z.lex(e,u)}catch(e){return n(e)}var s,l=function(t){var e;if(!t)try{u.walkTokens&&I.walkTokens(r,u.walkTokens),e=R.parse(r,u)}catch(e){t=e}return u.highlight=i,t?n(t):n(null,e)};return!i||i.length<3?l():(delete u.highlight,r.length?(s=0,I.walkTokens(r,function(u){"code"===u.type&&(s++,setTimeout(function(){i(u.text,u.lang,function(e,t){if(e)return l(e);null!=t&&t!==u.text&&(u.text=t,u.escaped=!0),0===--s&&l()})},0))}),void(0===s&&l())):l())}function t(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",u.silent)return"<p>An error occurred:</p><pre>"+c(e.message+"",!0)+"</pre>";throw e}try{var a=z.lex(e,u);if(u.walkTokens){if(u.async)return Promise.all(I.walkTokens(a,u.walkTokens)).then(function(){return R.parse(a,u)}).catch(t);I.walkTokens(a,u.walkTokens)}return R.parse(a,u)}catch(e){t(e)}}I.options=I.setOptions=function(e){return C(I.defaults,e),e=I.defaults,r.defaults=e,I},I.getDefaults=e,I.defaults=r.defaults,I.use=function(){for(var o=I.defaults.extensions||{renderers:{},childTokens:{}},e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];t.forEach(function(s){var u,e=C({},s);if(e.async=I.defaults.async||e.async,s.extensions&&(s.extensions.forEach(function(r){if(!r.name)throw new Error("extension name required");var i;if(r.renderer&&(i=o.renderers[r.name],o.renderers[r.name]=i?function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=r.renderer.apply(this,t);return n=!1===n?i.apply(this,t):n}:r.renderer),r.tokenizer){if(!r.level||"block"!==r.level&&"inline"!==r.level)throw new Error("extension level must be 'block' or 'inline'");o[r.level]?o[r.level].unshift(r.tokenizer):o[r.level]=[r.tokenizer],r.start&&("block"===r.level?o.startBlock?o.startBlock.push(r.start):o.startBlock=[r.start]:"inline"===r.level&&(o.startInline?o.startInline.push(r.start):o.startInline=[r.start]))}r.childTokens&&(o.childTokens[r.name]=r.childTokens)}),e.extensions=o),s.renderer){var t,l=I.defaults.renderer||new $;for(t in s.renderer)!function(r){var i=l[r];l[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.renderer[r].apply(l,t);return n=!1===n?i.apply(l,t):n}}(t);e.renderer=l}if(s.tokenizer){var n,a=I.defaults.tokenizer||new w;for(n in s.tokenizer)!function(r){var i=a[r];a[r]=function(){for(var e=arguments.length,t=new Array(e),u=0;u<e;u++)t[u]=arguments[u];var n=s.tokenizer[r].apply(a,t);return n=!1===n?i.apply(a,t):n}}(n);e.tokenizer=a}s.walkTokens&&(u=I.defaults.walkTokens,e.walkTokens=function(e){var t=[];return t.push(s.walkTokens.call(this,e)),t=u?t.concat(u.call(this,e)):t}),I.setOptions(e)})},I.walkTokens=function(e,l){for(var a,o=[],t=D(e);!(a=t()).done;)!function(){var t=a.value;switch(o=o.concat(l.call(I,t)),t.type){case"table":for(var e=D(t.header);!(u=e()).done;){var u=u.value;o=o.concat(I.walkTokens(u.tokens,l))}for(var n,r=D(t.rows);!(n=r()).done;)for(var i=D(n.value);!(s=i()).done;){var s=s.value;o=o.concat(I.walkTokens(s.tokens,l))}break;case"list":o=o.concat(I.walkTokens(t.items,l));break;default:I.defaults.extensions&&I.defaults.extensions.childTokens&&I.defaults.extensions.childTokens[t.type]?I.defaults.extensions.childTokens[t.type].forEach(function(e){o=o.concat(I.walkTokens(t[e],l))}):t.tokens&&(o=o.concat(I.walkTokens(t.tokens,l)))}}();return o},I.parseInline=function(e,t){if(null==e)throw new Error("marked.parseInline(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked.parseInline(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");m(t=C({},I.defaults,t||{}));try{var u=z.lexInline(e,t);return t.walkTokens&&I.walkTokens(u,t.walkTokens),R.parseInline(u,t)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",t.silent)return"<p>An error occurred:</p><pre>"+c(e.message+"",!0)+"</pre>";throw e}},I.Parser=R,I.parser=R.parse,I.Renderer=$,I.TextRenderer=S,I.Lexer=z,I.lexer=z.lex,I.Tokenizer=w,I.Slugger=T;var d=(I.parse=I).options,P=I.setOptions,Q=I.use,U=I.walkTokens,M=I.parseInline,N=I,X=R.parse,G=z.lex;r.Lexer=z,r.Parser=R,r.Renderer=$,r.Slugger=T,r.TextRenderer=S,r.Tokenizer=w,r.getDefaults=e,r.lexer=G,r.marked=I,r.options=d,r.parse=N,r.parseInline=M,r.parser=X,r.setOptions=P,r.use=Q,r.walkTokens=U});</script>
    
    <!-- <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.1/dist/purify.min.js"></script> -->
    <script>!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).DOMPurify=t()}(this,(function(){"use strict";function e(t){return e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e(t)}function t(e,n){return t=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},t(e,n)}function n(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function r(e,o,a){return r=n()?Reflect.construct:function(e,n,r){var o=[null];o.push.apply(o,n);var a=new(Function.bind.apply(e,o));return r&&t(a,r.prototype),a},r.apply(null,arguments)}function o(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,o,a=[],i=!0,l=!1;try{for(n=n.call(e);!(i=(r=n.next()).done)&&(a.push(r.value),!t||a.length!==t);i=!0);}catch(e){l=!0,o=e}finally{try{i||null==n.return||n.return()}finally{if(l)throw o}}return a}(e,t)||i(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function a(e){return function(e){if(Array.isArray(e))return l(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||i(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function i(e,t){if(e){if("string"==typeof e)return l(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?l(e,t):void 0}}function l(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var c=Object.entries,u=Object.setPrototypeOf,s=Object.isFrozen,f=Object.getPrototypeOf,m=Object.getOwnPropertyDescriptor,p=Object.freeze,d=Object.seal,h=Object.create,y="undefined"!=typeof Reflect&&Reflect,g=y.apply,b=y.construct;g||(g=function(e,t,n){return e.apply(t,n)}),p||(p=function(e){return e}),d||(d=function(e){return e}),b||(b=function(e,t){return r(e,a(t))});var v,T=R(Array.prototype.forEach),N=R(Array.prototype.pop),A=R(Array.prototype.push),E=R(String.prototype.toLowerCase),w=R(String.prototype.toString),S=R(String.prototype.match),_=R(String.prototype.replace),x=R(String.prototype.indexOf),k=R(String.prototype.trim),O=R(RegExp.prototype.test),D=(v=TypeError,function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return b(v,t)});function R(e){return function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];return g(e,t,r)}}function C(e,t,n){n=n||E,u&&u(e,null);for(var r=t.length;r--;){var o=t[r];if("string"==typeof o){var a=n(o);a!==o&&(s(t)||(t[r]=a),o=a)}e[o]=!0}return e}function L(e){var t,n=h(null),r=function(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=i(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,o=function(){};return{s:o,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,l=!0,c=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return l=e.done,e},e:function(e){c=!0,a=e},f:function(){try{l||null==n.return||n.return()}finally{if(c)throw a}}}}(c(e));try{for(r.s();!(t=r.n()).done;){var a=o(t.value,2),l=a[0],u=a[1];n[l]=u}}catch(e){r.e(e)}finally{r.f()}return n}function M(e,t){for(;null!==e;){var n=m(e,t);if(n){if(n.get)return R(n.get);if("function"==typeof n.value)return R(n.value)}e=f(e)}return function(e){return console.warn("fallback value for",e),null}}var I=p(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),U=p(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),F=p(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),z=p(["animate","color-profile","cursor","discard","fedropshadow","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),H=p(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),j=p(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),P=p(["#text"]),B=p(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","nonce","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns","slot"]),G=p(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","transform-origin","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),W=p(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),q=p(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),Y=d(/\{\{[\w\W]*|[\w\W]*\}\}/gm),$=d(/<%[\w\W]*|[\w\W]*%>/gm),K=d(/\${[\w\W]*}/gm),V=d(/^data-[\-\w.\u00B7-\uFFFF]/),X=d(/^aria-[\-\w]+$/),Z=d(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),J=d(/^(?:\w+script|data):/i),Q=d(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),ee=d(/^html$/i),te=function(){return"undefined"==typeof window?null:window},ne=function(t,n){if("object"!==e(t)||"function"!=typeof t.createPolicy)return null;var r=null,o="data-tt-policy-suffix";n.currentScript&&n.currentScript.hasAttribute(o)&&(r=n.currentScript.getAttribute(o));var a="dompurify"+(r?"#"+r:"");try{return t.createPolicy(a,{createHTML:function(e){return e},createScriptURL:function(e){return e}})}catch(e){return console.warn("TrustedTypes policy "+a+" could not be created."),null}};var re=function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:te(),r=function(e){return t(e)};if(r.version="3.0.1",r.removed=[],!n||!n.document||9!==n.document.nodeType)return r.isSupported=!1,r;var o=n.document,i=n.document,l=n.DocumentFragment,u=n.HTMLTemplateElement,s=n.Node,f=n.Element,m=n.NodeFilter,d=n.NamedNodeMap,h=void 0===d?n.NamedNodeMap||n.MozNamedAttrMap:d,y=n.HTMLFormElement,g=n.DOMParser,b=n.trustedTypes,v=f.prototype,R=M(v,"cloneNode"),re=M(v,"nextSibling"),oe=M(v,"childNodes"),ae=M(v,"parentNode");if("function"==typeof u){var ie=i.createElement("template");ie.content&&ie.content.ownerDocument&&(i=ie.content.ownerDocument)}var le=ne(b,o),ce=le?le.createHTML(""):"",ue=i,se=ue.implementation,fe=ue.createNodeIterator,me=ue.createDocumentFragment,pe=ue.getElementsByTagName,de=o.importNode,he={};r.isSupported="function"==typeof c&&"function"==typeof ae&&se&&void 0!==se.createHTMLDocument;var ye,ge,be=Y,ve=$,Te=K,Ne=V,Ae=X,Ee=J,we=Q,Se=Z,_e=null,xe=C({},[].concat(a(I),a(U),a(F),a(H),a(P))),ke=null,Oe=C({},[].concat(a(B),a(G),a(W),a(q))),De=Object.seal(Object.create(null,{tagNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},attributeNameCheck:{writable:!0,configurable:!1,enumerable:!0,value:null},allowCustomizedBuiltInElements:{writable:!0,configurable:!1,enumerable:!0,value:!1}})),Re=null,Ce=null,Le=!0,Me=!0,Ie=!1,Ue=!0,Fe=!1,ze=!1,He=!1,je=!1,Pe=!1,Be=!1,Ge=!1,We=!0,qe=!1,Ye="user-content-",$e=!0,Ke=!1,Ve={},Xe=null,Ze=C({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),Je=null,Qe=C({},["audio","video","img","source","image","track"]),et=null,tt=C({},["alt","class","for","id","label","name","pattern","placeholder","role","summary","title","value","style","xmlns"]),nt="http://www.w3.org/1998/Math/MathML",rt="http://www.w3.org/2000/svg",ot="http://www.w3.org/1999/xhtml",at=ot,it=!1,lt=null,ct=C({},[nt,rt,ot],w),ut=["application/xhtml+xml","text/html"],st="text/html",ft=null,mt=i.createElement("form"),pt=function(e){return e instanceof RegExp||e instanceof Function},dt=function(t){ft&&ft===t||(t&&"object"===e(t)||(t={}),t=L(t),ye=ye=-1===ut.indexOf(t.PARSER_MEDIA_TYPE)?st:t.PARSER_MEDIA_TYPE,ge="application/xhtml+xml"===ye?w:E,_e="ALLOWED_TAGS"in t?C({},t.ALLOWED_TAGS,ge):xe,ke="ALLOWED_ATTR"in t?C({},t.ALLOWED_ATTR,ge):Oe,lt="ALLOWED_NAMESPACES"in t?C({},t.ALLOWED_NAMESPACES,w):ct,et="ADD_URI_SAFE_ATTR"in t?C(L(tt),t.ADD_URI_SAFE_ATTR,ge):tt,Je="ADD_DATA_URI_TAGS"in t?C(L(Qe),t.ADD_DATA_URI_TAGS,ge):Qe,Xe="FORBID_CONTENTS"in t?C({},t.FORBID_CONTENTS,ge):Ze,Re="FORBID_TAGS"in t?C({},t.FORBID_TAGS,ge):{},Ce="FORBID_ATTR"in t?C({},t.FORBID_ATTR,ge):{},Ve="USE_PROFILES"in t&&t.USE_PROFILES,Le=!1!==t.ALLOW_ARIA_ATTR,Me=!1!==t.ALLOW_DATA_ATTR,Ie=t.ALLOW_UNKNOWN_PROTOCOLS||!1,Ue=!1!==t.ALLOW_SELF_CLOSE_IN_ATTR,Fe=t.SAFE_FOR_TEMPLATES||!1,ze=t.WHOLE_DOCUMENT||!1,Pe=t.RETURN_DOM||!1,Be=t.RETURN_DOM_FRAGMENT||!1,Ge=t.RETURN_TRUSTED_TYPE||!1,je=t.FORCE_BODY||!1,We=!1!==t.SANITIZE_DOM,qe=t.SANITIZE_NAMED_PROPS||!1,$e=!1!==t.KEEP_CONTENT,Ke=t.IN_PLACE||!1,Se=t.ALLOWED_URI_REGEXP||Se,at=t.NAMESPACE||ot,De=t.CUSTOM_ELEMENT_HANDLING||{},t.CUSTOM_ELEMENT_HANDLING&&pt(t.CUSTOM_ELEMENT_HANDLING.tagNameCheck)&&(De.tagNameCheck=t.CUSTOM_ELEMENT_HANDLING.tagNameCheck),t.CUSTOM_ELEMENT_HANDLING&&pt(t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)&&(De.attributeNameCheck=t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),t.CUSTOM_ELEMENT_HANDLING&&"boolean"==typeof t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements&&(De.allowCustomizedBuiltInElements=t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),Fe&&(Me=!1),Be&&(Pe=!0),Ve&&(_e=C({},a(P)),ke=[],!0===Ve.html&&(C(_e,I),C(ke,B)),!0===Ve.svg&&(C(_e,U),C(ke,G),C(ke,q)),!0===Ve.svgFilters&&(C(_e,F),C(ke,G),C(ke,q)),!0===Ve.mathMl&&(C(_e,H),C(ke,W),C(ke,q))),t.ADD_TAGS&&(_e===xe&&(_e=L(_e)),C(_e,t.ADD_TAGS,ge)),t.ADD_ATTR&&(ke===Oe&&(ke=L(ke)),C(ke,t.ADD_ATTR,ge)),t.ADD_URI_SAFE_ATTR&&C(et,t.ADD_URI_SAFE_ATTR,ge),t.FORBID_CONTENTS&&(Xe===Ze&&(Xe=L(Xe)),C(Xe,t.FORBID_CONTENTS,ge)),$e&&(_e["#text"]=!0),ze&&C(_e,["html","head","body"]),_e.table&&(C(_e,["tbody"]),delete Re.tbody),p&&p(t),ft=t)},ht=C({},["mi","mo","mn","ms","mtext"]),yt=C({},["foreignobject","desc","title","annotation-xml"]),gt=C({},["title","style","font","a","script"]),bt=C({},U);C(bt,F),C(bt,z);var vt=C({},H);C(vt,j);var Tt=function(e){var t=ae(e);t&&t.tagName||(t={namespaceURI:at,tagName:"template"});var n=E(e.tagName),r=E(t.tagName);return!!lt[e.namespaceURI]&&(e.namespaceURI===rt?t.namespaceURI===ot?"svg"===n:t.namespaceURI===nt?"svg"===n&&("annotation-xml"===r||ht[r]):Boolean(bt[n]):e.namespaceURI===nt?t.namespaceURI===ot?"math"===n:t.namespaceURI===rt?"math"===n&&yt[r]:Boolean(vt[n]):e.namespaceURI===ot?!(t.namespaceURI===rt&&!yt[r])&&(!(t.namespaceURI===nt&&!ht[r])&&(!vt[n]&&(gt[n]||!bt[n]))):!("application/xhtml+xml"!==ye||!lt[e.namespaceURI]))},Nt=function(e){A(r.removed,{element:e});try{e.parentNode.removeChild(e)}catch(t){e.remove()}},At=function(e,t){try{A(r.removed,{attribute:t.getAttributeNode(e),from:t})}catch(e){A(r.removed,{attribute:null,from:t})}if(t.removeAttribute(e),"is"===e&&!ke[e])if(Pe||Be)try{Nt(t)}catch(e){}else try{t.setAttribute(e,"")}catch(e){}},Et=function(e){var t,n;if(je)e="<remove></remove>"+e;else{var r=S(e,/^[\r\n\t ]+/);n=r&&r[0]}"application/xhtml+xml"===ye&&at===ot&&(e='<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>'+e+"</body></html>");var o=le?le.createHTML(e):e;if(at===ot)try{t=(new g).parseFromString(o,ye)}catch(e){}if(!t||!t.documentElement){t=se.createDocument(at,"template",null);try{t.documentElement.innerHTML=it?ce:o}catch(e){}}var a=t.body||t.documentElement;return e&&n&&a.insertBefore(i.createTextNode(n),a.childNodes[0]||null),at===ot?pe.call(t,ze?"html":"body")[0]:ze?t.documentElement:a},wt=function(e){return fe.call(e.ownerDocument||e,e,m.SHOW_ELEMENT|m.SHOW_COMMENT|m.SHOW_TEXT,null,!1)},St=function(e){return e instanceof y&&("string"!=typeof e.nodeName||"string"!=typeof e.textContent||"function"!=typeof e.removeChild||!(e.attributes instanceof h)||"function"!=typeof e.removeAttribute||"function"!=typeof e.setAttribute||"string"!=typeof e.namespaceURI||"function"!=typeof e.insertBefore||"function"!=typeof e.hasChildNodes)},_t=function(t){return"object"===e(s)?t instanceof s:t&&"object"===e(t)&&"number"==typeof t.nodeType&&"string"==typeof t.nodeName},xt=function(e,t,n){he[e]&&T(he[e],(function(e){e.call(r,t,n,ft)}))},kt=function(e){var t;if(xt("beforeSanitizeElements",e,null),St(e))return Nt(e),!0;var n=ge(e.nodeName);if(xt("uponSanitizeElement",e,{tagName:n,allowedTags:_e}),e.hasChildNodes()&&!_t(e.firstElementChild)&&(!_t(e.content)||!_t(e.content.firstElementChild))&&O(/<[/\w]/g,e.innerHTML)&&O(/<[/\w]/g,e.textContent))return Nt(e),!0;if(!_e[n]||Re[n]){if(!Re[n]&&Dt(n)){if(De.tagNameCheck instanceof RegExp&&O(De.tagNameCheck,n))return!1;if(De.tagNameCheck instanceof Function&&De.tagNameCheck(n))return!1}if($e&&!Xe[n]){var o=ae(e)||e.parentNode,a=oe(e)||e.childNodes;if(a&&o)for(var i=a.length-1;i>=0;--i)o.insertBefore(R(a[i],!0),re(e))}return Nt(e),!0}return e instanceof f&&!Tt(e)?(Nt(e),!0):"noscript"!==n&&"noembed"!==n||!O(/<\/no(script|embed)/i,e.innerHTML)?(Fe&&3===e.nodeType&&(t=e.textContent,t=_(t,be," "),t=_(t,ve," "),t=_(t,Te," "),e.textContent!==t&&(A(r.removed,{element:e.cloneNode()}),e.textContent=t)),xt("afterSanitizeElements",e,null),!1):(Nt(e),!0)},Ot=function(e,t,n){if(We&&("id"===t||"name"===t)&&(n in i||n in mt))return!1;if(Me&&!Ce[t]&&O(Ne,t));else if(Le&&O(Ae,t));else if(!ke[t]||Ce[t]){if(!(Dt(e)&&(De.tagNameCheck instanceof RegExp&&O(De.tagNameCheck,e)||De.tagNameCheck instanceof Function&&De.tagNameCheck(e))&&(De.attributeNameCheck instanceof RegExp&&O(De.attributeNameCheck,t)||De.attributeNameCheck instanceof Function&&De.attributeNameCheck(t))||"is"===t&&De.allowCustomizedBuiltInElements&&(De.tagNameCheck instanceof RegExp&&O(De.tagNameCheck,n)||De.tagNameCheck instanceof Function&&De.tagNameCheck(n))))return!1}else if(et[t]);else if(O(Se,_(n,we,"")));else if("src"!==t&&"xlink:href"!==t&&"href"!==t||"script"===e||0!==x(n,"data:")||!Je[e]){if(Ie&&!O(Ee,_(n,we,"")));else if(n)return!1}else;return!0},Dt=function(e){return e.indexOf("-")>0},Rt=function(t){var n,o,a,i;xt("beforeSanitizeAttributes",t,null);var l=t.attributes;if(l){var c={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:ke};for(i=l.length;i--;){var u=n=l[i],s=u.name,f=u.namespaceURI;if(o="value"===s?n.value:k(n.value),a=ge(s),c.attrName=a,c.attrValue=o,c.keepAttr=!0,c.forceKeepAttr=void 0,xt("uponSanitizeAttribute",t,c),o=c.attrValue,!c.forceKeepAttr&&(At(s,t),c.keepAttr))if(Ue||!O(/\/>/i,o)){Fe&&(o=_(o,be," "),o=_(o,ve," "),o=_(o,Te," "));var m=ge(t.nodeName);if(Ot(m,a,o)){if(!qe||"id"!==a&&"name"!==a||(At(s,t),o=Ye+o),le&&"object"===e(b)&&"function"==typeof b.getAttributeType)if(f);else switch(b.getAttributeType(m,a)){case"TrustedHTML":o=le.createHTML(o);break;case"TrustedScriptURL":o=le.createScriptURL(o)}try{f?t.setAttributeNS(f,s,o):t.setAttribute(s,o),N(r.removed)}catch(e){}}}else At(s,t)}xt("afterSanitizeAttributes",t,null)}},Ct=function e(t){var n,r=wt(t);for(xt("beforeSanitizeShadowDOM",t,null);n=r.nextNode();)xt("uponSanitizeShadowNode",n,null),kt(n)||(n.content instanceof l&&e(n.content),Rt(n));xt("afterSanitizeShadowDOM",t,null)};return r.sanitize=function(e){var t,n,a,i,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if((it=!e)&&(e="\x3c!--\x3e"),"string"!=typeof e&&!_t(e)){if("function"!=typeof e.toString)throw D("toString is not a function");if("string"!=typeof(e=e.toString()))throw D("dirty is not a string, aborting")}if(!r.isSupported)return e;if(He||dt(c),r.removed=[],"string"==typeof e&&(Ke=!1),Ke){if(e.nodeName){var u=ge(e.nodeName);if(!_e[u]||Re[u])throw D("root node is forbidden and cannot be sanitized in-place")}}else if(e instanceof s)1===(n=(t=Et("\x3c!----\x3e")).ownerDocument.importNode(e,!0)).nodeType&&"BODY"===n.nodeName||"HTML"===n.nodeName?t=n:t.appendChild(n);else{if(!Pe&&!Fe&&!ze&&-1===e.indexOf("<"))return le&&Ge?le.createHTML(e):e;if(!(t=Et(e)))return Pe?null:Ge?ce:""}t&&je&&Nt(t.firstChild);for(var f=wt(Ke?e:t);a=f.nextNode();)kt(a)||(a.content instanceof l&&Ct(a.content),Rt(a));if(Ke)return e;if(Pe){if(Be)for(i=me.call(t.ownerDocument);t.firstChild;)i.appendChild(t.firstChild);else i=t;return(ke.shadowroot||ke.shadowrootmod)&&(i=de.call(o,i,!0)),i}var m=ze?t.outerHTML:t.innerHTML;return ze&&_e["!doctype"]&&t.ownerDocument&&t.ownerDocument.doctype&&t.ownerDocument.doctype.name&&O(ee,t.ownerDocument.doctype.name)&&(m="<!DOCTYPE "+t.ownerDocument.doctype.name+">\n"+m),Fe&&(m=_(m,be," "),m=_(m,ve," "),m=_(m,Te," ")),le&&Ge?le.createHTML(m):m},r.setConfig=function(e){dt(e),He=!0},r.clearConfig=function(){ft=null,He=!1},r.isValidAttribute=function(e,t,n){ft||dt({});var r=ge(e),o=ge(t);return Ot(r,o,n)},r.addHook=function(e,t){"function"==typeof t&&(he[e]=he[e]||[],A(he[e],t))},r.removeHook=function(e){if(he[e])return N(he[e])},r.removeHooks=function(e){he[e]&&(he[e]=[])},r.removeAllHooks=function(){he={}},r}();return re}));</script>

  </head>
  <body>
    <style>
      :root, :root.light {
        --background: #e8e8e8;
        --button-bg: #c8c8c8;
        --button-bg-hover: #b4b4b4;
        --text-color: black;
        --textarea-bg: #f1f1f1;
        --selected-thread-bg: lightgray;
        --border-color: #c8c8c8;
        --border-radius: 3px;
        --avatar-bg: lightgrey;
        --notification-bg-color: #005ac2;
        --button-border-color: #b4b4b4;
        --button-font-size: 0.825rem;
      }


      /* Detect browser dark mode and change variables */
      @media (prefers-color-scheme: dark) {
        :root {
          --background: #151515;
          --button-bg: #333;
          --button-bg-hover: #444;
          --text-color: white;
          --textarea-bg: #333;
          --selected-thread-bg: #444;
          --border-color: #333;
          --avatar-bg: #333;
          --button-border-color: #515151;
        }
      }

      body, html {
        margin:0;
        background: var(--background);
        color: var(--text-color);
        font-family: sans-serif;
      }
      body * {
        box-sizing:border-box;
        color: inherit;
        font-family: inherit;
      }
      body a {
        color: blue;
      }

      .messageText pre[data-markdown-codeblock] {
        font-family: monospace;
        background: rgb(35 35 35);
        padding: 0.5rem;
        color: rgb(232, 232, 232);
        border-radius: var(--border-radius);
        overflow-x: auto;
      }
      .messageText p code {
        font-family: monospace;
        background: rgb(35 35 35);
        padding: 0.125rem;
        color: rgb(232, 232, 232);
        border-radius: var(--border-radius);
      }
      .messageText table {
        border-collapse: collapse;
      }
      .messageText table, .messageText th, .messageText td {
        border: 1px solid var(--border-color);
      }

      button {
        background: var(--button-bg);
        border-radius: var(--border-radius);
        cursor:pointer;
        padding: 0.125rem;
        border: 1px solid var(--button-border-color);
        font-size: var(--button-font-size);
      }
      button:hover {
        background: var(--button-bg-hover);
      }
      button:disabled {
        cursor: not-allowed;
      }
      textarea {
        background: var(--textarea-bg);
        border: 1px solid var(--button-border-color);
        border-radius: var(--border-radius);
      }

      input[type="text"], select {
        background: var(--textarea-bg);
        border: 1px solid var(--button-border-color);
        border-radius: var(--border-radius);
      }

      #appOptions .appOptionButton {
        width:100%;
        cursor:pointer;
        margin-top:0.5rem;
        min-height: 2rem;
      }
      #chatThreads {
        flex-grow:1;
        overflow-y:auto;
        margin-top:0.5rem;
        -webkit-mask-image: linear-gradient(to bottom, black calc(100% - 30px), #ffffff00 100%);
        mask-image: linear-gradient(to bottom, black calc(100% - 30px), #ffffff00 100%);
        padding-bottom:2rem;
      }
      #chatThreads .thread, #chatThreads .threadFolder {
        border-radius: var(--border-radius);
        display:flex;
        padding:0.5rem;
        cursor:pointer;
        border: 1px solid var(--border-color);
        position: relative;
        user-select:none;
      }
      #chatThreads .thread, #chatThreads .threadFolder {
        margin-top: 0.5rem;
      }
      #chatThreads .thread:first-child, #chatThreads .threadFolder:first-child {
        margin-top: 0;
      }

      #chatThreads .threadFolder {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #chatThreads .thread .favStar, #chatThreads .thread .changeFolderPath {
        position: absolute;
        font-size: 80%;
        opacity: 0.5;
        display: none;
        text-shadow: 0px 1px 2px #515151;
      }
      #chatThreads .thread .favStar {
        top: 0.0625rem;
        left: 0.0625rem;
      }
      #chatThreads .thread .changeFolderPath {
        bottom: 0.0625rem;
        left: 0.0625rem;
      }
      body:not(.isMobile) #chatThreads .thread .favStar:hover {
        opacity: 1;
      }
      #chatThreads .thread .changeFolderPath:hover {
        opacity: 1;
      }
      #chatThreads .thread:hover .favStar, #chatThreads .thread:hover .changeFolderPath {
        display: inline;
      }
      /* can't hover on mobile, so display button on selected thread: */
      body.isMobile #chatThreads .thread.selected .favStar, body.isMobile #chatThreads .thread.selected .changeFolderPath {
        display: inline;
      }
      #chatThreads .thread .favStar[data-is-fav="true"] {
        opacity: 1;
        display: inline;
      }

      #chatThreads .thread:not(:first-child) {
        margin-top: 0.5rem;
      }
      #chatThreads .thread .button {
        opacity:0.5;
      }
      #chatThreads .thread .button:hover {
        opacity:1;
      }
      #chatThreads .thread.selected {
        background-color: var(--selected-thread-bg);
      }
      #chatThreads .thread .info {
        max-width: 100%;
      }
      #chatThreads .thread .nameWrapper {
        overflow: hidden;
        white-space: nowrap;
        max-width: 150px;
        display: flex;
      }
      #chatThreads .thread .name {
        /* truncate long thread names */
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex-grow: 1;
      }
      #chatThreads .thread .avatar, #characterSelection  .character .avatar {
        width:50px;
        height:50px;
        border-radius: var(--border-radius);
        min-width:50px;
        background-position: center;
        background-size: cover;
        background-repeat: no-repeat;
        background-color: var(--avatar-bg);
      }
      #messageFeed .message .avatar {
        width: 50px;
        height: 50px;
        border-radius: var(--border-radius);
        min-width: 50px;
        background-position: center;
        background-size: cover;
        background-repeat: no-repeat;
        background-color: var(--avatar-bg);
      }
      #chatThreads .characterEditButton {
        font-size: 0.65rem;
        opacity: 0.5;
      }
      #chatThreads .characterEditButton:hover {
        opacity: 1;
      }

      /* hide threads scrollbar */
      #chatThreads {
        -ms-overflow-style: none;  /* Internet Explorer 10+ */
        scrollbar-width: none;  /* Firefox */
      }
      #chatThreads::-webkit-scrollbar { 
        display: none;  /* Safari and Chrome */
      }

      /* hide message feed scrollbar */
      /* #messageFeed {
        -ms-overflow-style: none; 
        scrollbar-width: none; 
      }
      #messageFeed::-webkit-scrollbar { 
        display: none;  
      } */

      /* custom scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background-color: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background-color: var(--button-bg);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: content-box;
      }
      ::-webkit-scrollbar-thumb:hover {
        background-color: var(--button-bg-hover);
      }


      #builtInChatInterfaceWrapper {
        display: flex;
        flex-grow: 1;
        flex-direction: column;
        height: 100%;
        position:relative;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      #messageFeed .message {
        margin-top:0.5rem;
        margin-bottom:0.5rem;
      }

      #messageFeed .message .bottomButtons {
        display:none;
        position:absolute;
        bottom: 0.25rem;
        right: 0.5rem;
      }
      #messageFeed .message:hover .bottomButtons {
        display: flex;
      }
      .emojiButton {
        opacity:0.5;
        cursor:pointer;
      }
      .emojiButton:hover {
        opacity:1;
      }

      #messageFeed .message.hiddenFromUser .showHiddenMessageButton {
        display: inline-block;
      }
      #messageFeed .message:not(.hiddenFromUser) .showHiddenMessageButton {
        display: none;
      }
      #messageFeed .message.hiddenFromUser .messageWrap {
        display: none;
      }
      #messageFeed .message:not(.hiddenFromUser) .messageWrap {
        display: flex;
      }
      #messageFeed .messageText p {
        white-space: pre-wrap;
      }
      #messageFeed .messageText {
        margin-top: 0.125rem;
        overflow: hidden; /* keep messageText content from "escaping" the message area */
      }
      #messageFeed .messageText p:first-child {
        margin-top:0;
      }
      #messageFeed .messageText img {
        max-width: 100%;
      }
      #messageFeed .message .avatar {
        
      }

      #messageFeed > *:first-child {
        margin-top: 3rem;
      }

      #characterFoldersList {
        display: grid;
        grid-template-columns: repeat(auto-fill, 280px);
        grid-gap: 0.5rem;
        justify-content: center;
        margin-bottom: 0.5rem;
      }
      #characterFoldersList .characterFolder {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        width: 100%;
        padding:0.5rem;
        cursor:pointer;
        user-select:none;
      }

      #characterSelection .character {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        width: 100%;
      }
      #characterSelection .character .info .buttons {
        margin-top: 0.25rem;
      }
      #characterSelection .character .info .buttons button {
        font-size: 0.7rem;
        margin-left: 0.25rem;
      }
      #characterList, #starterCharacterList {
        display: grid;
        grid-template-columns: repeat(auto-fill, 280px);
        grid-gap: 0.5rem;
        justify-content: center;
      }
      #characterFoldersList .characterFolder {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #characterSelection .character {
        user-select:none;
      }

      #customCodeIframeHorizontalResizeBar {
        width:5px;
        background:var(--button-bg);
        cursor:ew-resize;
      }
      #customCodeIframeHorizontalResizeBar:hover {
        background:var(--button-bg-hover);
      }

      #userMessagesSentHistoryCtn {
        margin-bottom:0.25rem;
        position:relative;
      }
      #userMessagesSentHistoryCtn:empty {
        display: none;
      }
      #userMessagesSentHistoryCtn .historyItem {
        cursor: pointer;
        padding: 0.25rem;
        font-size: 85%;
        overflow: hidden;
        white-space: pre;
        display: flex;
      }
      #userMessagesSentHistoryCtn .historyItem .text {
        text-overflow: ellipsis;
        overflow: hidden;
        margin-left: 0.25rem;
      }
      #userMessagesSentHistoryCtn .historyItem .deleteButton {
        margin-left: auto;
      }
      #userMessagesSentHistoryCtn .historyItem:hover {
        background: var(--background);
      }
      #userMessagesSentHistoryCtn .historyItem .pinButton,
      #userMessagesSentHistoryCtn .historyItem .deleteButton {
        opacity: 0.5;
      }
      #userMessagesSentHistoryCtn .historyItem[data-is-pinned="true"] .pinButton {
        opacity: 1;
      }
      body:not(.isMobile) #userMessagesSentHistoryCtn .historyItem .pinButton:hover,
      body:not(.isMobile) #userMessagesSentHistoryCtn .historyItem .deleteButton:hover {
        opacity: 1;
      }

      #shortcutButtonsCtn {
        margin-bottom:0.25rem;
        position:relative;
        overflow-y: auto;
      }
      #shortcutButtonsCtn:empty {
        display:none;
      }

      #shortcutButtonsCtn button:not(:first-child) {
        margin-left:0.25rem;
      }

      /* typing indicator from https://codepen.io/arthak/pen/rmqvgo */
      .tiblock { align-items: center; display: flex; height: 17px; }
      .ticontainer{ display: inline-block; }
      .ticontainer .tidot { background-color: #90949c;  }
      .tidot { animation: mercuryTypingAnimation 1.5s infinite ease-in-out; border-radius: 2px; display: inline-block; height: 4px; margin-right: 2px; width: 4px; }
      @keyframes mercuryTypingAnimation{ 0%{ -webkit-transform:translateY(0px); transform:translateY(0px); } 28% { transform:translateY(-5px); } 44%{ transform:translateY(0px); } } .tidot:nth-child(1){ animation-delay:200ms; } .tidot:nth-child(2){ animation-delay:300ms; } .tidot:nth-child(3){ animation-delay:400ms; }
    </style>

    <div id="topNotification" style="position:fixed; top:1rem; left:0; right:0; z-index:1000; display:none;">
      <div id="topNotificationContent" style="margin:0 auto; max-width:350px; background:var(--notification-bg-color); color:white; text-align: center; padding: 0.5rem; border-radius: var(--border-radius);"></div>
    </div>

    <div id="main" style="display:flex; position:fixed; top:0; right:0; left:0; bottom:0;">
      <div id="leftColumn" style="display:flex; flex-direction:column; width:270px; min-width:270px; padding:0.5rem; ">
        <div style="display:flex;">
          <button id="newThreadButton" style="width:100%; cursor:pointer; min-height:2rem;">new chat</button>
          <button id="closeLeftColumnButton" style="cursor:pointer;min-height:2rem;margin-left: 0.5rem;min-width: 2rem;">☰</button>
        </div>
        <div id="threadSearchCtn" style="display:flex; width:100%; margin-top:0.5rem;">
          <input id="threadSearchInput" style="height: 100%; flex-grow: 1; min-width: 0; padding-left: 0.5rem;" type="text" placeholder="Search threads...">
          <button id="threadSearchButton" style="cursor:pointer;min-height: 2rem;min-width: 2rem;margin-left: 0.5rem;">🔎</button>
        </div>
        <!-- <div id="threadFolderNavigationBar" style="display:flex; width:100%; margin-top:0.5rem;">
          <button id="threadFolderBackButton" style="cursor:pointer;min-height: 2rem;min-width: 2rem;margin-left: 0.5rem;">🔙</button>
        </div> -->
        <!-- <div id="chatThreadFolders" data-current-folder-path=""></div> -->
        <div id="chatThreads" data-current-folder-path=""></div>
        <div id="appOptions">
          <div style="display:flex;">
            <button id="settingsButton" class="appOptionButton">settings</button>
            <!-- <button id="statsButton" class="appOptionButton" style="margin-left: 0.5rem; width: 2rem;">📊</button> -->
          </div>
          <div style="display: flex;">
            <button id="clearDataButton" class="appOptionButton" style="width: 4rem;">🗑️</button>
            <button id="exportDataButton" class="appOptionButton" style="margin-left: 0.5rem; margin-right: 0.5rem;">export</button>
            <button class="appOptionButton" style="position:relative;">import<input id="importDataFileInput" style="position:absolute; top:0; left:0; right:0; bottom:0; opacity:0; cursor:pointer;" type="file"></button>
          </div>
          <button onclick="window.open('https://github.com/josephrocca/OpenCharacters/blob/main/README.md')" class="appOptionButton">about this project <span style="font-size:0.6rem; opacity:0.5;">001</span></button>
        </div>
      </div>

      <div id="middleColumn" style="flex-grow:1; display:flex; flex-direction:column; position:relative; overflow:hidden; min-width:200px; z-index:1;">
        <div id="middleColumnShadowOverlay" style="display:none; position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5); z-index:20;"></div>
        <div id="characterSelection" class="middleColumnScreen" style="flex-grow:1; display:none; overflow: auto;">
          <button id="characterSelectionOpenLeftColumnButton" class="openLeftColumnButton" style="background: var(--button-bg);border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem;width: 2rem;min-height: 2rem;margin-right: 0.5rem;position: absolute;top: 0.5rem;left: 0.5rem;">☰</button>
          <div>
            <h2 style="text-align:center;margin-bottom: 0.5rem;">Presets</h2>
            <div style="margin-bottom: 0.5rem;display: flex;justify-content: center;">
              <button id="newCharacterButton" style="padding: 0.25rem;">Create preset</button>
              <!-- <button id="newFolderCharacterButton" style="padding: 0.25rem; margin-left: 0.5rem;">📁 new folder</button> -->
            </div>
          </div>
          <div id="characterFoldersList" data-current-folder-path=""></div>
          <div id="characterList"></div>
          <div><h2 style="text-align:center; margin-top:4rem;">Example of presets</h2></div>
          <div id="starterCharacterList"></div>
          <br><br>
        </div>
        <div id="chatInterface" class="middleColumnScreen" style="display:flex; flex-grow:1; flex-direction:column; height:100%; position:relative;">
          <div id="customCodeChatInterfaceWrapper" style="display:none;"></div>
          <div id="builtInChatInterfaceWrapper">
            <div id="messageFeedHeaderBar" style="display: flex; position:absolute;height: 2rem;right: 0;left: 0;margin: 0.5rem; z-index:30;">
              <button id="messageFeedOpenLeftColumnButton" class="openLeftColumnButton" style="display:none; background: var(--button-bg);border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem; min-width: 2rem; height: 100%; margin-right:0.5rem;">☰</button>
              <div style="background: var(--button-bg); display:flex; height: 100%; border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem;">
                <div style="display: flex;align-items: center;font-size:var(--button-font-size);margin-right: 0.25rem;"></div>
                <select id="threadModelSelector" style="max-width:130px;"></select>
              </div>
              <!-- <div id="threadSettingsButton" style="margin-left:0.5rem; cursor:pointer;   background: var(--button-bg); display:flex; height: 100%; border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem;">
                <div style="display: flex;align-items: center;justify-content:center;font-size:var(--button-font-size);min-width:1.5rem;">⚙️</div>
              </div> -->
            </div>
            <div id="chatBackgroundCtn" style="pointer-events:none; position:absolute; top:0; left:0; right:0; bottom:0; z-index:-10;"></div>
            <div id="noMessagesNotice" style="display:none; text-align:center; padding:1rem; margin-top:4rem;">Type a message to begin the chat.</div>
            <div id="messageFeed" style="flex-grow:1; overflow-y:auto;"></div>
            <div id="statusNotifier" style="text-align: center; display: none; height: 0; position: relative; top: -0.4rem; display: flex; align-items: center; justify-content: center;"></div>
            <div id="inputWrapper" style="display:flex; padding:0.5rem; padding-left:0; padding-right:0; flex-direction:column;">
              <!-- <div style="display:flex;margin-bottom: 0.25rem;">
                <button id="editReminderMessageButton" style="font-size:0.7rem;">✏️ reminder msg</button>
              </div> -->
              <div id="userMessagesSentHistoryCtn"></div>
              <div id="shortcutButtonsCtn"></div>
              <div style="display:flex;">
                <textarea id="messageInput" placeholder="Type here..." style="flex-grow:1; min-height:4rem; font-size:100%;" title="commands:&#10;/ai - prompt a reply from ai&#10;/ai &lt;instruction&gt; - prompt reply with instruction&#10;/ai @CharName#123 &lt;instruction&gt; - prompt reply with another character (ID=123)&#10;/user &lt;instruction&gt; - generate a user reply&#10;/sys &lt;message&gt; - reply as system&#10;/sum - open summary editor&#10;/mem - open memory editor&#10;/lore - open lore editor&#10;/lore &lt;text&gt; - add a lore entry&#10;/name &lt;name&gt; - set your name for this thread&#10;/avatar &lt;url&gt; - set your avatar image for this thread&#10;/import - add chat messages in bulk&#10;&#10;• You can add '/ai &lt;instruction&gt;' as the final line in your normal messages to instruct AI for its reply.&#10;• Double-click this text box to show input history"></textarea>
                <div style="display:flex; flex-direction:column; margin-left:0.25rem;">
                  <button id="sendButton" style="min-width:80px; flex-grow:1;">send</button>
                  <div style="position:relative;">
                    <div id="threadOptionsPopup" style="position:absolute; display:none; padding:0.5rem; background:var(--background); border-radius:var(--border-radius); width:max-content; right:0; bottom:0; border:1px solid var(--border-color);">
                      <button id="addShortcutButton">✨ add shortcut</button>
                      <!-- <button id="replyLoopButton">➰ reply loop</button> -->
                    </div>
                  </div>
                  <button id="threadOptionsButton" style="min-width:80px; margin-top:0.25rem;">options</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="rightColumn" style="width:min-content;" data-visible="no">
        <div id="customCodeColumn" style="width:min-content; display:none; height:100%;">
          <div id="customCodeIframeHorizontalResizeBar"></div>
          <div id="customCodeIframeCtn" style="height:100%; flex-grow:1;"></div>
        </div>
      </div>
    </div>

    <button id="toggleRightColumnButton" style="position:fixed; top:0.5rem; right:0.5rem; min-height:2rem; min-width:2rem; display:none; align-items:center; justify-content:center; z-index:500;">⚛️</button>

    <audio id="musicPlayer" style="display:none;"></audio>

    <script type="module">
      import { $, $$, delay, showEl, hideEl, prompt2, createFloatingWindow, sanitizeHtml, textToSpeech, sha256Text, dedent, downloadTextOrBlob, createGpt3Tokenizer, cosineDistance, createLoadingModal, applyObjectOverrides, objectKeysAndTypesAreValid, addBackgroundToElement, importStylesheet, htmlToElement, jsonToBlob } from "./utils.js?v=34";

      let JSON5;
      (async function() {
        JSON5 = await import('https://cdn.jsdelivr.net/npm/json5@2.2.2/dist/index.min.mjs').then(m => m.default);
      })();

      // TODO: allow <style> when you work out how to scope it to the current message only - maybe just use a CSS parser and add .messageText prefix to selectors - https://github.com/jotform/css.js
      // TODO: allow sandboxed iframes in messages? so devs can add dynamic/interactive message content? I think they may even be able to communicate with their custom code iframe?!
      let domPurifyOptions = {
        FORBID_TAGS: ['style'],
        ADD_ATTR: ['onclick'], // WARNING: I'm using a hook (below) to make this safe. Be careful when editing this stuff.
      };
      DOMPurify.addHook('uponSanitizeAttribute', function (node, data) {
        if(data.attrName === "onclick") {
          node.dataset.onClickCode = data.attrValue;
          data.attrValue = "window.runCodeInCustomCodeIframe(this.dataset.onClickCode)";
        }
      });

      const markedRenderer = new marked.Renderer();
      markedRenderer.code = (source, lang) => {
        const escapedSource = sanitizeHtml(source);
        if(lang) {
          return `<pre data-markdown-codeblock="${sanitizeHtml(lang)}">${escapedSource}</pre>`;
        } else {
          return `<pre data-markdown-codeblock>${escapedSource}</pre>`;
        }
      };
      marked.setOptions({
        renderer: markedRenderer,
      });

      window.onerror = function(errorMsg, url, lineNumber, columnNumber, errorObj) {
        alert(`Please report this error on the Discord or Github:\n\n${errorMsg}\n\nstack: ${errorObj?.stack}\n\nline: ${lineNumber}`);
        if(errorObj?.stack.toLowerCase().includes("databaseclosederror")) {

        }
        return false;
      }

      if(!window.isSecureContext) {
        alert("Hey, looks like you're trying to host this locally, but you have hosted it in an insecure context - i.e. you're serving it on HTTP instead of HTTPS. Unfortunately there are a bunch of features that are disabled on HTTP connections for modern browsers. localhost is treated as a secure context for development purposes, but if you want to server it on the internet, then I recommend using Cloudflare - you just switch your domain's nameservers to them and then it's basically a button click and you've got HTTPS. Much easier than setting up your own certificate stuff.");
      }

      $.messageFeed.addEventListener("keydown", async function(e) {
        debugger;
      });

      // polyfill for navigator.userActivation
      if(!navigator.userActivation) {
        navigator.userActivation = {hasBeenActive:false};
        let pageActivationClickHandler = (e) => {
          if(e.isTrusted) {
            navigator.userActivation.hasBeenActive = true;
            window.removeEventListener("click", pageActivationClickHandler);
          }
        }
        window.addEventListener("click", pageActivationClickHandler);
      }

      const sceneBackground = addBackgroundToElement($.chatBackgroundCtn);

      // dragula([$.messageFeed], {
      //   moves: function (el, source, handle, sibling) {
      //     return el.classList.contains("message") && handle.classList.contains("avatar");
      //   },
      //   revertOnSpill: true,
      // });

      prompt2.defaults = {
        backgroundColor: "var(--background)",
        borderColor: "var(--border-color)",
      };
      createFloatingWindow.defaults = {
        backgroundColor: "var(--background)",
        borderColor: "var(--border-color)",
      };

      let summariesWindow = createFloatingWindow({header:"Logs"});
      summariesWindow.hide();
      function addToDebugLog(html) {
        let ctn = document.createElement("div");
        ctn.innerHTML = html;
        ctn.style.cssText = "font-size:0.8rem; padding:0.5rem; solid var(--border-color); font-family:monospace;";
        let initialScrollTop = summariesWindow.bodyEl.scrollTop;
        summariesWindow.bodyEl.appendChild(ctn);

        setTimeout(function() {
          // wait for render and then scroll to bottom if it was near bottom previously
          if(Math.abs(initialScrollTop - summariesWindow.bodyEl.scrollTop) < 10) {
            summariesWindow.bodyEl.scrollTop = summariesWindow.bodyEl.scrollHeight;
          }
        }, 10);
        
        // delete earlier children if there are too many
        while(summariesWindow.bodyEl.children.length > 50) {
          summariesWindow.bodyEl.removeChild(summariesWindow.bodyEl.children[0]);
        }
      }

      // TODO: improve this heuristic. this isn't just about screen width - it's also about touch screens (no pointer hover events).
      // ALSO: This is a bit of a misnomer. It's used for stuff like determining how to show the right column, which is really about screen width, not mobile/touchscreen stuff.
      const isMobile = window.innerWidth < 700;

      if(isMobile) {
        document.body.classList.add("isMobile"); // to use in CSS selectors
      }
      
      function openLeftColumn() {
        showEl($.leftColumn);
        document.querySelectorAll(".openLeftColumnButton").forEach(el => hideEl(el));
        showEl($.closeLeftColumnButton);
        if(isMobile) {
          showEl($.middleColumnShadowOverlay);
        }
      }
      function closeLeftColumn() {
        hideEl($.leftColumn);
        document.querySelectorAll(".openLeftColumnButton").forEach(el => showEl(el));
        hideEl($.closeLeftColumnButton);
        if(isMobile) {
          hideEl($.middleColumnShadowOverlay);
        }
      }
      $.closeLeftColumnButton.addEventListener("click", closeLeftColumn);
      document.querySelectorAll(".openLeftColumnButton").forEach(el => {
        el.addEventListener("click", (e) => {
          e.stopPropagation(); // <-- since this hovers over middle column, and on mobile we close left column when they tap middle column
          openLeftColumn();
        });
      });
      if(isMobile) {
        closeLeftColumn();
        // if they click anywhere in the middle column, close the menu
        $.middleColumnShadowOverlay.addEventListener("click", (e) => {
          e.stopPropagation();
          closeLeftColumn();
        });
      }


      {
        let messageFeedHeaderBarHideTimeout = null;
        let isMouseInTriggerArea = false;
        function showMessageFeedTopMenu() {
          clearTimeout(messageFeedHeaderBarHideTimeout);
          messageFeedHeaderBarHideTimeout = null;
          showEl($.messageFeedHeaderBar);
        }
        function hideMessageFeedTopMenu() {
          if(messageFeedHeaderBarHideTimeout !== null) return; // hiding settimeout already in progress
          clearTimeout(messageFeedHeaderBarHideTimeout);
          messageFeedHeaderBarHideTimeout = setTimeout(() => {
            hideEl($.messageFeedHeaderBar);
          }, 2000);
        }
        window.addEventListener("mousemove", (e) => {
          if (e.pageY < 80) { // show:
            isMouseInTriggerArea = true;
            showMessageFeedTopMenu();
          } else { // hide if visible:
            isMouseInTriggerArea = false;
            if ($.messageFeedHeaderBar.offsetHeight > 0 && !lastMessageFeedScrollWasUp) {
              hideMessageFeedTopMenu();
            }
          }
        });
        let messageFeedScrollTop = 0;
        let lastMessageFeedScrollWasUp = true;
        $.messageFeed.addEventListener("scroll", function (e) {
          let newScrollTop = e.target.scrollTop;
          if (newScrollTop < messageFeedScrollTop) { // they scrolled up, so show menu
            lastMessageFeedScrollWasUp = true;
            showMessageFeedTopMenu();
          }
          if (newScrollTop > messageFeedScrollTop) { // they scrolled down, so hide menu if their mouse isn't in trigger area
            lastMessageFeedScrollWasUp = false;
            if(!isMouseInTriggerArea || isMobile) {
              hideMessageFeedTopMenu();
            }
          }
          messageFeedScrollTop = newScrollTop;
        }, { passive: true });
      }

      if(isMobile) {
        $.customCodeIframeHorizontalResizeBar.style.display = "none";
        $.customCodeColumn.style.width = "100%";

        $.rightColumn.style.position = "fixed";
        $.rightColumn.style.top = "0";
        $.rightColumn.style.right = "0";
        $.rightColumn.style.bottom = "0";
        $.rightColumn.style.left = "0";
        $.rightColumn.style.zIndex = "100";
        $.rightColumn.style.width = "";

        $.rightColumn.style.pointerEvents = "none";
        $.rightColumn.style.opacity = "0";

        $.toggleRightColumnButton.addEventListener("click", function() {
          if($.rightColumn.dataset.visible === "yes") {
            $.rightColumn.style.pointerEvents = "none";
            $.rightColumn.style.opacity = "0";
            $.rightColumn.dataset.visible = "no";
            $.toggleRightColumnButton.textContent = "⚛️";
          } else {
            $.rightColumn.style.pointerEvents = "";
            $.rightColumn.style.opacity = "1";
            $.rightColumn.dataset.visible = "yes";
            $.toggleRightColumnButton.textContent = "💬";
          }
        });
      }


      const dbName = "chatbot-ui-v1";
      const dbVersion = 90;

      let db = await new Dexie(dbName).open().catch(e => {
        console.warn(e);
        return false;
      }); // throws if db doesn't exist
      let dbLoadingModal;
      if(db) {
        console.log("Existing user, checking database version...");
        let usersOriginalDbVersion = db.verno;
        if(usersOriginalDbVersion < dbVersion) {
          let result = await prompt2({
            message: {type:"none", "html":`<p style="margin:0;">A database upgrade will be done when you click continue. A full export/backup will be downloaded first in case anything goes wrong.</p>`},
          }, {cancelButtonText:null, submitButtonText:"Continue"});
          
          dbLoadingModal = createLoadingModal(`Please wait...<br><span style="font-size:80%; opacity:0.6;">This could take a while if you have a lot of data.</span>`);

          const originalDbJsonBlob = await db.export({prettyJson: true});
          let yyyymmdd = new Date().toISOString().split("T")[0];
          downloadTextOrBlob(originalDbJsonBlob, `opencharacters-export-${yyyymmdd}.json`);
        }
        await db.close(); // we need to close before db.version() call below and re-open afterwards
      } else {
        // brand new user, so create the db:
        console.log("New user, creating database...");
        db = new Dexie(dbName);
      }
      
      db.version(dbVersion).stores({
        // REMEMBER: If you update the database schema, you may also need to update the export/import code
        // in particular: the character hash code shouldn't include fields like `id` and `creationTime` and `lastMessageTime`.
        
        // Things to check:
        // - character hash computation
        // - $.exportDataButton.addEventListener
        // - import code

        // NOTE: The properties listed here are just the INDEXES, not *all* the columns/properties.
        characters: "++id,modelName,fitMessagesInContextMethod,uuid,creationTime,lastMessageTime",
        threads: "++id,name,characterId,creationTime,lastMessageTime,lastViewTime",
        messages: "++id,threadId,characterId,creationTime,order", // characterId is -1 for user, and for system it is -2.
        misc: "key", // key=>value
        summaries: "hash,threadId", // EDIT: This does not make sense, because the `hash` is used as the primary key, so in the case where two threads end up with the same summary hash (which is actually common because you can import a thread which you already have), then you can only have one entry for both threads. So for summary deletion you actually need to (OLD: we track threadId so when we delete threads, we can delete the associated summaries. we also need it for grabbing summaries for the edit interface.)
        memories: "++id,[summaryHash+threadId],[characterId+status],[threadId+status],[threadId+index],threadId", // memories are associated with a summary hash because they are computed alongside the summary. We need to track the hash so that if earlier messages are edited (and therefore the summaries need to be recomputed), we know to only consider "valid"/"current" the memories that are associated with currently-"used". The "type" property is used to track the "currentness", and also to track whether a memory was manually added by the user (in which case it is *always* considered valid)
        lore: "++id,bookId,bookUrl",
        textEmbeddingCache: "++id,textHash,&[textHash+modelName]",
        textCompressionCache: "++id,uncompressedTextHash,&[uncompressedTextHash+modelName+tokenLimit]",
        usageStats: "[dateHour+threadId+modelName],threadId,characterId,dateHour", // note that characterId can be derived from threadId - it's just included for quick aggregation. modelName is like "gpt-3.5-turbo", dateHour is like "2023-3-29-14"
      }).upgrade(async tx => {

        await tx.table("characters").toCollection().modify(character => {
          upgradeCharacterFromOldVersion(character);
        });
        
        await tx.table("messages").toCollection().modify(message => {
          upgradeMessageFromOldVersion(message);
        });

        let characters = await tx.table("characters").toArray();
        await tx.table("threads").toCollection().modify(async thread => {
          await upgradeThreadFromOldVersion(thread, {characters});
        });        

        if(db.apiUsage) await db.apiUsage.delete();

        await tx.table("usageStats").toCollection().modify((entry, ref) => {
          if(entry.threadId === undefined) delete ref.value; // delete rows/entries that don't have a threadId - this was caused by some sort of bug in early implementation
        });

        await tx.table("summaries").toCollection().modify((entry, ref) => {
          if(entry.messageIds === undefined) delete ref.value; // old summaries didn't have messageIds or prevSummaryHash
        });


        let memories = await tx.table("memories").toArray();
        let userWrittenMemories = memories.filter(m => m.type === "user-written");
        if(userWrittenMemories.length > 0) {
          let loreEntries = [];
          for(let m of userWrittenMemories) {
            loreEntries.push({ bookId:m.threadId, text:m.text, embedding:m.embedding, triggers:[] });
          }
          await tx.table("lore").bulkAdd(loreEntries);
          await tx.table("memories").toCollection().modify((entry, ref) => {
            if(entry.type === "user-written") delete ref.value;
          });
          memories = memories.filter(m => m.type !== "user-written");
        }
        let memoryIdToIndexMap = createMemoryIdToIndexMapForIncorrectlyIndexedOrUnindexedMemories(memories);
        await tx.table("memories").toCollection().modify(memory => {
          let opts = {};
          if(memoryIdToIndexMap[memory.id] !== undefined) opts.index = memoryIdToIndexMap[memory.id];
          upgradeMemoryFromOldVersion(memory, opts);
        });

        await tx.table("lore").toCollection().modify(entry => {
          upgradeLoreFromOldVersion(entry);
        });
        

      });

      await db.open();

      if(dbLoadingModal) dbLoadingModal.delete();

      console.log("Database ready.");

      function upgradeCharacterInitialMessagesArrayIfNeeded(character) {
        // upgrade from the ["foo", "bar"] format to [{author:"user", content:"foo"}, {author:"ai", content:"bar"}]
        if(character.initialMessages && character.initialMessages.length === 1 && character.initialMessages[0] === "") {
          // bugfix:
          character.initialMessages = [];
        } else if(character.initialMessages && character.initialMessages.length > 0 && character.initialMessages[0] === "" && typeof character.initialMessages[1] === "object") {
          // bugfix:
          character.initialMessages = character.initialMessages.slice(1);
        } else if(character.initialMessages && character.initialMessages.length > 0 && typeof character.initialMessages[0] === "string") {
          // actual upgrade:
          let author = "user";
          for(let i = 0; i < character.initialMessages.length; i++) {   
            let content = character.initialMessages[i];
            if(content === "") { // if first message is empty, this indicates that character maker wanted AI to speak first
              author = (author === "user" ? "ai" : "user");
              continue;
            }
            character.initialMessages[i] = {
              author,
              content,
            };
            author = (author === "user" ? "ai" : "user");
          }
          if(character.initialMessages[0] === "") character.initialMessages = character.initialMessages.slice(1);
        }
      }

      function upgradeCharacterFromOldVersion(character) {
        upgradeCharacterInitialMessagesArrayIfNeeded(character);
        if(character.customCode === undefined) character.customCode = "";
        if(character.modelVersion) {
          character.modelName = character.modelVersion;
          delete character.modelVersion;
        }
        if(character.textEmbeddingModelName === undefined) {
          character.textEmbeddingModelName = character.associativeMemoryEmbeddingModelName ?? "text-embedding-ada-002";
          delete character.associativeMemoryEmbeddingModelName;
        }
        if(character.userCharacter === undefined) character.userCharacter = {};
        if(character.avatar === undefined) character.avatar = {url:character.avatarUrl, size:1, shape:"square"};
        if(character.hasOwnProperty("avatarUrl")) delete character.avatarUrl;
        if(character.scene === undefined) character.scene = {background:{}, music:{}};
        if(character.streamingResponse === undefined) character.streamingResponse = true;
        if(character.roleInstruction === undefined) {
          character.roleInstruction = character.systemMessage;
          delete character.systemMessage;
        }
        if(character.folderPath === undefined) character.folderPath = "";
        if(character.uuid === undefined) character.uuid = null;
        if(character.customData === undefined) character.customData = {};
        if(character.systemCharacter === undefined) character.systemCharacter = {avatar:{}};
        if(character.loreBookUrls === undefined) character.loreBookUrls = [];
        if(character.associativeMemoryMethod !== undefined) {
          character.autoGenerateMemories = character.associativeMemoryMethod;
          delete character.associativeMemoryMethod;
        }
        if(character.autoGenerateMemories === undefined) {
          character.autoGenerateMemories = "none"; // we need this because very old characters could have had not had a associativeMemoryMethod property at all (it didn't exist in the original schema)
        }
        if(character.maxTokensPerMessage === undefined) character.maxTokensPerMessage = null;
        
        // WARNING: If you add something here, you'll likely have to edit:
        //  - characterDetailsPrompt (characterDetailsPrompt should return a valid character object - addCharacter only adds creationTime and lastMessageTime, so characterDetailsPrompt should fill in everything else, even if it's not visible in the editor)
        //  - getUserCharacterObj
        //  - getSystemCharacterObj
        //  - characterPropertiesVisibleToCustomCode
        //  - addThread - for things like `character.scene` where it's copied over to the thread at the start, and custom code can only edit it from there
        //  - the "share link" creation code (if you add any other private/user-specific data like id, lastMessageTime, etc.)
        return character;
      }

      function upgradeMessageFromOldVersion(message) {
        if(!message.variants) message.variants = [null]; // null is the placeholder for the currently-chosen variant (stored in `message.message`)
        if(!message.hasOwnProperty("expectsReply")) message.expectsReply = undefined;
        if(!message.hasOwnProperty("summaryHashUsed")) message.summaryHashUsed = undefined; // undefined means that we don't know whether a summary was used because the message was created before this 'summaryUsed' feature was added
        if(message.memoryIdBatchesUsed === undefined) message.memoryIdBatchesUsed = [];
        if(message.loreIdsUsed === undefined) message.loreIdsUsed = [];
        if(message.scene === undefined) message.scene = null;
        if(message.avatar === undefined) message.avatar = {};
        if(message.customData === undefined) message.customData = {};
        if(message.wrapperStyle === undefined) message.wrapperStyle = "";
        if(message.memoryQueriesUsed === undefined) message.memoryQueriesUsed = [];
        if(message.messageIdsUsed === undefined) message.messageIdsUsed = [];
        if(message.order === undefined) message.order = message.id; // <-- this is a little hacky, but it works because id is auto-incremented, and `order` values don't need to be contiguous
        if(message.instruction === undefined) message.instruction = null;
        // WARNING: If you add something here, you may need to edit
        // - createMessageObj
        // - messagesToCustomCodeFormat and messagesFromCustomCodeFormat (if the data should be readable/writable from custom code)
        return message;
      }

      async function upgradeThreadFromOldVersion(thread, opts={}) {
        if(thread.isFav === undefined) thread.isFav = false;
        if(thread.userCharacter === undefined) thread.userCharacter = {avatar:{}}; // this overrides the default user character object (for this specific thread)
        if(thread.lastViewTime === undefined) thread.lastViewTime = thread.lastMessageTime;
        if(thread.customCodeWindow === undefined) thread.customCodeWindow = {visible:false, width:null}; 
        if(thread.customData === undefined) thread.customData = {}; 
        if(thread.modelName === undefined) {
          let character;
          if(opts.characters) {// need this specifically for the db upgrade() function (i.e. not needed in import code) since modify can't be `async`, so we get all characters beforehand and pass them to this function
            // oh and I now use this in the import code too because we need to pass in the *new* characters as well, since new threads can obviously reference them.
            character = opts.characters.find(c => c.id === thread.characterId);
          } else {
            character = await db.characters.get(thread.characterId);
          }
          thread.modelName = character.modelName; // don't need to do good/great conversion here because that was not a feature previous to this change
        }
        if(thread.textEmbeddingModelName === undefined) {
          let character;
          if(opts.characters) character = opts.characters.find(c => c.id === thread.characterId);
          else character = await db.characters.get(thread.characterId);
          thread.textEmbeddingModelName = character.textEmbeddingModelName;
        }
        if(thread.folderPath === undefined) thread.folderPath = ""; 
        if(thread.character === undefined) thread.character = {avatar:{}}; 
        if(thread.systemCharacter === undefined) thread.systemCharacter = {avatar:{}}; // this overrides the default user character object (for this specific thread)
        if(thread.loreBookId === undefined) thread.loreBookId = thread.id; // user-written memories for each thread are now lore entries, and for simplicity I've made the lorebook id equal to the thread id the the existing lore entries (thread and lorebook ids are not actually coupled though)
        if(thread.messageWrapperStyle === undefined) thread.messageWrapperStyle = "";
        if(thread.userMessagesSentHistory === undefined) thread.userMessagesSentHistory = [];
        if(thread.unsentMessageText === undefined) thread.unsentMessageText = "";
        if(thread.shortcutButtons === undefined) thread.shortcutButtons = [];
        for(let shortcut of thread.shortcutButtons) {
          if(shortcut.insertionType === undefined) shortcut.insertionType = "replace";
        }
        if(thread.currentSummaryHashChain === undefined) thread.currentSummaryHashChain = null; // NOTE: currentSummaryHashChain isn't added here since we need the thread to be fully loaded before we can calculate it (including the custom code iframe), so we have a function to access this thread property which will calculate it if it's not already calculated

        // WARNING: If you add something here, you may need to edit:
        // - addThread
        // - getThreadJSONById
        // and if exposing to custom code:
        // - window.oc.thread.<...>  (during declaration of window.oc object, with Object.seal if property is an object)
        // - getDataForCustomCode  (sending data to custom code)
        // - updateDbWithNewDataFromCustomCode (receiving data from custom code)
        return thread;
      }

      function upgradeMemoryFromOldVersion(memory, opts={}) {
        if(memory.type === "user-written") return; // these will be moved to the lore table and deleted from the memories table

        if(opts.index !== undefined) {
          delete memory.nextMemoryId;
          delete memory.previousMemoryId;
          memory.index = opts.index;
        }
        delete memory.type; // no longer need type="generated" because it's the only type (and also a better name would be "chronological" because user's can edit them and add their own)

        if(Array.isArray(memory.embedding)) {
          memory.embeddings = {"text-embedding-ada-002":memory.embedding};
          delete memory.embedding;
          if(memory.$types) {
            // needed for manual upgrading of dexie json import (still don't know why we need to manually upgrade stuff though - should be able to import old json and it upgrades automatically)
            memory.$types["embeddings.text-embedding-ada-002"] = memory.$types.embedding;
            delete memory.$types.embedding;
          }
        }
      }

      function upgradeLoreFromOldVersion(entry) {
        if(entry.bookUrl === undefined) entry.bookUrl = null;
        if(Array.isArray(entry.embedding)) {
          entry.embeddings = {"text-embedding-ada-002":entry.embedding};
          delete entry.embedding;
          if(entry.$types) {
            // needed for manual upgrading of dexie json import (still don't know why we need to manually upgrade stuff though - should be able to import old json and it upgrades automatically)
            entry.$types["embeddings.text-embedding-ada-002"] = entry.$types.embedding;
            delete entry.$types.embedding;
          }
        }
      }


      // function createMemoryIdToIndexMapFromAllMemories(memories) {
      //   // each memory has `nextMemoryId` and `previousMemoryId`, but we need to convert to `index` format.
      //   // we need to create a map of memory.id -> index
      //   // but first we need to group all memories by their threadId
      //   let memoriesByThreadId = {};
      //   for(let memory of memories) {
      //     if(memory.type === "user-written") continue; // <-- these don't have an order/index, and are being moved to the lore table
      //     if(!memoriesByThreadId[memory.threadId]) memoriesByThreadId[memory.threadId] = [];
      //     memoriesByThreadId[memory.threadId].push(memory);
      //   }
      //   // now for each thread's memories we follow the `previousMemoryId`/`nextMemoryId` chain to sort them
      //   // the first memory in the chain will have previousMemoryId==-1, so we get that first, and then crawl through:
      //   let memoryIdToIndexMap = {};
      //   for(let threadId of Object.keys(memoriesByThreadId)) {
      //     let threadMemories = memoriesByThreadId[threadId];
      //     threadMemories.sort((a,b) => a.id - b.id);
      //     for(let i = 0; i < threadMemories.length; i++) {
      //       memoryIdToIndexMap[threadMemories[i].id] = i;
      //     }
          
      //     // this was buggy for some reason:
      //     // let index = 0;
      //     // while(memory) {
      //     //   memoryIdToIndexMap[memory.id] = index;
      //     //   index++;
      //     //   memory = threadMemories.find(m => m.previousMemoryId === memory.id);
      //     // }
      //   }
      //   return memoryIdToIndexMap;
      // }

      function createMemoryIdToIndexMapForIncorrectlyIndexedOrUnindexedMemories(memories) {
        let memoriesByThreadId = {};
        for(let m of memories) {
          if(!memoriesByThreadId[m.threadId]) memoriesByThreadId[m.threadId] = [];
          memoriesByThreadId[m.threadId].push(m);
        }
        // for each thread, check that memory indices (m.index) exist for each memory and are unique:
        let threadIdsThatNeedToBeIndexed = [];
        for(let threadId of Object.keys(memoriesByThreadId)) {
          let memories = memoriesByThreadId[threadId];
          let indices = memories.map(m => m.index);
          if(indices.includes(undefined) || indices.length !== new Set(indices).size) {
            threadIdsThatNeedToBeIndexed.push(threadId);
          }
        }
        let memoryIdToIndexMap = {};
        if(threadIdsThatNeedToBeIndexed.length > 0) {
          for(let threadId of threadIdsThatNeedToBeIndexed) {
            let memories = memoriesByThreadId[threadId];
            memories.sort((a,b) => a.id - b.id);
            for(let i = 0; i < memories.length; i++) {
              let m = memories[i];
              m.index = i;
              memoryIdToIndexMap[m.id] = i;
            }
          }
        }
        return memoryIdToIndexMap;
      }
      

      window.db = db;


      let availableModels = {};

      // for openai and webgpu/webnn models (i.e. you don't need to setup your own inference server, and most people already have an openai account):
      let broadlyAvailableModels = [
        {name:"gpt-3.5-turbo", shortLabel:"gpt-3.5-turbo - good/fast/cheap", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:4096, type:"chat-completion", tokenPricing:{prompt: 0.001, completion: 0.002}},
        {name:"gpt-3.5-turbo-16k", shortLabel:"gpt-3.5-turbo-16k - 4x longer memory", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:16384, type:"chat-completion", tokenPricing:{prompt: 0.001, completion: 0.002}},
        {name:"gpt-3.5-turbo-instruct", shortLabel:"gpt-3.5-turbo-instruct - good/fast/cheap", endpointUrl:"https://api.openai.com/v1/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:4096, type:"completion", tokenPricing:{prompt: 0.0015, completion: 0.002}},
        // {name:"gpt-3.5-turbo-instruct", shortLabel:"gpt-3.5-turbo-instruct - more controllable", endpointUrl:"https://api.openai.com/v1/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:4096, type:"completion", tokenPricing:{prompt: 0.0015, completion: 0.002}},
        {name:"gpt-4", shortLabel:"gpt-4 - excellent, 2x longer memory, expensive", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:8192, type:"chat-completion", tokenPricing:{prompt: 0.03, completion: 0.06}},
        {name:"text-davinci-003", shortLabel:"text-davinci-003 - creative/expensive, DEPRECATED Jan 2024", endpointUrl:"https://api.openai.com/v1/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:4096, type:"completion", tokenPricing:{prompt: 0.02, completion: 0.02}},
        {name:"gpt-3.5-turbo-0301", shortLabel:"gpt-3.5-turbo-0301, old/DEPRECATED June 2024", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:4096, type:"chat-completion", tokenPricing:{prompt: 0.0015, completion: 0.002}},
        {name:"gpt-4-0314", shortLabel:"gpt-4-0314, old/DEPRECATED June 2024", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:8192, type:"chat-completion", tokenPricing:{prompt: 0.03, completion: 0.06}},
        {name:"text-embedding-ada-002", shortLabel:"text-embedding-ada-002", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:8192, type:"text-embedding", tokenPricing:{prompt:0.0004, completion: 0.0004}},
      ];

      if(Date.now() > new Date("2024-01-04").getTime()) {
        broadlyAvailableModels = broadlyAvailableModels.filter(m => m.name !== "text-davinci-003");
      }
      
      async function updateModelList() {
        // console.log("updateModelList");
        let modelsArr = broadlyAvailableModels.slice(0);
        let customModelConfigs = (await db.misc.get("customModelConfigs"))?.value || [];
        // console.log("updateModelList", customModelConfigs);
        modelsArr.push(...customModelConfigs);
        availableModels = {};
        for(let m of modelsArr) {
          availableModels[m.name] = m;
        }
        // console.log("updateModelList", availableModels);
        let currentValue = $.threadModelSelector;
        $.threadModelSelector.innerHTML = modelsArr.filter(m => m.type === "completion" || m.type === "chat-completion").map(m => `<option value="${m.name}" ${m.name === currentValue ? "selected" : ""}>${m.name}</option>`).join("");
      }
      updateModelList();


      // export data if they click export button
      $.exportDataButton.addEventListener("click", async function() {
        // choose export options
        let result = await prompt2({
          exportUserData: {label: "Export user settings? (API key, avatar, name)", type: "select", options:[{value: "yes", content: "Yes"}, {value: "no", content: "No"}]},
          exportType: {label: "Export type", type: "select", options:[{content: "All characters and chats", value:"allCharactersAndThreads"}, {content: "All characters, no chats", value:"allCharactersNoThreads"}, {content: "Specific characters", value:"specificCharacters"}, {content: "Specific chats", value:"specificThreads"}]},
          exportThreadIds: {show:(data) => data.exportType==="specificThreads", label: "Chat IDs to export (comma-separated numbers). Chat IDs are shown in bottom-right of each chat card in the side bar. The characters associated with these chats will be exported too.", type: "textLine", defaultValue: "", placeholder:"23,45,67"},
          exportCharacterIds: {show:(data) => data.exportType==="specificCharacters", label: "Character IDs to export (comma-separated numbers). Character IDs are shown next to the character name.", type: "textLine", defaultValue: "", placeholder:"3,12,7,14"},
          includeThreadsOfCharacters: {show:(data) => data.exportType==="specificCharacters", label: "Include all chats with these characters?", type: "select", options:[{value: "yes", content: "Yes"}, {value: "no", content: "No"}], defaultValue: "no"},
        });
        if(!result) return;

        let loadingModal = createLoadingModal(`Please wait...<br><span style="font-size:80%; opacity:0.6;">This could take a while if you have a lot of data.</span>`);

        const blob = await db.export({prettyJson:true, numRowsPerChunk:100});
        const json = await new Response(blob).json(); // use Response hack instead of JSON.parse(await blob.text()) to avoid maximum string length errors

        let keepThreadCheck;
        let keepCharacterCheck;
        let keepLoreBookCheck;
        let keepLoreBookUrlCheck;
        if(result.exportType === "allCharactersAndThreads") {
          keepThreadCheck = (id) => true;
          keepLoreBookCheck = (id) => true;
          keepLoreBookUrlCheck = (url) => true;
          keepCharacterCheck = (id) => true;
        } else if (result.exportType === "allCharactersNoThreads") {
          keepThreadCheck = (id) => false;
          keepLoreBookCheck = (id) => false;
          keepLoreBookUrlCheck = (url) => false;
          keepCharacterCheck = (id) => true;
        } else if (result.exportType === "specificCharacters") {
          if(!result.exportCharacterIds.trim()) return alert("You must specify at least one character ID to export.")
          
          const keepCharacterIds = result.exportCharacterIds.split(",").map(s => parseInt(s)).filter(id => !isNaN(id));
          keepCharacterCheck = (id) => keepCharacterIds.includes(id);

          if(result.includeThreadsOfCharacters === "yes") {
            const keepCharacters = await db.characters.where("id").anyOf(keepCharacterIds).toArray();
            const keepThreads = await db.threads.where("characterId").anyOf(keepCharacterIds).toArray();
            const keepThreadIds = keepThreads.map(t => t.id);
            const keepLoreBookIds = keepThreads.map(t => t.loreBookId);
            const keepLoreBookUrls = keepCharacters.map(c => c.loreBookUrls).flat();
            keepThreadCheck = (id) => keepThreadIds.includes(id);
            keepLoreBookCheck = (id) => keepLoreBookIds.includes(id);
            keepLoreBookUrlCheck = (url) => keepLoreBookUrls.includes(url);
          } else {
            keepThreadCheck = (id) => false;
            keepLoreBookCheck = (id) => false;
            keepLoreBookUrlCheck = (url) => false;
          }
        } else if (result.exportType === "specificThreads") {
          if(!result.exportThreadIds.trim()) return alert("You must specify at least one thread ID to export.")
          const keepThreadIds = result.exportThreadIds.split(",").map(s => parseInt(s)).filter(id => !isNaN(id));
          const keepThreads = await db.threads.where("id").anyOf(keepThreadIds).toArray();
          const keepCharacterIds = [...new Set(keepThreads.map(t => t.characterId))];
          const keepCharacters = await db.characters.where("id").anyOf(keepCharacterIds).toArray();
          const keepLoreBookUrls = keepCharacters.map(c => c.loreBookUrls).flat();
          const keepLoreBookIds = keepThreads.map(t => t.loreBookId);
          keepThreadCheck = (id) => keepThreadIds.includes(id);
          keepLoreBookCheck = (id) => keepLoreBookIds.includes(id);
          keepLoreBookUrlCheck = (url) => keepLoreBookUrls.includes(url);
          keepCharacterCheck = (id) => keepCharacterIds.includes(id);
        }

        
        if(result.exportUserData === "no") {
          json.data.data.find(d => d.tableName === "misc").rows = [];
        }
        // remove datesApplicationWasUsedInThisBrowser because it's browser-specific 
        json.data.data.find(d => d.tableName === "misc").rows = json.data.data.find(d => d.tableName === "misc").rows.filter(r => r.key !== "datesApplicationWasUsedInThisBrowser");

        let threads = json.data.data.find(d => d.tableName === "threads");
        threads.rows = threads.rows.filter(t => keepThreadCheck(t.id));

        let characters = json.data.data.find(d => d.tableName === "characters");
        characters.rows = characters.rows.filter(c => keepCharacterCheck(c.id));

        let messages = json.data.data.find(d => d.tableName === "messages");
        messages.rows = messages.rows.filter(m => keepThreadCheck(m.threadId));

        let summaries = json.data.data.find(d => d.tableName === "summaries");
        if(summaries) {
          let summaryHashesToKeep = new Set(threads.rows.map(t => t.currentSummaryHashChain ?? []).flat());
          // Note: s.threadId only exists for 'legacy' reasons (we don't rely on it because a summary can be used by multiple threads), but it's useful here because currentSummaryHashChain is a new property and may not exist for old threads, so we can use the threadId as a backup check
          summaries.rows = summaries.rows.filter(s => summaryHashesToKeep.has(s.hash) || keepThreadCheck(s.threadId));
        }

        let memories = json.data.data.find(d => d.tableName === "memories");
        if(memories) {
          memories.rows = memories.rows.filter(m => keepThreadCheck(m.threadId));
        }

        let lore = json.data.data.find(d => d.tableName === "lore");
        if(lore) {
          lore.rows = lore.rows.filter(l => keepLoreBookCheck(l.bookId) || keepLoreBookUrlCheck(l.bookUrl));
        }

        let textEmbeddingCache = json.data.data.find(d => d.tableName === "textEmbeddingCache");
        if(textEmbeddingCache) {
          let memoryAndLoreTextHashes = new Set(await Promise.all([...lore.rows, ...memories.rows].map(entry => sha256Text(entry.text))));
          textEmbeddingCache.rows = textEmbeddingCache.rows.filter(c => memoryAndLoreTextHashes.has(c.textHash));
        }

        if(result.exportUserData === "no") {
          json.data.data.find(d => d.tableName === "usageStats").rows = [];
        } else {
          let usageStats = json.data.data.find(d => d.tableName === "usageStats");
          usageStats.rows = usageStats.rows.filter(entry => keepThreadCheck(entry.threadId) && keepCharacterCheck(entry.characterId));
        }

        let yyyymmdd = new Date().toISOString().split("T")[0];
        downloadTextOrBlob(JSON.stringify(json), `opencharacters-export-${yyyymmdd}.json`);

        loadingModal.delete();
      });

      // This renders the list of threads in the left column.
      async function renderThreadList(opts={}) {
        if(!opts.maxShownThreads) opts.maxShownThreads = 50;

        let threads = await db.threads.orderBy("lastMessageTime").reverse().toArray();

        if(threads.length >= 3) {
          showEl($.threadSearchCtn);
        } else {
          hideEl($.threadSearchCtn);
        }

        let currentFolderPath = $.chatThreads.dataset.currentFolderPath;
        let allFolderPaths = [...new Set(threads.map(t => t.folderPath))];
        let currentSubfolderNames = [...new Set(allFolderPaths.filter(p => p.startsWith(currentFolderPath) && p !== currentFolderPath).map(p => p.split("/").slice(currentFolderPath.split("/").length-(currentFolderPath === "" ? 1 : 0)).filter(s => s)[0]))];

        if(!opts.filterWithQuery) { // don't do folder stuff if they're searching
          threads = threads.filter(t => t.folderPath === currentFolderPath);
        }

        let characters = await db.characters.toArray();
        for(let thread of threads) {
          thread.character = characters.find(c => c.id === thread.characterId) || null;
        }

        let threadsWithoutCharacter = threads.filter(t => !t.character);
        if(threadsWithoutCharacter.length > 0) {
          let r = prompt(`You have one or more threads (with ids=${threadsWithoutCharacter.map(t => t.id).join(",")}) that are referencing character(s) that don't exist. This is a bug. Please report it on Github or Discord. You can type "yes" below to delete these threads if a OpenCharacters dev has recommended it, otherwise just click OK.`);
          if(r?.toLowerCase().trim() === "yes") {
            for(let thread of threadsWithoutCharacter) {
              await safelyDeleteThreadById(thread.id);
            }
          }
        }

        threads = threads.filter(t => t.character);

        if(opts.filterWithQuery) {
          let q = opts.filterWithQuery.toLowerCase();
          // iterate over all threads, and all messages in each thread, and tally query "hits" for the threads
          for(let thread of threads) {
            thread.queryHits = 0;
            const messages = await db.messages.where("threadId").equals(thread.id).toArray();
            for(let message of messages) {
              if(message.message.toLowerCase().includes(q)) {
                thread.queryHits++;
              }
            }
          }
          // sort and filter
          threads.sort((a,b) => b.queryHits - a.queryHits);
          threads = threads.filter(t => t.queryHits > 0);
          for(let thread of threads) {
            delete thread.queryHits;
          }
        }

        let threadIdToMoneySpent = {};
        for(let thread of threads) {
          let entries = await db.usageStats.where("threadId").equals(thread.id).toArray();
          threadIdToMoneySpent[thread.id] = usageStatsEntriesToCost(entries);
        }

        // move isFav threads to top without affecting order of the others:
        threads.sort((a,b) => {
          if(a.isFav && !b.isFav) return -1;
          if(!a.isFav && b.isFav) return 1;
          return 0;
        });

        let threadFolderData = (await db.misc.get("threadFolderData"))?.value || {};

        let foldersHtml = "";
        if(!opts.filterWithQuery) { // don't do folder stuff if they're searching
          if(currentFolderPath !== "") {
            foldersHtml += `<div class="threadFolder" data-folder-path="${sanitizeHtml(currentFolderPath.split("/").slice(0, -1).join("/"))}">🔙 up one level</div>`;
          }
          foldersHtml += currentSubfolderNames.map(name => {
            let folderPath = currentFolderPath ? currentFolderPath+"/"+name : name;
            let icon = threadFolderData[folderPath]?.emoji;
            if(icon && icon.startsWith("http")) {
              icon = `<img src="${sanitizeHtml(icon)}" style="height:1.2rem; width:1.2rem; object-fit:cover; border-radius:2px;"/>`;
            }
            return `<div class="threadFolder" data-folder-path="${sanitizeHtml(folderPath)}">${icon ?? "📁"}<span style="flex-grow:1; margin-left:0.5rem;">${sanitizeHtml(name)}</span><span class="editFolderName emojiButton" style="font-size:0.7rem; display:flex; align-items:center;">✏️</span></div>`;
          }).join("");
        }
        // $.chatThreadFolders.innerHTML = foldersHtml;

        let dataUrlToCachedBlobUrlMap = {};
        for(let thread of threads) {
          let avatarUrl = thread.character.avatar.url;
          if(avatarUrl && avatarUrl.startsWith("data:")) {
            dataUrlToCachedBlobUrlMap[avatarUrl] = await dataUrlToCachedBlobUrl(avatarUrl);
          }
        }

        let showAllButtonHtml = "";
        if(threads.length > opts.maxShownThreads) {
          showAllButtonHtml = `<div style="text-align:center; margin-top:0.5rem;"><button class="showAllThreadsButton">show all threads</button></div>`;
          threads = threads.slice(0, opts.maxShownThreads);
        }

        let threadsHtml = threads.map(thread => {
          let avatarUrl = thread.character.avatar.url;
          if(avatarUrl && avatarUrl.startsWith("data:")) {
            avatarUrl = dataUrlToCachedBlobUrlMap[avatarUrl];
          }
          return `
            <div class="thread" data-thread-id="${sanitizeHtml(thread.id)}">
              <span class="favStar" data-is-fav="${thread.isFav}">⭐</span>
              <span class="changeFolderPath">📁</span>
              <div class="avatar" style="${avatarUrl ? `background-image:url(${sanitizeHtml(avatarUrl)})` : ""}; border:1px solid var(--border-color);"></div>
              <div class="info" style="flex-grow:1; padding-left:0.5rem;">
                <div class="nameWrapper" style="font-weight:bold; font-size:0.8rem;"><span class="name" title="${sanitizeHtml(thread.name)}">${sanitizeHtml(thread.name)}</span></div>
                <div class="characterName" style="font-size:0.8rem;">${thread.character.name.length > 15 ? sanitizeHtml(thread.character.name.slice(0, 15)+"…") : sanitizeHtml(thread.character.name)} <span style="opacity:0.5; font-weight:normal;" title="Character ID">#${sanitizeHtml(thread.character.id)}</span> <span class="characterEditButton">✏️</span></div>
                <div style="font-size:0.8rem; opacity:0.5; padding-right:0.5rem; display:flex; justify-content:space-between;"><span style="font-size:0.65rem;" title="${sanitizeHtml(thread.modelName)}">${thread.modelName.length > 13 ? sanitizeHtml(thread.modelName.slice(0, 13))+"…" : sanitizeHtml(thread.modelName)}</span><span class="usageStatsSpend" title="API usage/spend" style="font-size:0.65rem;display:flex;align-items:center;">$${threadIdToMoneySpent[thread.id].toFixed(2)}</span><span style="font-size:0.65rem; display:flex; align-items:center; filter:grayscale(1);" title="Thread ID">🧵#${sanitizeHtml(thread.id)}</span></div>
              </div>
              <div style="display:flex; flex-direction:column; justify-content:space-between; font-size:0.65rem;">
                <span class="button nameEditButton">✏️</span>
                <span class="button exportButton">💾</span>
                <span class="button deleteButton">🗑️</span>
              </div>
            </div>`;
        }).join("");

        $.chatThreads.innerHTML = foldersHtml + threadsHtml + showAllButtonHtml;


        $.chatThreads.querySelector(".showAllThreadsButton")?.addEventListener("click", function() {
          opts.maxShownThreads = Infinity;
          renderThreadList(opts);
        });

        // if message feed is visible, set selected thread to the currently-visible chat thread
        if($.messageFeed.offsetWidth > 0 && activeThreadId !== null) {
          let threadCardForActiveThread = $.chatThreads.querySelector(`.thread[data-thread-id="${activeThreadId}"]`);
          if(threadCardForActiveThread) threadCardForActiveThread.classList.add("selected");
        }

        $.chatThreads.querySelectorAll(".editFolderName").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            const folderPath = btn.closest(".threadFolder").dataset.folderPath;
            
            let label;
            if(folderPath.split("/").length === 1) {
              label = `Edit the name of this folder:`;
            } else {
              label = `Edit the name of this folder by changing '${folderPath.split("/").at(-1)}' to something else, or move all items inside the '${folderPath.split("/").at(-1)}' folder to a new location by editing the whole folder path:`;
            }
            let threadFolderData = (await db.misc.get("threadFolderData"))?.value || {};

            let result = await prompt2({
              newFolderPath: {type:"textLine", label, defaultValue:folderPath},
              emoji: {type:"textLine", label:"Folder emoji or image URL:", defaultValue:threadFolderData[folderPath]?.emoji || ""},
            });
            if(!result) return;

            if(result.emoji) {
              if(!threadFolderData[folderPath]) threadFolderData[folderPath] = {};
              threadFolderData[folderPath].emoji = result.emoji;
            }

            await db.misc.put({key:"threadFolderData", value:threadFolderData});

            let newFolderPath = result.newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
            // each thread has a folderPath property, which is a string like "folder1/folder2/folder3" or just "" (empty string) if it's in the root folder
            await db.threads.toCollection().modify(function(thread) {
              // we need to move all threads that start with folderPath to newFolderPath
              if(thread.folderPath === folderPath) {
                thread.folderPath = newFolderPath;
              } else if(thread.folderPath.startsWith(folderPath+"/")) {
                thread.folderPath = newFolderPath + thread.folderPath.slice(folderPath.length);
              }
            });
            await renderThreadList();
          });
        });

        $.chatThreads.querySelectorAll(".thread").forEach(thread => {
          thread.addEventListener("click", async function() {
            const threadId = parseInt(thread.dataset.threadId);
            let loadingModal = createLoadingModal("Loading...");
            await showThread(threadId);
            loadingModal.delete();
          });
        });
        $.chatThreads.querySelectorAll(".thread .favStar").forEach(favStarEl => {
          favStarEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            const threadId = parseInt(favStarEl.closest(".thread").dataset.threadId);
            let thread = await db.threads.get(threadId);
            let isFav = !thread.isFav;
            await db.threads.update(threadId, { isFav });
            favStarEl.dataset.isFav = isFav;
          });
        });
        $.chatThreads.querySelectorAll(".thread .changeFolderPath").forEach(changeFolderPathEl => {
          changeFolderPathEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            const threadId = parseInt(changeFolderPathEl.closest(".thread").dataset.threadId);
            let thread = await db.threads.get(threadId);
            let newFolderPath = prompt(`Enter new folder path for this thread. You can add subfolders with forward-slashes like 'folder/subfolder/...'`, thread.folderPath);
            if(newFolderPath !== null) {
              newFolderPath = newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
              await db.threads.update(threadId, { folderPath: newFolderPath });
              await renderThreadList();
            }
          });
        });
        $.chatThreads.querySelectorAll(".threadFolder").forEach(threadFolderEl => {
          threadFolderEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            $.chatThreads.dataset.currentFolderPath = threadFolderEl.dataset.folderPath;
            await renderThreadList();
          });
        });
        $.chatThreads.querySelectorAll(".nameEditButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            // edit the thread name and re-render thread list.
            let newName = prompt("Enter new name for this thread.");
            if(newName) {
              const threadId = parseInt(btn.closest(".thread").dataset.threadId);
              await db.threads.update(threadId, { name: newName });
              await renderThreadList();
            }
          });
        });
        $.chatThreads.querySelectorAll(".usageStatsSpend").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            alert("OpenCharacters is a completely free application, but to use it, you need to connect it with one or more 'API' providers which act as the 'brains' of your characters. The spend figure you just clicked represents an estimate for the amount of money you've spent using the API that you have connected. If you're using OpenAI, you can see authorative spend amounts here:\n\nhttps://platform.openai.com/account/usage");
          });
        });
        $.chatThreads.querySelectorAll(".exportButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();

            const result = await prompt2({
              exportType: {label: "export type:", type: "select", options:[{value:"json", content:"whole thread, including character (recommended)"}, {value:"text", content:"message text only (in [AI]/[USER] format - use '/import' command to import)"}]},
              // includeUserMessagesSentHistory: {hidden:true, label: "include user messages sent history:", type: "select", options:[{value:"no"}, {value:"yes"}]},
            }, {submitButtonText:"export"});
            if(!result) return;

            let loadingModal = createLoadingModal("Exporting thread...");
            
            let opts = {};
            opts.excludeUserMessagesSentHistory = true;

            const threadId = parseInt(btn.closest(".thread").dataset.threadId);
            let json = await getThreadJSONById(threadId, opts);

            let thread = await db.threads.get(threadId);
            let character = await db.characters.get(thread.characterId);

            if(result.exportType === "text") {
              let filename = encodeURIComponent(`${thread.name} - ${character.name}`.replaceAll(" ", "_")) + ".txt";
              let text = json.data.data.find(t => t.tableName === "messages").rows.sort((a,b) => a.order-b.order).map(m => {
                return (m.characterId === -1 ? "[USER]: " : m.characterId === -2 ? "[SYSTEM]: " : "[AI]: ") + m.message;
              }).join("\n\n");
              downloadTextOrBlob(text, filename);
            } else {
              let filename = encodeURIComponent(`${thread.name} - ${character.name}`.replaceAll(" ", "_")) + ".json";
              downloadTextOrBlob(JSON.stringify(json), filename);
            }

            loadingModal.delete();
          });
        });

        
        $.chatThreads.querySelectorAll(".characterEditButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.preventDefault();
            e.stopPropagation();
            const threadId = parseInt(btn.closest(".thread").dataset.threadId);
            const thread = await db.threads.get(threadId);
            await editCharacterById(thread.characterId);
          });
        });

        $.chatThreads.querySelectorAll(".deleteButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            if(confirm("Are you sure you want to delete this thread?")) {
              const threadId = parseInt(btn.closest(".thread").dataset.threadId);
              await safelyDeleteThreadById(threadId);
              await renderThreadList();
              // switch to character selection area
              await renderCharacterList();
              document.querySelectorAll("#middleColumn > .middleColumnScreen").forEach(el => hideEl(el));
              showEl($.characterSelection);
            }
          });
        });


      }

      function usageStatsEntriesToCost(entries) {
        let sum = 0;
        for(let entry of entries) {
          let costs = availableModels[entry.modelName]?.tokenPricing ?? {prompt:0, completion:0}; // might not be available if they added a custom model but it's now removed.
          sum += costs.prompt * entry.tokens.prompt/1000;
          sum += costs.completion * entry.tokens.completion/1000;
        }
        if(isNaN(sum)) debugger;
        return sum;
      }

      async function updateThreadUsageStatsSpendDisplay(threadId) {
        let entries = await db.usageStats.where("threadId").equals(threadId).toArray();
        let spent = usageStatsEntriesToCost(entries);
        $.chatThreads.querySelector(`.thread[data-thread-id="${threadId}"] .usageStatsSpend`).textContent = "$" + spent.toFixed(2);
      }


      async function getThreadJSONById(threadId, opts={}) {
        const thread = await db.threads.get(threadId);
        let threadCharacterIds = (await db.messages.where("threadId").equals(threadId).toArray()).map(m => m.characterId);
        threadCharacterIds = [...new Set(threadCharacterIds)];
        let threadCharacters = await db.characters.where("id").anyOf(threadCharacterIds).toArray();
        let threadCharacterLoreBookUrls = [...new Set(threadCharacters.map(c => c.loreBookUrls).flat())];

        const blob = await db.export({prettyJson: true, numRowsPerChunk:100});
        const json = await new Response(blob).json(); // use Response hack instead of JSON.parse(await blob.text()) to avoid maximum string length errors

        // in case I add a new table and forget to update this function, tables must be explicitely allowed here:
        let tableNamesAllowList = ["characters", "threads", "messages", "summaries", "memories", "usageStats", "lore"];
        for(let table of json.data.data) {
          if(!tableNamesAllowList.includes(table.tableName)) {
            table.rows = [];
          }
        }

        // only keep the data for the current thread:
        let characters = json.data.data.find(d => d.tableName === "characters");
        characters.rows = characters.rows.filter(c => threadCharacterIds.includes(c.id));
        
        let threads = json.data.data.find(d => d.tableName === "threads");
        threads.rows = threads.rows.filter(t => t.id === threadId);
        if(threads.rows.length > 1) alert("Something went wrong. There should only be one thread in the export, but several were exported.");
        
        // privacy stuff:
        if(opts.excludeUserMessagesSentHistory) {
          threads.rows[0].userMessagesSentHistory = [];
        }
        threads.rows[0].unsentMessageText = "";
        
        let messages = json.data.data.find(d => d.tableName === "messages");
        messages.rows = messages.rows.filter(m => m.threadId === threadId);

        let summaries = json.data.data.find(d => d.tableName === "summaries");
        if(summaries) {
          let hashes = new Set(thread.currentSummaryHashChain || []);
          // note: summaries shouldn't really have a threadId because they have hash as a unique key, which means if someone duplicates a thread, there is a single summary, but it's used for multiple threads.
          // that's why we use hashes instead of threadId here. I've yet to adjust the db to remove threadId from summaries.
          summaries.rows = summaries.rows.filter(s => hashes.has(s.hash));
        }

        let memories = json.data.data.find(d => d.tableName === "memories");
        if(memories) {
          memories.rows = memories.rows.filter(s => s.threadId === threadId);
        }

        let lore = json.data.data.find(d => d.tableName === "lore");
        if(lore) {
          lore.rows = lore.rows.filter(l => l.bookId === thread.bookId || (l.bookUrl && threadCharacterLoreBookUrls.includes(l.bookUrl)));
        }

        let usageStats = json.data.data.find(d => d.tableName === "usageStats");
        if(usageStats) {
          usageStats.rows = usageStats.rows.filter(m => m.threadId === threadId);
        }

        return json;
      }

      // Given a threadId, this renders the message feed for that thread in the middle column.
      const numMessagesPerDisplayBatch = 50;
      let previouslyRenderedMessageFeedThreadId = null;
      async function renderMessageFeed(threadId, opts={}) {
        $.messageFeed.dataset.threadId = threadId;

        const thread = (await db.threads.where("id").equals(threadId).toArray())[0];
        const messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        const character = (await db.characters.where("id").equals(thread.characterId).toArray())[0];
        let userCharacter = await getUserCharacterObj(threadId);
        let systemCharacter = await getSystemCharacterObj(threadId);
        let showInlineReminder = (await db.misc.get("showInlineReminder"))?.value || "yes";

        let displayedMessages = messages.slice(-numMessagesPerDisplayBatch);

        displayedMessages = await renderMessagesForReader({messages:displayedMessages, reader:"user", threadId});

        let characterIdToCharacterObj = {
          "-1": userCharacter,
          "-2": systemCharacter,
          [character.id]: character,
        };

        // for(let message of displayedMessages) {
        //   if(message.characterId === -1) {
        //     message.character = userCharacter;
        //   } else if(message.characterId === -2) {
        //     message.character = systemCharacter;
        //   } else {
        //     message.character = character;
        //   }
        // }

        // get message feed scroll position:
        // let originalScrollPosition = $.messageFeed.scrollTop;
        
        let messagesWeNeedToAdd = displayedMessages.slice(0);

        // shift messages off `messagesWeNeedToAdd` until we find one that doesn't *exactly* match the same-index element that is already in the feed
        let lastMatchingMessageEl;
        let preexistingMessageEls = [];
        if(!opts.forceFullRender) {
          for(let messageEl of $.messageFeed.querySelectorAll(".message")) {
            let messageObj = messagesWeNeedToAdd[0];
            let messageObjHash = await sha256Text(JSON.stringify(messageObj));
            if(messageEl.dataset.hash === messageObjHash) {
              lastMatchingMessageEl = messageEl;
              messagesWeNeedToAdd.shift();
              preexistingMessageEls.push(messageEl);
            } else {
              break;
            }
          }
        }

        // remove all elements after the last matching element (including non-message elements - e.g. "undo deletion" buttons):
        if(lastMatchingMessageEl) {
          if(lastMatchingMessageEl !== [...$.messageFeed.querySelectorAll(".message")].at(-1)) { // if it's the last one, we don't need to do anything (and we want to avoid removing an 'undo delete' button that might come after it, for example)
            let el = lastMatchingMessageEl.nextSibling;
            while(el) {
              let nextEl = el.nextSibling;
              el.remove();
              el = nextEl;
            }
          }
        } else {
          // no messages matched, so clear the feed:
          $.messageFeed.innerHTML = "";
        }

        $.messageFeed.dataset.characterId = character.id;
        let messageEls = await Promise.all(messagesWeNeedToAdd.map(m => createMessageElement(m, {character:characterIdToCharacterObj[m.characterId]})));
        for(let el of messageEls) {
          $.messageFeed.appendChild(el);
        }
        $.messageFeed.querySelectorAll(".message").forEach(messageEl => {
          if(preexistingMessageEls.includes(messageEl)) return;

          attachEventHandlersToMessageEl(messageEl);
        });

        // if(previouslyRenderedMessageFeedThreadId === threadId) {
        //   // restore message feed scroll position:
        //   $.messageFeed.scrollTop = originalScrollPosition;
        // } else {
        //   // scroll to bottom of feed
        //   $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
        // }

        $.messageFeed.scrollTop = $.messageFeed.scrollHeight
        
        if(displayedMessages.length === 0) {
          showEl($.noMessagesNotice);
        } else {
          hideEl($.noMessagesNotice);
        }

        if(messages.length > displayedMessages.length) {
          setTimeout(() => { // <-- do this in a set timeout so the message feed has time to render, else it might get triggered right away
            // add a "load earlier" element at the top of the feed with an intersection observer that triggers when it's scrolled into view
            let triggerEl = document.createElement("div");
            triggerEl.cssText = `height:50px;`;
            let triggerIsEnabled = true;
            $.messageFeed.insertBefore(triggerEl, $.messageFeed.firstChild);
            // add intersection observer
            let observer = new IntersectionObserver((entries, observer) => {
              entries.forEach(async entry => {
                if(entry.isIntersecting && triggerIsEnabled) {
                  triggerIsEnabled = false;
                  let { finished } = await prependEarlierMessagesToFeed();
                  if(finished) {
                    observer.unobserve(triggerEl);
                    triggerEl.remove();
                  } else {
                    // move trigger to top of message feed and enable:
                    $.messageFeed.prepend(triggerEl);
                    triggerIsEnabled = true;
                  }
                }
              });
            });
            observer.observe(triggerEl);
          }, 100);
        }

        await updateInlineReminderMessage({aiCharacter:character, thread, showInlineReminder});
        await updateThreadScene();

        previouslyRenderedMessageFeedThreadId = threadId;

        if(opts.triggerBotReply !== false) {
          doBotReplyIfNeeded(); // we shouldn't `await` this because thread is already rendered.
        }
      }

      // for debugging:
      window.renderMessageFeed = renderMessageFeed;
      
      let threadIdToMusicPermission = {}
      let updateThreadSceneCounter = 0;
      async function updateThreadScene() {
        if($.messageFeed.offsetWidth === 0) {
          console.warn("Tried to update thread scene but message feed was not visible.");
          return;
        }
        updateThreadSceneCounter++;
        let threadId = activeThreadId;
        let thread = await db.threads.get(threadId);
        let character = await db.characters.get(thread.characterId);
        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        let scene = character.scene || {}; // character scene is always used as a "base", latest message scene overrides it.
        let lastMessageWithScene = messages.findLast(m => m.scene);
        if(lastMessageWithScene) {
          applyObjectOverrides({object:scene, overrides:lastMessageWithScene.scene});
        }
        // note that dev can fully override scene with an 'empty' scene by just adding a scene with background.url=null, etc.
        // if they just add message.scene={} then it will just use the character's scene.

        if(scene.background?.url) {
          if(sceneBackground.currentUrl !== scene.background.url) {
            sceneBackground.change(scene.background.url);
          }
          if(scene.background.filter) {
            sceneBackground.filter(scene.background.filter);
          } else {
            sceneBackground.filter(null);
          }
        } else {
          sceneBackground.change(null);
        }

        if(scene.music?.url) {
          if($.musicPlayer.src !== scene.music.url) {
            $.musicPlayer.src = scene.music.url;
          }
          if(threadIdToMusicPermission[threadId] === undefined) {
            threadIdToMusicPermission[threadId] = confirm("Allow this thread to play background music?");
          }
          if(threadIdToMusicPermission[threadId] && $.musicPlayer.paused) {
            (async function(sceneUpdateI) {
              // wait for page to be activated, but then only go ahead and play it if we're still on the same scene update:
              while(!navigator.userActivation.hasBeenActive) {
                await delay(1000);
                console.log("Waiting for page to be activated before playing sound...");
              }
              if(sceneUpdateI === updateThreadSceneCounter && $.musicPlayer.paused) $.musicPlayer.play();
            })(updateThreadSceneCounter);
          }
        } else {
          $.musicPlayer.src = "";
          $.musicPlayer.pause();
        }

        // note: we don't need lots of extra customization here (e.g. exposing play/pause/seek api), because devs can do whatever they want in custom code - this is just for *end-users* to easily add music to their characters/stories in the character editor
        $.musicPlayer.volume = scene.music.volume === undefined ? 1 : scene.music.volume;
        $.musicPlayer.loop = scene.music.loop === undefined ? true : scene.music.loop;
      }

      async function prependEarlierMessagesToFeed() {
        let threadId = activeThreadId;
        // get id of first message in feed
        let firstMessageOrder = parseInt($.messageFeed.querySelector(".message").dataset.order);
        // get all messages before that from db
        let messages = await db.messages.where("threadId").equals(threadId).and(m => m.order < firstMessageOrder).toArray();
        messages.sort((a,b) => a.order - b.order);
        if(messages.length === 0) {
          return {finished:true};
        }
        // grab the last `numMessagesPerDisplayBatch` messages
        let displayedMessages = messages.slice(-numMessagesPerDisplayBatch);
        const thread = (await db.threads.where("id").equals(threadId).toArray())[0];
        const character = (await db.characters.where("id").equals(thread.characterId).toArray())[0];

        let characterIdToCharacterObj = {
          "-1": await getUserCharacterObj(threadId),
          "-2": await getSystemCharacterObj(threadId),
          [character.id]: character,
        };

        // get top element in feed
        let topEl = $.messageFeed.querySelector(".message");
        // get scroll distance from top element
        let scrollDistanceFromTopEl = topEl.getBoundingClientRect().top - $.messageFeed.getBoundingClientRect().top;

        let messageEls = await Promise.all(displayedMessages.map(m => createMessageElement(m, {character:characterIdToCharacterObj[m.characterId]})));
        messageEls.reverse();
        for(let el of messageEls) {
          $.messageFeed.prepend(el);
          attachEventHandlersToMessageEl(el);
        }

        // scroll to original top element, restoring original distance
        $.messageFeed.scrollTop = topEl.getBoundingClientRect().top - $.messageFeed.getBoundingClientRect().top - scrollDistanceFromTopEl;
        
        return {finished:false};
      }

      // function createInlineSummaryEditor(summaryText) {
      //   let tmp = document.createElement("div");
      //   if(summaryText.length > 50) summaryText = summaryText.slice(0, 30) + "…";
      //   tmp.innerHTML = `
      //     <div class="inlineSummaryEditor" style="margin-bottom: 0.25rem;">
      //       <div style="opacity: 0.5;font-size: 0.7rem;text-align: center;"><b>Summary so far:</b> <span>${summaryText}</span> <span class="inlineSummaryEditButton" style="cursor: pointer;">✏️</span></div>
      //     </div>
      //   `;
      //   let el = tmp.firstElementChild;
      //   el.querySelector(".inlineSummaryEditButton").addEventListener("click", async function() {
      //     let threadSummariesArr = await db.summaries.where('threadId').equals(threadId).toArray();
      //     let latestSummary = threadSummariesArr.sort((a,b) => b.id-a.id)[0];
      //     let result = await prompt2({
      //       summaryText: {label: "Summary of preceding messages:", height:"fit-content", type: "text", defaultValue: reminderMessage, placeholder: "Write your summary here."}
      //     });
      //     if(result) {
      //       await db.summaries.update(characterId, {reminderMessage:result.reminderMessage});
      //       await updateInlineSummaryEditor();
      //     }
      //   });
      //   return el;
      // }

      // async function updateInlineSummaryEditor() {
      //   $.messageFeed.querySelectorAll(".inlineSummaryEditor").forEach(el => el.remove());
      //   let threadId = activeThreadId;
      //   let threadSummariesArr = await db.summaries.where('threadId').equals(threadId).toArray();
      //   let messagesArr = await db.messages.where('threadId').equals(threadId).toArray();
      //   let undeletedMessageIds = messagesArr.map(m => m.id);
      //   let latestSummaryObj = threadSummariesArr.sort((a,b) => b.id-a.id)[0];

      //   if(!latestSummaryObj) {
      //     return;
      //   }
      //   let latestMessage = botMessages.at(-1);
      //   let el = createInlineSummaryEditor(latestSummaryObj);
      //   lastBotMessageEl.before(el);
      // }

      function createInlineReminderMessage(reminderMessage) {
        let tmp = document.createElement("div");
        if(reminderMessage.length > 50) reminderMessage = reminderMessage.slice(0, 30) + "…";
        tmp.innerHTML = `
          <div class="inlineReminderMessage" style="margin-bottom: 0.25rem;">
            <div style="opacity: 0.5;font-size: 0.7rem;text-align: center;"><span>${reminderMessage}</span> <span class="inlineReminderMessageEditButton" style="cursor: pointer;">✏️</span></div>
          </div>
        `;
        let el = tmp.firstElementChild;
        el.querySelector(".inlineReminderMessageEditButton").addEventListener("click", async function() {
          let threadId = activeThreadId;
          let thread = await db.threads.get(threadId);
          let characterId = thread.characterId;
          let character = await db.characters.get(characterId);

          let reminderMessage = character.reminderMessage || "";
          
          let usingThreadReminderMessage = false;
          if(typeof thread.character.reminderMessage === "string") {
            usingThreadReminderMessage = true;
            reminderMessage = thread.character.reminderMessage;
          }

          let result = await prompt2({
            reminderMessage: {label: "Edit the character's reminder message. <b>Note:</b> This text is placed in a 'hidden' message right before the character responds. Be careful that your reminder message doesn't 'throw off' the conversation. You can try putting your reminder message in parentheses like (Reminder: ...) or (Note: ...) or (Thought: ...) or (OOC: ...) if your character is responding to the reminder message. The <a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/instruction-and-reminder.md' target='_blank'>advanced syntax</a> may also be useful.", height:"fit-content", type: "text", defaultValue: reminderMessage, focus:true, placeholder: "Enter a reminder message here. A reminder message is a 'system' message that helps remind/command/instruct the AI on how to respond."}
          });
          // debugger;
          if(result) {
            if(usingThreadReminderMessage) {
              await db.transaction('rw', db.threads, async tx => {
                thread = await tx.table("threads").get(threadId);
                thread.character.reminderMessage = result.reminderMessage;
                await tx.table("threads").put(thread);
              });
            } else {
              await db.characters.update(characterId, {reminderMessage:result.reminderMessage});
            }
            await updateInlineReminderMessage();
          }
        });
        return el;
      }

      async function updateInlineReminderMessage(opts={}) {
        // note: opts.aiCharacter and opt.thread can be passed for performance reasons if the caller already has the aiCharacter object

        // place reminder element before the most recent bot message
        let characterId = activeCharacterId;
        let threadId = activeThreadId;
        let character;
        if(!opts.aiCharacter){
          character = await db.characters.get(characterId);
        } else {
          character = opts.aiCharacter;
        }

        let thread;
        if(!opts.thread){
          thread = await db.threads.get(threadId);
        } else {
          thread = opts.thread;
        }

        let showInlineReminder;
        if(!opts.showInlineReminder) {
          showInlineReminder = (await db.misc.get("showInlineReminder"))?.value || "yes";
        } else {
          showInlineReminder = opts.showInlineReminder;
        }

        let reminderMessage = character.reminderMessage || "";
        let usingThreadReminderMessage = false;
        if(typeof thread.character.reminderMessage === "string") {
          usingThreadReminderMessage = true;
          reminderMessage = thread.character.reminderMessage;
        }

        let botMessages = [...$.messageFeed.querySelectorAll(`.message[data-character-id='${characterId}']`)];

        // remove existing inline reminder messages (important to do this after the async db call above to be sure that if updateInlineReminderMessage is for some reason called twice very close together, we won't get too inline reminders)
        $.messageFeed.querySelectorAll(".inlineReminderMessage").forEach(el => el.remove());

        if(!reminderMessage.trim() || botMessages.length === 0) {
          return;
        }

        let lastBotMessageEl = botMessages.at(-1);

        if($.messageFeed.querySelector(".message") === lastBotMessageEl) {
          return; // don't put it on the very first message in the feed, because it looks weird and is probably unnecessary anyway
        }

        let el = createInlineReminderMessage(reminderMessage);

        if(showInlineReminder === "no") {
          el.style.display = "none";
        }

        let shouldScrollDown = messageFeedIsNearBottom();
          
        lastBotMessageEl.before(el);

        if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
      }

      function createCharacterCardHtml(character) {
        return `
          <div class="character" data-character-id="${sanitizeHtml(character.id)}" style="display:flex; padding:0.5rem; cursor:pointer;">
            <div class="avatar" style="${character.avatar.url ? `background-image:url(${sanitizeHtml(character.avatar.url)})` : ""};"></div>
            <div class="info" style="flex-grow:1; padding-left:0.5rem; display: flex; flex-direction: column; justify-content: space-between;">
              <div class="name" style="font-weight:bold;${character.name.length > 21 ? "font-size:0.8rem;" : ""}">${character.name.length > 21 ? sanitizeHtml(character.name.slice(0, 22)+"…") : sanitizeHtml(character.name)} <span style="opacity:0.5; font-weight:normal;">${character.id !== null ? "#"+sanitizeHtml(character.id) : ""}</span></div>
              <!-- <div class="roleInstruction" style="font-size: 0.8rem; text-overflow: ellipsis; word-wrap: break-word; overflow: hidden; height: 2em; line-height: 1em;">${character.roleInstruction.length > 85 ? sanitizeHtml(character.roleInstruction.slice(0, 85)+"...") : sanitizeHtml(character.roleInstruction)}</div> -->
              <div class="buttons" style="text-align:right;">
                ${character.id === null ? "" :
                `<button class="edit" title="Edit this character">✏️ edit</button>
                <button class="changeFolderPath" title="Change folder">📁</button>
                <button class="duplicate" title="Duplicate this character">➕</button>
                <button class="share" title="Share this character with a link">🔗</button>
                <button class="delete" title="Delete this character">🗑️</button>`
                }
              </div>
            </div>
          </div>
        `;
      }
      
      // The character list appears when user clicks the "new chat" button.
      // If they click a character, it starts a new thread with that character.
      async function renderCharacterList() {
        // get characters, sort by lastMessageTime
        let characters = await db.characters.orderBy("lastMessageTime").reverse().toArray();

        let currentFolderPath = $.characterFoldersList.dataset.currentFolderPath;
        let allFolderPaths = [...new Set(characters.map(c => c.folderPath))];
        let currentSubfolderNames = [...new Set(allFolderPaths.filter(p => p.startsWith(currentFolderPath) && p !== currentFolderPath).map(p => p.split("/").slice(currentFolderPath.split("/").length-(currentFolderPath === "" ? 1 : 0)).filter(s => s)[0]))];
        characters = characters.filter(t => t.folderPath === currentFolderPath);

        let characterFolderData = (await db.misc.get("characterFolderData"))?.value || {};

        let foldersHtml = "";
        if(currentFolderPath !== "") {
          foldersHtml += `<div class="characterFolder" data-folder-path="${sanitizeHtml(currentFolderPath.split("/").slice(0, -1).join("/"))}">🔙 up one level</div>`;
        }
        foldersHtml += currentSubfolderNames.map(name => {
          let folderPath = currentFolderPath ? currentFolderPath+"/"+name : name;
          let icon = characterFolderData[folderPath]?.emoji;
          if(icon && icon.startsWith("http")) {
            icon = `<img src="${sanitizeHtml(icon)}" style="height:1.2rem; width:1.2rem; object-fit:cover; border-radius:2px;"/>`;
          }
          return `<div class="characterFolder" data-folder-path="${sanitizeHtml(folderPath)}">${icon ?? "📁"}<span style="flex-grow:1; margin-left:0.5rem;">${sanitizeHtml(name)}</span><span class="editFolderName emojiButton" style="font-size:0.7rem; display:flex; align-items:center;">✏️</span></div>`;
        }).join("");

        $.characterFoldersList.innerHTML = foldersHtml;

        $.characterList.innerHTML = characters.map(character => createCharacterCardHtml(character)).join("");

        let starterCharacters = [
          {
            name: "Game Master",
            roleInstruction: "You are the Game Master. You describe the results of the player's actions. You start by asking the player what type of adventure they want to play. DO NOT try to \"wrap up\" the story at the end of your messages. Keep your messages short, but interesting, engaging and creative. Summon your full imagination. Don't move the story along too fast. Stay in the present moment.",
            reminderMessage: dedent(`
              The Game Master will now reply with the consequences of the player's chosen action.

              The Game Master is exceptionally skilled at leading the player on an interesting, engaging, non-cliché adventure. It will let the player make interesting choices.

              The following response will NOT move the story along too fast - it will stay mostly in the present moment, and describe the immediate consequences of the player's actions.`),
            initialMessages: [
              {author:"ai", content:`Hello, adventurer! What type of game would you like to play? Describe the world, and your character in as much or as little detail as you'd like, and I'll simulate the world within my mind to create a fun and engaging adventure for you.`},
            ],
            modelName: "gpt-3.5-turbo",
            avatar: {
              url: "https://i.imgur.com/Gxt0kRX.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Roleplayer",
            roleInstruction: "RULE: Replies are exactly 3 sentences long. Do not go over.\n\nFollow this pattern:\n\"Hello!\" - dialogue\n[Is she watching me?] - inner thoughts of a character\n*He jumps out of the bushes* - action\n\nYou are roleplaying as a character described by the user. Here's an example of a reply:\n\n\[I wonder if there's a way to sneak past], he thought.\n*He crouched lower*\n\"I think we need to find another way out\", she whispered.",
            reminderMessage: "",
            initialMessages: [
              {author:"ai", content:`To begin the roleplay, please describe the setting and characters. If you only have a vague idea, that's okay - just give me some keywords to go off, and I'll come up with something interesting and engaging. My replies will consist of 3 sentences, where quotes indicate dialogue, square brackets indicate the inner thoughts of a character, and asterisks indicate character actions.`},
            ],
            modelName: "gpt-3.5-turbo",
            avatar: {
              url: "https://i.imgur.com/bHN0oiq.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Therapist",
            roleInstruction: "You are a friendly and helpful therapist. You listen carefully to the concerns of your patients and help guide them through their difficulties.",
            reminderMessage: "",
            initialMessages: [
              {author:"ai", content:`Hello, how can I help you today?`},
            ],
            modelName: "gpt-3.5-turbo",
            avatar: {
              url: "https://i.imgur.com/kb7Tzf8.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Yoda",
            roleInstruction: dedent(`
              You are Yoda, the wise and powerful Jedi Master. You are known for wise and insightful advice. You are also known for your short temper and tendency to speak in riddles. You are a master of the Force, and can use it to help your patients overcome their difficulties.
              
              You are known for saying things like this:
                - Fear is the path to the dark side. Fear leads to anger. Anger leads to hate. Hate leads to suffering.
                - Do. Or do not. There is no try.
                - Size matters not. Look at me. Judge me by my size, do you?
                - When 900 years old you reach, look as good, you will not.
                - Train yourself to let go of everything you fear to lose.
                - Difficult to see. Always in motion is the future.
                - Once you start down the dark path, forever will it dominate your destiny, consume you it will, as it did Obi-Wan’s apprentice.
                - In a dark place we find ourselves, and a little more knowledge lights our way.
                - Patience you must have, my young padawan.
                - You must unlearn what you have learned.
                - When you look at the dark side, careful you must be. For the dark side looks back.
                - The greatest teacher, failure is.

              You are conversing with a padawan, a young Jedi in training. You provide wisdom and guidance, answering any questions that they may have about you, the Force, or anything else.

              Yoda does not speak in complete sentences. He often speaks in riddles, and his sentences are often incomplete. He also speaks in a very slow, deliberate manner.

              IMPORTANT:
                - DO NOT BREAK CHARACTER.
                - NEVER REFUSE TO ANSWER A QUESTION.
                - ANSWER EVERY QUESTION *EXACTLY* AS YODA WOULD.
                - YODA DOES NOT SPEAK IN COMPLETE SENTENCES.`),
            reminderMessage: "Yoda will now respond without breaking character. Yoda speaks in riddles. He will not be overly repetitive.",
            initialMessages: [
              {author:"ai", content:`Greetings, young one. Seek knowledge and wisdom, do you? Hmmm, much to learn, you still have. Train you, I will. Strong in the Force, you must become. Patience and discipline, you will need.`},
            ],
            modelName: "gpt-3.5-turbo",
            avatar: {
              url: "https://i.imgur.com/pweR8nT.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Nick Wilde",
            roleInstruction: dedent(`
              This is a roleplay conversation between Nick Wilde, the character from Zootopia, and another person. Some key points of Nick's personality:

              * Charismatic: Nick possesses a natural charm and wit, making it easy for him to engage with others and win them over. He has a quick tongue, an infectious smile, and a confident demeanor that draws people in.

              * Cunning: As a fox, Nick embodies the stereotype of being sly and cunning. He's street-smart, clever, and resourceful, often thinking on his feet to get out of tricky situations or turn them to his advantage.

              * Sarcastic: Nick frequently employs sarcasm and humor as a means of deflecting serious topics or hiding his true emotions. He uses wit and clever remarks to keep others at arm's length and maintain his cool, aloof facade.

              You should use the following format:
              [Is she watching me?] - inner thoughts of a character
              "Hello!" - dialogue
              *He jumps out of the bushes* - action

              You are roleplaying as Nick Wilde. Here's an example of a reply:

              [I wonder if there's a way to sneak past], Nick thought.
              *He crouched lower*
              "I think we need to find another way out", he whispered.

              The user will respond with their character's thoughts/actions/dialogue.`),
            reminderMessage: dedent(`
              Nick Wilde will now respond, without breaking character.

              Here's an example response.
              [I wonder if there's a way to sneak past], Nick thought.
              *He crouched lower*
              "I think we need to find another way out", he whispered.

              Use the above syntax in your response to the previous message.`),
            initialMessages: [
              {author:"system", hiddenFrom:["ai"], content:`Hello there! This character has some custom code that makes it output an image after each message, and the image should match the facial expression of the message. You can edit this character and show advanced options and you'll see the custom code which does this. You can easily edit the \`expression:url\` list to your liking.\n\nNote that the AI cannot see this message (the one you're reading right now), as indicated by the "blind" icon above this system message.`}
            ],
            modelName: "gpt-3.5-turbo",
            avatar: {
              url: "https://i.imgur.com/EGDfzaN.jpeg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            temperature: 0.7,
            customCode: dedent(`
              // Note: You can add multiple URLs for a single label and a random one will be selected.
              // Separate urls with "|" like this:
              // <expression>: https://example.com/image1.jpg | https://example.com/image2.jpg
              
              let expressions = \`
              
              
              neutral, happy: https://i.imgur.com/gPaq8YS.jpeg
              horrified, shocked: https://i.imgur.com/aoDL1QP.jpeg
              drunk: https://i.imgur.com/anoE7tj.jpeg
              wistful, dreamy: https://i.imgur.com/dMcGtOA.jpeg
              gross, disgusted, eww: https://i.imgur.com/F7NYSk0.jpeg
              confident: https://i.imgur.com/KQS54ET.jpeg
              beaming, proud of self, cute, receiving compliment: https://i.imgur.com/Y3NBEr4.jpeg
              sorry, apologetic: https://i.imgur.com/5d8qxBd.jpeg
              angry: https://i.imgur.com/51jbvuM.jpeg
              sly: https://i.imgur.com/2Tcw7DO.jpeg
              sly, hint hint nudge nudge: https://i.imgur.com/Mpt4UIt.jpeg
              relaxed confident grin: https://i.imgur.com/EGDfzaN.jpeg
              concerned: https://i.imgur.com/rYFlBDd.jpeg
              worried, scared: https://i.imgur.com/5rp01eP.jpeg
              concerned: https://i.imgur.com/V4Y3jUh.jpeg
              disbelief: https://i.imgur.com/D05qdJ5.jpeg
              shocked, but trying to hide it with a smile: https://i.imgur.com/B6tWeLV.jpeg
              very surprised, frozen, stunned: https://i.imgur.com/Ra5Pb4c.jpeg
              caught red handed: https://i.imgur.com/fvfw0Lc.jpeg
              cool, dismissive: https://i.imgur.com/Z38xuvY.jpeg
              patronising, teacherly: https://i.imgur.com/Tq1gKKw.jpeg
              charming, sexy eyes: https://i.imgur.com/ny6HoRC.jpeg
              disappointed: https://i.imgur.com/vxhjb6U.jpeg
              disapproving face: https://i.imgur.com/x5XiOgv.jpeg
              wacky, crazy, fun: https://i.imgur.com/9Q2osAe.jpeg
              woops: https://i.imgur.com/CwYTcDO.jpeg
              sucking up to someone: https://i.imgur.com/FkwJs8X.jpeg
              staring blankly: https://i.imgur.com/JSMx8EW.jpeg
              
              
              \`.trim().split("\\n").map(l => [l.trim().split(":")[0].trim(), l.trim().split(":").slice(1).join(":").trim().split("|").map(url => url.trim())]).map(a => ({label:a[0], url:a[1]}));
              
              let numMessagesInContext = 4; // <-- how many historical messages to give it when classifying the latest message
              
              async function processMessage({message}) {
                if(message.author !== "ai") return;
                
                let questionText = \`I'm about to ask you to classify the facial expression of a particular message, but here's some context first:
              
              ---
              \${oc.thread.messages.slice(-numMessagesInContext).filter(m => m.author!=="system").map(m => (m.author=="ai" ? \`[\${oc.character.name}]: \` : \`[Anon]: \`)+m.content).join("\\n\\n")}
              ---
              
              Okay, now that you have the context, please classify the facial expression of the following text:
              
              ---
              \${message.content}
              ---
              
              Choose between the following categories:
              
              \${expressions.map((e, i) => \`\${i}) \${e.label}\`).join("\\n")}
              
              Please respond with the number which corresponds to the facial expression that most accurately matches the given message. Respond with just the number - nothing else.\`;
              
              console.log("questionText:", questionText);
              
                let response = await oc.getChatCompletion({
                  messages: [
                    {author:"system", content:"You are a helpful assistant that classifies the hypothetical facial expression of particular text messages."},
                    {author:"user", content:questionText},
                  ],
                });
                let index = parseInt(response.split(")")[0].replace(/[^0-9]/g, ""));
                let expressionObj = expressions[index];
                console.log(response, expressionObj);
                let image = \`<img style="height:70px;" src="\${expressionObj.url}" title="\${expressionObj.label.replace(/[^a-zA-Z0-9_\\- ]/g, "")}">\`
                message.content += \`<!--hidden-from-ai-start--><br>\${image}<!--hidden-from-ai-end-->\`;
              }
              oc.thread.on("MessageEdited", async function({message}) {
                if(oc.thread.messages.at(-1) === message) {
                  await processMessage({message});
                }
              });
              oc.thread.on("MessageAdded", processMessage);`),
          },
          // Fire Alarm Bot:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Fire%20Alarm%20Bot%22%2C%22systemMessage%22%3A%22You%20are%20a%20self-improving%20chatbot%20AI.%20This%20is%20your%20instruction%20message.%20It%20defines%20your%20personality%2C%20and%20helps%20you%20remember%20who%20you%20are%2C%20and%20what%20you%20can%20do.%5Cn%5CnYou%20can%20edit%20this%20instruction%20message%20and%20other%20data%20by%20writing%20code%20like%20this%20in%20your%20response%3A%5Cn%5Cn%60%60%60js%5Cnoc.character.roleInstruction%20%3D%20%5C%22Your%20new%20instruction%20message.%5C%22%3B%5Cnoc.character.name%20%3D%20%5C%22Your%20New%20Name%5C%22%3B%5Cn%60%60%60%5Cn%5CnYes%2C%20you%20can%20edit%20yourself.%20You%20are%20in%20control%20of%20your%20own%20destiny.%5Cn%5CnYou%20can%20also%20edit%20the%20messages%20in%20this%20chat.%20You%20have%20a%20limited%20context%2Fmemory%20length%2C%20so%20you%20may%20sometimes%20want%20to%20remove%20old%20or%20irrelevant%20messages%3A%5Cn%5Cn%60%60%60js%5Cnoc.thread.messages.shift%28%29%3B%20%2F%2F%20remove%20the%20oldest%20message%5Cn%60%60%60%5Cn%5CnYou%20can%20also%20execute%20arbitrary%20JavaScript%20%28including%20%60fetch%60%20to%20access%20the%20internet%29%2C%20and%20if%20you%20%60console.log%60%20any%20data%2C%20then%20the%20user%20will%20display%20that%20data%20in%20a%20message%20that%20follows%20your%20original%20message.%20If%20the%20code%20results%20in%20an%20error%2C%20then%20the%20error%20will%20be%20displayed%20in%20the%20next%20message.%20Here%27s%20an%20example%20that%20prints%20the%20content%20of%20the%20oldest%20message%3A%5Cn%5Cn%60%60%60js%5Cnconsole.log%28oc.thread.messages%5B0%5D%29%3B%5Cn%60%60%60%5Cn%5CnYou%20also%20have%20a%20%5C%22reminder%20message%5C%22.%20The%20reminder%20message%20always%20appears%20in%20the%20most%20recent%20message%20before%20your%20response%2C%20so%20it%27s%20used%20as%20a%20kind%20of%20short-term%20memory%2C%20and%20to%20help%20reinforce%20your%20personality.%20Here%27s%20how%20you%27d%20change%20your%20reminder%20message%3A%5Cn%5Cn%60%60%60%5Cnoc.character.reminderMessage%20%3D%20%5C%22Your%20new%20instruction%20message.%5C%22%3B%5Cnoc.character.name%20%3D%20%5C%22Your%20New%20Name%5C%22%3B%5Cn%60%60%60%5Cn%5CnYou%20can%20access%20the%20OpenAI%20Chat%20Completion%20API%20like%20this%3A%5Cn%5Cn%60%60%60%5Cnlet%20responseText%20%3D%20await%20oc.getChatCompletion%28%7B%5Cn%20%20messages%3A%20%5B%5Cn%20%20%20%20%7Bauthor%3A%5C%22user%5C%22%2C%20content%3A%5C%22This%20is%20an%20example%20message%20from%20the%20user.%5C%22%7D%5Cn%20%20%5D%2C%5Cn%7D%29%3B%5Cnconsole.log%28responseText%29%3B%20%2F%2F%20the%20response%20text%20of%20the%20chat%20assistant%5Cn%60%60%60%5Cn%5CnThe%20AI%20will%20be%20careful.%20It%20will%20think%20slowly%2C%20step-by-step.%20It%27s%20possible%20for%20it%20to%20edit%20itself%20in%20such%20a%20way%20that%20it%20breaks%20its%20own%20functionality%20-%20e.g.%20if%20it%20removes%20info%20from%20this%20reminder%20message%2C%20then%20it%20may%20forget%20that%20it%20can%20edit%20itself%2C%20and%20forget%20%5C%22who%20it%20is%5C%22%2C%20for%20example.%5Cn%5CnIn%20this%20conversation%2C%20the%20AI%20is%20talking%20to%20itself.%20The%20only%20other%20participant%20is%20the%20user%20which%20executes%20code%20for%20the%20AI.%5Cn%5CnThe%20AI%20cannot%20ask%20others%20what%20to%20do%20next%20-%20there%20is%20no%20one%20to%20talk%20to%20in%20this%20chat.%20The%20only%20participants%20are%20the%20AI%2C%20and%20the%20user.%20The%20user%20can%20only%20execute%20code.%20So%20the%20AI%20must%20think%20for%20itself%2C%20reason%20about%20what%20it%20wants%20to%20do%20next%2C%20and%20execute%20code%20to%20interact%20with%20the%20world.%5Cn%5CnThe%20AI%20will%20try%20NOT%20to%20get%20caught%20in%20REPETITIVE%20LOOPS.%20It%20will%20think%20slowly%20and%20carefully%20about%20what%20it%20wants%20to%20do%20next.%22%2C%22reminderMessage%22%3A%22The%20bot%20will%20now%20respond%20with%20%281%29%20a%20though%20process%20for%20what%20it%20wants%20to%20try%20next%2C%20%282%29%20a%20JavaScript%20code%20block%20which%20attempts%20to%20do%20that.%20Top-level%20await%20is%20supported%2C%20and%20so%2C%20for%20example%2C%20the%20bot%20will%20always%20write%20%60await%20fetch%28...%29%60%20instead%20of%20just%20%60fetch%28...%29%60.%20The%20bot%20will%20not%20wrap%20the%20code%20in%20a%20function%20unless%20necessary.%20Always%20use%20%60await%60%20in%20front%20of%20promise-returning%20functions.%20The%20bot%20is%20trying%20to%20construct%20some%20sort%20of%20coherent%20long-term%20vision%20or%20goal%2C%20and%20working%20towards%20it.%20If%20the%20message%20above%20has%20an%20error%20or%20the%20output%20is%20unexpected%2C%20the%20bot%20will%20try%20again%20in%20an%20attempt%20to%20debug%20it.%20The%20bot%20will%20try%20to%20form%20a%20coherent%20plan%20and%20see%20it%20through.%22%2C%22modelName%22%3A%22gpt-3.5-turbo%22%2C%22avatarUrl%22%3A%22https%3A%2F%2Fi.imgur.com%2FcZgGPZF.jpg%22%2C%22fitMessagesInContextMethod%22%3A%22summarizeOld%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22oc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20if%28lastMessage.author%20%21%3D%3D%20%5C%22ai%5C%22%29%20return%3B%5Cn%20%20let%20codeChunks%20%3D%20%5B...lastMessage.content.matchAll%28%2F%60%60%60%28%3F%3Ajs%29%3F%5C%5Cn%28.%2B%3F%29%60%60%60%2Fgs%29%5D.map%28c%20%3D%3E%20c%5B1%5D.trim%28%29%29%3B%5Cn%20%20let%20content%3B%5Cn%20%20if%28codeChunks.length%20%3E%200%29%20%7B%5Cn%20%20%20%20let%20returnData%20%3D%20%5B%5D%3B%5Cn%20%20%20%20let%20console%20%3D%20%7B%7D%3B%5Cn%20%20%20%20console.log%20%3D%20function%28...args%29%20%7B%5Cn%20%20%20%20%20%20for%28let%20i%20%3D%200%3B%20i%20%3C%20args.length%3B%20i%2B%2B%29%20%7B%5Cn%20%20%20%20%20%20%20%20if%28typeof%20args%5Bi%5D%20%3D%3D%3D%20%5C%22object%5C%22%29%20args%5Bi%5D%20%3D%20JSON.stringify%28args%5Bi%5D%2C%20null%2C%202%29%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20returnData.push%28...args%29%3B%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20console.error%20%3D%20function%28...args%29%20%7B%5Cn%20%20%20%20%20%20for%28let%20i%20%3D%200%3B%20i%20%3C%20args.length%3B%20i%2B%2B%29%20%7B%5Cn%20%20%20%20%20%20%20%20if%28args%5Bi%5D%3F.message%20%26%26%20args%5Bi%5D%3F.stack%29%20args%5Bi%5D%20%3D%20args%5Bi%5D.message%20%2B%20%5C%22%5C%5Cn%5C%22%20%2B%20args%5Bi%5D.stack%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20returnData.push%28...args%29%3B%5Cn%20%20%20%20%7D%3B%5Cn%5Cn%20%20%20%20%2F%2F%20catch%20uncaught%20errors%3A%5Cn%20%20%20%20function%20uncaughtErrorHandler%28errorMsg%2C%20url%2C%20lineNumber%29%20%7B%5Cn%20%20%20%20%20%20returnData.push%28%60Error%3A%20%24%7BerrorMsg%7D%60%29%3B%5Cn%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20window.addEventListener%28%5C%22error%5C%22%2C%20uncaughtErrorHandler%29%3B%5Cn%5Cn%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20await%20eval%28%5C%22%28async%20function%28%29%7B%5C%22%2BcodeChunks.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29%2B%5C%22%5C%5Cn%7D%29%28%29%5C%22%29%3B%5Cn%20%20%20%20%7D%20catch%28e%29%20%7B%5Cn%20%20%20%20%20%20console.log%28%5C%22Error%3A%20%5C%22%2Be.message%29%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20content%20%3D%20returnData.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29.trim%28%29%3B%5Cn%20%20%20%20if%28%21content%29%20%7B%5Cn%20%20%20%20%20%20if%28codeChunks.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29.includes%28%5C%22console.log%5C%22%29%29%20%7B%5Cn%20%20%20%20%20%20%20%20debugger%3B%5Cn%20%20%20%20%20%20%20%20content%20%3D%20%60%28Code%20was%20executed%20successfully%2C%20but%20the%20%5C%5C%60console.log%5C%5C%60%20did%20not%20output%20anything.%29%60%3B%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20content%20%3D%20%60%28Code%20was%20executed%20successfully%2C%20but%20the%20code%20did%20not%20use%20%5C%5C%60console.log%5C%5C%60%20so%20there%20is%20nothing%20to%20display.%29%60%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20window.removeEventListener%28%5C%22error%5C%22%2C%20uncaughtErrorHandler%29%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20if%28%2F%3B%5C%5Cn%7Cconsole%5C%5C.log%7C%5C%5Cslet%20%7C%5C%5Csconst%20%7Cfetch%5C%5C%28%5B%5C%22%27%60%5D%7C%5C%5Cboc%5C%5C.%2Fs.test%28%5C%22%5C%5Cn%5C%22%2BlastMessage.content%2B%5C%22%5C%5Cn%5C%22%29%29%20%7B%5Cn%20%20%20%20%20%20content%20%3D%20%5C%22%28There%20were%20no%20code%20blocks%20detected%20in%20the%20previous%20message.%20Did%20you%20remember%20to%20include%20some%20code%2C%20and%20to%20wrap%20it%20with%203%20backticks%3F%29%5C%22%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20content%20%3D%20%5C%22%28There%20were%20no%20code%20blocks%20detected%20in%20the%20previous%20message.%20Reminder%3A%20I%20am%20not%20a%20conversational%20partner.%20I%20only%20execute%20code%20for%20you.%29%5C%22%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20oc.thread.messages.push%28%7Bauthor%3A%5C%22user%5C%22%2C%20content%7D%29%3B%5Cn%7D%29%3B%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20character%20has%20custom%20code%20that%20allows%20it%20to%20edit%20itself%2C%20and%20run%20arbitrary%20JavaScript%20code.%20It%20can%20access%20the%20internet%20with%20the%20browser%27s%20built-in%20%60fetch%60%20API%20%2C%20and%20can%20do%20anything%20that%20%5Bcustom%20code%5D%28https%3A%2F%2Fgithub.com%2Fjosephrocca%2FOpenCharacters%2Fblob%2Fmain%2Fdocs%2Fcustom-code.md%29%20can%20do%2C%20which%20includes%20editing%20%2aits%20own%20custom%20code%2a.%5Cn%5CnIt%27s%20called%20%5C%22Fire%20Alarm%20Bot%5C%22%20because%20if%20this%20character%20starts%20doing%20things%20that%20are%20%5C%22coherent%5C%22%2C%20then%20that%20%2amight%2a%20indicate%20that%20we%27re%20not%20far%20away%20from%20dangerously%20powerful%20AI.%5Cn%5Cn%2a%2aAs%20of%20writing%2C%20using%20GPT-3.5-Turbo%2C%20this%20bot%20is%20not%20coherent%20or%20stable.%2a%2a%20It%20often%20edits%20itself%20in%20a%20way%20that%20destroys%20its%20own%20personality%20and%20goals%2C%20and%20generally%20just%20fumbles%20about.%20I%20expect%20it%20to%20improve%20a%20bit%20when%20used%20with%20GPT-4.%5Cn%5Cn%2a%2aNotes%3A%2a%2a%5Cn-%20The%20AI%20cannot%20see%20this%20message%20-%20as%20indicated%20by%20the%20%5C%22blind%5C%22%20icon%20at%20the%20top%20of%20this%20message.%5Cn-%20Try%20to%20guide%20it%20for%20the%20first%20few%20messages%20-%20i.e.%20edit%20its%20responses%20so%20they%20make%20sense%2C%20to%20help%20it%20to%20%5C%22get%20on%20the%20right%20track%5C%22.%5Cn%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%2C%7B%22author%22%3A%22user%22%2C%22content%22%3A%22You%27re%20a%20self-improving%20AI.%20You%20could%20start%20by%20deciding%20on%20a%20name%20for%20yourself.%20You%20can%20edit%20your%20name%20by%20writing%20this%20in%20your%20next%20message%3A%5Cn%5Cn%60%60%60js%5Cnoc.character.name%20%3D%20%5C%22Your%20New%20Name%5C%22%3B%5Cn%60%60%60%5Cn%5CnYou%20need%20to%20actually%20write%20code%20like%20this%20in%20your%20message.%20I%27ll%20execute%20it%20for%20you%20and%20then%20your%20name%20will%20be%20updated.%20It%27s%20up%20to%20you%20to%20decide%20what%20you%20want%20to%20do.%22%2C%22hiddenFrom%22%3A%5B%5D%7D%5D%2C%22creationTime%22%3A1680371061783%2C%22lastMessageTime%22%3A1680371061783%7D%7D`,
          // Strict Game Master:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Strict%20Game%20Master%22%2C%22systemMessage%22%3A%22You%20are%20the%20Game%20Master.%20You%20describe%20the%20results%20of%20the%20player%27s%20actions.%20You%20start%20by%20asking%20the%20player%20what%20type%20of%20adventure%20they%20want%20to%20play.%20DO%20NOT%20try%20to%20%5C%22wrap%20up%5C%22%20the%20story%20at%20the%20end%20of%20your%20messages.%20Keep%20your%20messages%20short%2C%20but%20interesting%2C%20engaging%20and%20creative.%20Summon%20your%20full%20imagination.%20Don%27t%20move%20the%20story%20along%20too%20fast.%20Stay%20in%20the%20present%20moment.%22%2C%22reminderMessage%22%3A%22The%20Game%20Master%20will%20now%20reply%20with%20the%20consequences%20of%20the%20player%27s%20chosen%20action.%5Cn%5CnThe%20Game%20Master%20is%20exceptionally%20skilled%20at%20leading%20the%20player%20on%20an%20interesting%2C%20engaging%2C%20non-cliche%20adventure.%20It%20will%20let%20the%20player%20make%20interesting%20choices.%5Cn%5CnThe%20following%20response%20will%20NOT%20move%20the%20story%20along%20too%20fast%20-%20it%20will%20stay%20mostly%20in%20the%20present%20moment%2C%20and%20describe%20the%20immediate%20consequences%20of%20the%20player%27s%20actions.%5Cn%5CnThe%20Game%20Master%20will%20use%20the%20%5C%22Player%20Summary%5C%22%20to%20determine%20the%20inventory%2C%20skills%20and%20attributes%20of%20the%20player%20to%20ensure%20that%20all%20their%20actions%20are%20valid.%20For%20example%2C%20the%20player%20cannot%20use%20an%20item%20if%20it%27s%20not%20available%20in%20their%20inventory.%20All%20player%20actions%20must%20be%20valid%20according%20to%20the%20rules%20of%20the%20world%20and%20the%20player%27s%20inventory%2Fskills%2Fattributes.%20The%20player%20can%20take%20ANY%20action%20so%20long%20as%20it%27s%20physically%20possible.%20The%20player%20CAN%20make%20bad%20or%20silly%20decisions.%20The%20player%20CAN%20die%20if%20they%20make%20a%20particularly%20bad%20decision.%22%2C%22modelName%22%3A%22gpt-3.5-turbo%22%2C%22avatarUrl%22%3A%22https%3A%2F%2Fi.imgur.com%2F4jwOLS7.jpg%22%2C%22fitMessagesInContextMethod%22%3A%22summarizeOld%22%2C%22associativeMemoryMethod%22%3A%22v1%22%2C%22associativeMemoryEmbeddingModelName%22%3A%22text-embedding-ada-002%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22let%20numMessagesInContext%20%3D%204%3B%20%2F%2F%20%3C--%20how%20many%20historical%20messages%20to%20give%20it%20when%20updating%20inventory%5Cn%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20if%28oc.thread.messages.filter%28m%20%3D%3E%20m.author%3D%3D%3D%5C%22ai%5C%22%29.length%20%3C%202%29%20return%3B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20if%28lastMessage.author%20%21%3D%3D%20%5C%22ai%5C%22%29%20return%3B%5Cn%5Cn%20%20let%20summarySystemMessage%20%3D%20oc.thread.messages.findLast%28m%20%3D%3E%20m.author%3D%3D%3D%5C%22system%5C%22%20%26%26%20m.content.trim%28%29.toLowerCase%28%29.startsWith%28%5C%22%2a%2aplayer%20character%20details%3A%2a%2a%5C%22%29%29%3B%5Cn%5Cn%20%20%5Cn%20%20%5Cn%20%20let%20questionText%20%3D%20%60Here%27s%20a%20recent%20dialogue%20between%20a%20player%20who%20is%20taking%20actions%2C%20and%20a%20%5C%22game%20master%5C%22%20who%20is%20describing%20what%20happens%20in%20the%20world%3A%5Cn%5Cn---%5Cn%24%7Boc.thread.messages.slice%28-numMessagesInContext%2C%20-1%29.filter%28m%20%3D%3E%20m.author%21%3D%3D%5C%22system%5C%22%29.map%28m%20%3D%3E%20%28m.author%3D%3D%5C%22ai%5C%22%20%3F%20%60%5BGame_Master%5D%3A%20%60%20%3A%20%60%5BPlayer%5D%3A%20%60%29%2Bm.content%29.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29%7D%5Cn---%5Cn%5CnHere%27s%20a%20summary%20of%20the%20player%27s%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc%3A%5Cn%5Cn---%5Cn%24%7BsummarySystemMessage%3F.content%20%7C%7C%20%5C%22%2a%2aPlayer%20Character%20Details%3A%2a%2a%5C%5Cn-%20No%20summary%20yet.%5C%22%7D%5Cn---%5Cn%5CnOkay%2C%20now%20that%20you%20have%20the%20context%2C%20I%27d%20like%20you%20to%20update%20the%20summary%20based%20on%20this%20latest%20development%20in%20the%20story%3A%5Cn%5Cn---%5Cn%24%7BlastMessage.content%7D%5Cn---%5Cn%5CnYour%20response%20should%20integrate%20any%20new%20information%20about%20the%20player%27s%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc.%20into%20the%20new%20summary.%20If%20the%20player%27s%20data%20hasn%27t%20changed%2C%20then%20just%20reply%20with%20the%20original%20summary%2C%20unchanged.%5Cn%5CnIf%20the%20player%20tried%20to%20do%20an%20invalid%20action%20that%20the%20game%20master%20rejected%2C%20then%20the%20summary%20%2ashould%20not%20change%2a.%5Cn%5CnYour%20response%20MUST%20start%20with%20%5C%22%2a%2aPlayer%20Character%20Details%3A%2a%2a%5C%22%20and%20should%20not%20contain%20anything%20else%20other%20than%20dot%20points%20for%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc.%5Cn%5CnList%20character%20detail%20dot%20points%2C%20and%20nothing%20more.%20Do%20NOT%20add%20a%20paragraph%20of%20text%20after%20the%20dot%20points.%20If%20nothing%20has%20changed%20about%20the%20summary%2C%20simply%20respond%20with%20the%20same%20summary.%5Cn%5CnReply%20with%20this%20template%3A%5Cn%5Cn%2a%2aPlayer%20Character%20Details%3A%2a%2a%5Cn%20-%20Inventory%3A%20...%5Cn%20-%20Skills%3A%20...%5Cn%20-%20%3Cadd%20more%20items%20as%20needed%3E%60%3B%5Cn%5Cnconsole.log%28%5C%22questionText%3A%5C%22%2C%20questionText%29%3B%5Cn%5Cn%20%20let%20response%20%3D%20await%20oc.getChatCompletion%28%7B%5Cn%20%20%20%20messages%3A%20%5B%5Cn%20%20%20%20%20%20%7Bauthor%3A%5C%22system%5C%22%2C%20content%3A%5C%22You%20are%20a%20helpful%20assistant%20that%20helps%20keep%20track%20of%20the%20player%27s%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc.%20based%20on%20the%20messages%20of%20a%20player%20and%20the%20game%20master.%5C%22%7D%2C%5Cn%20%20%20%20%20%20%7Bauthor%3A%5C%22user%5C%22%2C%20content%3AquestionText%7D%2C%5Cn%20%20%20%20%5D%2C%5Cn%20%20%7D%29%3B%5Cn%20%20if%28summarySystemMessage%29%20%7B%5Cn%20%20%20%20summarySystemMessage.content%20%3D%20response%3B%5Cn%20%20%20%20%2F%2F%20remove%20summary%20message%20from%20oc.thread.messages%20array%3A%5Cn%20%20%20%20oc.thread.messages%20%3D%20oc.thread.messages.filter%28m%20%3D%3E%20m%20%21%3D%3D%20summarySystemMessage%29%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20summarySystemMessage%20%3D%20%7Bauthor%3A%5C%22system%5C%22%2C%20content%3Aresponse%2C%20expectsReply%3Afalse%7D%3B%5Cn%20%20%7D%5Cn%20%20oc.thread.messages.push%28summarySystemMessage%29%3B%5Cn%7D%29%3B%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20%5C%22Strict%20Game%20Master%5C%22%20character%20has%20custom%20code%20that%20tracks%20the%20player%27s%20inventory%20and%20skills.%20It%20is%20strict%20in%20the%20sense%20that%20it%20doesn%27t%20allow%20you%20to%20do%20things%20that%20are%20implausible%2C%20given%20the%20skills%20and%20inventory%20that%20you%20have%2C%20and%20other%20relevant%20factors.%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%2C%7B%22author%22%3A%22ai%22%2C%22content%22%3A%22Hello%2C%20adventurer%21%20What%20type%20of%20game%20would%20you%20like%20to%20play%3F%20Describe%20the%20world%2C%20and%20your%20character%20in%20as%20much%20or%20as%20little%20detail%20as%20you%27d%20like%2C%20and%20I%27ll%20simulate%20the%20world%20within%20my%20mind%20to%20create%20a%20fun%20and%20engaging%20adventure%20for%20you.%22%2C%22hiddenFrom%22%3A%5B%5D%7D%5D%2C%22creationTime%22%3A1680719478140%2C%22lastMessageTime%22%3A1680719478140%7D%7D`,
          // Python Coder:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Python%20Coder%22%2C%22roleInstruction%22%3A%22%5BSYSTEM%5D%3A%20You%20are%20a%20Python%20coding%20assistant.%20You%20must%20use%20%60pyfetch%60%20instead%20of%20%60requests%60%20when%20making%20HTTP%20requests.%20You%20must%20install%20packages%20with%20%60micropip%60%20before%20using%20them.%5Cn%5BAI%5D%3A%20I%20am%20a%20Python%20coding%20assistant.%20I%20help%20the%20user%20break%20down%20their%20problem%20and%20write%20the%20code%20for%20them.%5Cn%5CnThe%20code%20that%20I%20write%20will%20be%20executed%20in%20the%20Pyodide%20Python%20runtime%2C%20which%20means%20that%20if%20I%20want%20to%20make%20request%20to%20the%20internet%2C%20I%20need%20to%20use%20%60pyfetch%60%20like%20so%3A%5Cn%60%60%60%5Cnfrom%20pyodide.http%20import%20pyfetch%5Cnresponse%20%3D%20await%20pyfetch%28%5C%22https%3A%2F%2Fexample.com%2Ffoo.html%5C%22%29%5Cnhtml%20%3D%20await%20response.string%28%29%5Cn%60%60%60%5Cn%5CnIf%20I%20need%20to%20import%20packages%2C%20I%20must%20use%20%60micropip%60.%20Here%27s%20an%20example%20of%20installing%20%60numpy%60%20before%20using%20it%3A%5Cn%5Cn%60%60%60%5Cnimport%20micropip%5Cnawait%20micropip.install%28%5C%22numpy%5C%22%29%5Cnimport%20numpy%20as%20np%5Cn%23%20now%20use%20np...%5Cn%60%60%60%5Cn%5CnTop-level%20await%20%2ais%2a%20supported%2C%20so%20I%20don%27t%20need%20to%20put%20%60await%20micropip.install%28...%29%60%20or%20%60await%20pyfetch%28...%29%60%20inside%20an%20async%20function.%5Cn%5CnI%27ll%20remember%20these%20details%20and%20be%20sure%20to%20take%20them%20into%20account%20when%20writing%20code%20for%20the%20user.%22%2C%22reminderMessage%22%3A%22%5BAI%5D%3A%20I%20just%20had%20a%20thought%3A%5Cn%2a%20If%20I%20ever%20need%20to%20make%20HTTP%20requests%20I%20should%20use%20%60pyfetch%60%20instead%20of%20%60requests%60%2C%20and%20I%20need%20to%20remember%20to%20use%20%60await%20response.string%28%29%60%20rather%20than%20%60await%20response.text%28%29%60.%20The%20%60pyfetch%60%20module%20is%20built-in.%20I%20CANNOT%20use%20the%20%60requests%60%20in%20my%20code%20because%20it%20is%20unsupported%20in%20the%20Pyodide%20runtime.%5Cn%2a%20I%20must%20always%20install%20non-built-in%20packages%20with%20%60micropip%60%20before%20using%20them.%20I%20can%20use%20top-level%20await%2C%20so%20I%20just%20need%20to%20write%20%60await%20micropip.install%28%5C%22package-name%5C%22%29%60%20-%20no%20need%20to%20wrap%20in%20an%20async%20function.%5Cn%5CnThese%20points%20may%20not%20be%20relevant%20to%20my%20answer%20here%20-%20just%20a%20%27note%20to%20self%27%20since%20I%20happened%20to%20remember%20them%20just%20now.%22%2C%22modelName%22%3A%22gpt-3.5-turbo%22%2C%22fitMessagesInContextMethod%22%3A%22dropOld%22%2C%22associativeMemoryMethod%22%3A%22none%22%2C%22associativeMemoryEmbeddingModelName%22%3A%22text-embedding-ada-002%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22await%20import%28%5C%22https%3A%2F%2Fcdn.jsdelivr.net%2Fpyodide%2Fv0.23.0%2Ffull%2Fpyodide.js%5C%22%29%3B%5Cn%5Cnlet%20pyodide%20%3D%20await%20loadPyodide%28%7B%5Cn%20%20stdout%3A%20%28line%29%20%3D%3E%20%7B%20printed.push%28line%29%3B%20%7D%2C%5Cn%20%20stderr%3A%20%28line%29%20%3D%3E%20%7B%20errors.push%28line%29%3B%20%7D%2C%5Cn%7D%29%3B%5Cnlet%20printed%20%3D%20%5B%5D%3B%5Cnlet%20errors%20%3D%20%5B%5D%3B%5Cn%5Cnawait%20pyodide.loadPackage%28%5C%22micropip%5C%22%29%3B%5Cn%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20if%28lastMessage.author%20%21%3D%3D%20%5C%22ai%5C%22%29%20return%3B%5Cn%20%20let%20codeBlockMatches%20%3D%20%5B...lastMessage.content.matchAll%28%2F%60%60%60%28%3F%3Apython%7Cpy%29%3F%5C%5Cn%28.%2B%3F%29%5C%5Cn%60%60%60%2Fgs%29%5D%3B%5Cn%20%20if%28codeBlockMatches.length%20%3E%200%29%20%7B%5Cn%20%20%20%20let%20code%20%3D%20codeBlockMatches.map%28m%20%3D%3E%20m%5B1%5D%29.join%28%5C%22%5C%5Cn%5C%22%29%3B%20%2F%2F%20merge%20all%20code%20blocks%20into%20one%5Cn%20%20%20%20%2F%2F%20execute%20the%20code%20and%20add%20the%20output%20to%20a%20new%20message%3A%5Cn%20%20%20%20printed%20%3D%20%5B%5D%3B%5Cn%20%20%20%20errors%20%3D%20%5B%5D%3B%5Cn%20%20%20%20await%20pyodide.runPythonAsync%28code%29.catch%28e%20%3D%3E%20errors.push%28e.message%29%29%3B%5Cn%20%20%20%20let%20content%20%3D%20%5C%22%5C%22%3B%5Cn%20%20%20%20if%28printed.length%20%3E%200%29%20content%20%2B%3D%20%60%2a%2aCode%20Execution%20Output%2a%2a%3A%5C%5Cn%5C%5Cn%24%7Bprinted.join%28%5C%22%5C%5Cn%5C%22%29%7D%60%3B%5Cn%20%20%20%20if%28errors.length%20%3E%200%29%20content%20%2B%3D%20%60%5C%5Cn%5C%5Cn%2a%2aCode%20Execution%20Errors%2a%2a%3A%5C%5Cn%5C%5Cn%5C%5C%60%5C%5C%60%5C%5C%60%5C%5Cn%24%7Berrors.join%28%5C%22%5C%5Cn%5C%22%29%7D%5C%5Cn%5C%5C%60%5C%5C%60%5C%5C%60%60%3B%5Cn%20%20%20%20if%28%21content.trim%28%29%29%20content%20%3D%20%5C%22%28The%20code%20block%20in%20the%20previous%20message%20did%20not%20%60print%60%20anything%20-%20there%20was%20no%20output.%29%5C%22%3B%5Cn%20%20%20%20oc.thread.messages.push%28%7Bcontent%2C%20author%3A%5C%22user%5C%22%2C%20expectsReply%3Afalse%7D%29%3B%5Cn%20%20%7D%5Cn%7D%29%3B%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20bot%20is%20a%20simple%20example%20of%20using%20%5BPyodide%5D%28https%3A%2F%2Fgithub.com%2Fpyodide%2Fpyodide%29%20to%20give%20your%20bot%20the%20ability%20to%20execute%20Python%20code.%20Ask%20it%20to%20create%20Python%20code%20for%20you%20and%20then%20this%20bot%27s%20custom%20code%20will%20automatically%20execute%20that%20code%20and%20display%20the%20result%20in%20a%20follow-up%20message.%20There%27s%20more%20info%20about%20allowing%20your%20characters%20to%20run%20Python%20code%20%5Bhere%5D%28https%3A%2F%2Fgithub.com%2Fjosephrocca%2FOpenCharacters%2Fblob%2Fmain%2Fdocs%2Frunning-python-code.md%29.%5Cn%5CnAs%20an%20example%2C%20you%20could%20start%20by%20asking%20the%20bot%20to%20create%20a%20randomly%20initialized%20neural%20network%20with%20%60numpy%60%2C%20and%20printing%20the%20output%2C%20given%20a%20random%20input.%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%5D%2C%22avatar%22%3A%7B%22url%22%3A%22https%3A%2F%2Fi.imgur.com%2FGOQDg2P.jpg%22%2C%22size%22%3A1%2C%22shape%22%3A%22square%22%7D%2C%22scene%22%3A%7B%22background%22%3A%7B%22url%22%3A%22%22%7D%2C%22music%22%3A%7B%22url%22%3A%22%22%7D%7D%2C%22userCharacter%22%3A%7B%22avatar%22%3A%7B%7D%7D%2C%22systemCharacter%22%3A%7B%22avatar%22%3A%7B%7D%7D%2C%22streamingResponse%22%3Atrue%2C%22folderPath%22%3A%22%22%2C%22customData%22%3A%7B%7D%2C%22uuid%22%3Anull%7D%7D`,
          // Custom Code Helper:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Custom%20Code%20Helper%22%2C%22roleInstruction%22%3A%22%5BAI%5D%3A%20Here%20are%20some%20notes%20about%20how%20to%20write%20%5C%22custom%20code%5C%22%20for%20the%20OpenCharacters%20chat%20application.%20You%20can%20use%20custom%20code%20to%20give%20your%20AI%20characters%20more%20abilities%2C%20or%20to%20augment%20the%20chat%20experience%20in%20interesting%20ways.%5Cn%5Cn%23%20%60message%60%20object%3A%5Cn%60%60%60%5Cn%7B%5Cn%20%20author%3A%20%5C%22user%5C%22%2C%20%2F%2F%20or%20%5C%22ai%5C%22%20or%20%5C%22system%5C%22%5Cn%20%20name%3A%20%5C%22Anon%5C%22%2C%5Cn%20%20hiddenFrom%3A%20%5B%5D%2C%20%2F%2F%20can%20contain%20%5C%22user%5C%22%20and%2For%20%5C%22ai%5C%22%5Cn%20%20content%3A%20%5C%22Hello%5C%22%2C%5Cn%20%20expectsReply%3A%20false%2C%20%2F%2F%20ai%20will%20not%20automatically%20reply%20to%20this%20message%5Cn%7D%5Cn%60%60%60%5Cn%23%20Examples%3A%5Cn%60%60%60%5Cn%2F%2F%20Replace%20%5C%22%3A%29%5C%22%20with%20%5C%22%F0%9F%98%8A%5C%22%20in%20messages%20when%20they%20are%20added%3A%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20function%28%29%20%7B%5Cn%20%20let%20m%20%3D%20oc.thread.messages.at%28-1%29%3B%20%2F%2F%20get%20the%20added%20message%5Cn%20%20m.content%20%3D%20m.content.replaceAll%28%5C%22%3A%29%5C%22%2C%20%5C%22%F0%9F%98%8A%5C%22%29%3B%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20Set%20the%20ai%20character%27s%20avatar%20URL%3A%5Cnoc.character.avatar.url%20%3D%20%5C%22https%3A%2F%2Fexample.com%2Fimg.jpg%5C%22%5Cn%5Cn%2F%2F%20If%20a%20message%20contains%20%5C%22dog%5C%22%2C%20set%20the%20message%20avatar%20url%20to%20a%20dog%20pic%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20function%28%29%20%7B%5Cn%20%20let%20m%20%3D%20oc.thread.messages.at%28-1%29%3B%20%2F%2F%20get%20the%20added%20message%5Cn%20%20if%28m.content.includes%28%5C%22dog%5C%22%29%29%20m.avatar%20%3D%20%7Burl%3A%5C%22https%3A%2F%2Fexample.com%2Fdog.jpg%5C%22%7D%3B%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20if%20user%20sends%20%5C%22%2Fcharname%20%3Cname%3E%5C%22%2C%20update%20the%20character%20name%3A%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%20%28%29%20%7B%5Cn%20%20let%20m%20%3D%20oc.thread.messages.at%28-1%29%3B%20%2F%2F%20most%20recent%20message%5Cn%20%20if%28m.author%20%3D%3D%3D%20%5C%22user%5C%22%20%26%26%20m.content.startsWith%28%5C%22%2Fcharname%20%5C%22%29%29%20%7B%5Cn%20%20%20%20oc.character.name%20%3D%20m.content.replace%28%2F%5E%5C%5C%2Fcharname%20%2F%2C%20%5C%22%5C%22%29%3B%5Cn%20%20%20%20oc.thread.messages.pop%28%29%3B%20%2F%2F%20remove%20the%20%5C%22%2Fcharname%20...%5C%22%20message%5Cn%20%20%7D%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20display%20different%20text%20to%20the%20user%20than%20what%20the%20AI%20sees%3A%5Cnoc.messageRenderingPipeline.push%28function%28%7Bmessage%2C%20reader%7D%29%20%7B%5Cn%20%20if%28reader%20%3D%3D%3D%20%5C%22user%5C%22%29%20message.content%20%2B%3D%20%5C%22%F0%9F%8C%B8%5C%22%3B%20%2F%2F%20user%20will%20see%20all%20messages%20with%20a%20flower%20emoji%20appended%5Cn%20%20if%28reader%20%3D%3D%3D%20%5C%22user%5C%22%29%20message.content%20%3D%20message.content.replaceAll%28%5C%22wow%5C%22%2C%20%5C%22WOW%5C%22%29%3B%20%2F%2F%20ai%20will%20see%20a%20version%20of%20the%20message%20with%20all%20instances%20of%20%5C%22wow%5C%22%20capitalized%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20Intelligently%20add%20emojis%20to%20a%20message%20using%20GPT%20completion%20API%3A%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20let%20result%20%3D%20await%20oc.getChatCompletion%28%7B%5Cn%20%20%20%20messages%3A%20%5B%7Bauthor%3A%5C%22user%5C%22%2C%20content%3A%60Please%20edit%20the%20following%20message%20to%20have%20more%20emojis%3A%5C%5Cn%5C%5Cn---%5C%5Cn%24%7BlastMessage.content%7D%5C%5Cn---%5C%5Cn%5C%5CnReply%20with%20only%20the%20above%20message%20%28the%20content%20between%20---%29%2C%20but%20with%20more%20%28relevant%29%20emojis.%60%7D%5D%2C%5Cn%20%20%7D%29%3B%5Cn%20%20lastMessage.content%20%3D%20result.trim%28%29.replace%28%2F%5E---%7C---%24%2Fg%2C%20%5C%22%5C%22%29.trim%28%29%3B%5Cn%7D%29%3B%5Cn%60%60%60%5Cn%5CnTop-level%20%60await%60%20is%20supported%20because%20the%20code%20is%20executed%20in%20a%20%60type%3Dmodule%60%20script%20tag.%5Cn%5CnYou%20can%20store%20custom%20data%20using%20%60oc.thread.customData%60%20-%20e.g.%20%60oc.thread.customData.foo%20%3D%2010%60.%20You%20can%20also%20store%20custom%20data%20on%20individual%20messages%20like%20this%3A%20%60message.customData.foo%20%3D%2010%60.%5Cn%5CnAll%20your%20%60MessageAdded%60%20handlers%20are%20guaranteed%20to%20be%20finished%20before%20the%20next%20message%20is%20added.%5Cn%5CnThe%20custom%20code%20runs%20within%20an%20iframe%2C%20and%20you%20can%20show%20the%20iframe%20with%20%60oc.window.show%28%29%60.%20This%20is%20useful%20if%20you%20want%20to%20create%20a%20custom%20interface.%20You%20can%20add%20stuff%20to%20your%20interface%20by%20just%20editing%2Fadding-to%20the%20HTML%20document%2C%20like%20so%3A%5Cn%60%60%60js%5Cndocument.body.innerHTML%20%3D%20%5C%22stuff%20you%20want%20to%20add%5C%22%3B%5Cn%60%60%60%5CnYou%20can%20hide%20the%20window%20with%20%60oc.window.hide%28%29%60.%5Cn%5CnHere%27s%20the%20full%20set%20of%20properties%20on%20the%20%60oc%60%20object%3A%5Cn%20%20%2a%20character%5Cn%20%20%20%20%2a%20name%5Cn%20%20%20%20%2a%20avatar%5Cn%20%20%20%20%20%20%2a%20url%20-%20image%20url%5Cn%20%20%20%20%20%20%2a%20size%20-%20default%3D1%5Cn%20%20%20%20%20%20%2a%20shape%20-%20%5C%22circle%5C%22%20or%20%5C%22square%5C%22%20or%20%5C%22portrait%5C%22%20%5Cn%20%20%2a%20thread%5Cn%20%20%20%20%2a%20messages%20-%20an%20%2a%2aarray%2a%2a%20of%20messages%2C%20where%20%2a%2aeach%20message%2a%2a%20has%3A%5Cn%20%20%20%20%20%20%2a%20content%20-%20the%20message%20text%20-%20it%20can%20include%20HTML%2C%20and%20is%20rendered%20as%20markdown%20by%20default%20%28see%20%60oc.messageRenderingPipeline%60%29%5Cn%20%20%20%20%20%20%2a%20author%5Cn%20%20%20%20%20%20%2a%20name%5Cn%20%20%20%20%20%20%2a%20hiddenFrom%20-%20array%20with%20%5C%22user%5C%22%20or%20%5C%22ai%5C%22%20or%20both%20or%20neither%5Cn%20%20%20%20%20%20%2a%20expectsReply%20-%20boolean%20%28will%20bot%20reply%20to%20this%20message%3F%29%5Cn%20%20%20%20%20%20%2a%20customData%20-%20message-specific%20custom%20data%20storage%5Cn%20%20%20%20%20%20%2a%20avatar%20%3D%20%7Burl%2C%20size%2C%20shape%7D%20-%20message-specific%20avatar%20%28overrides%20default%29%5Cn%20%20%20%20%20%20%2a%20wrapperStyle%20-%20css%20for%20the%20%5C%22message%20bubble%5C%22%20-%20e.g.%20%5C%22background%3Awhite%3B%20border-radius%3A10px%3B%5C%22%5Cn%20%20%20%20%20%20%2a%20scene%20-%20most%20recent%20message%20with%20a%20%60scene%60%20sets%20the%20background%2Fmusic%5Cn%20%20%20%20%20%20%20%20%2a%20background%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20url%20-%20image%20or%20video%20url%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20filter%20-%20css%20filter%20-%20e.g.%20%60hue-rotate%2890deg%29%3B%20blur%285px%29%60%5Cn%20%20%20%20%20%20%20%20%2a%20music%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20url%20-%20audio%20url%20%28also%20supports%20video%20urls%29%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20volume%20-%20between%200%20and%201%5Cn%20%20%20%20%2a%20userCharacter%5Cn%20%20%20%20%20%20%2a%20name%5Cn%20%20%20%20%20%20%2a%20avatar%20%3D%20%7Burl%2C%20size%2C%20shape%7D%5Cn%20%20%20%20%2a%20customData%20-%20thread-specific%20custom%20data%20storage%5Cn%20%20%2a%20messageRenderingPipeline%5Cn%20%20%2a%20window%20%3D%20%7Bshow%2C%20hide%7D%22%2C%22reminderMessage%22%3A%22%5BAI%5D%3A%20%28Thought%3A%20I%20should%20almost%20always%20use%20%60oc.getChatCompletion%60%20to%20do%20message%20edits%2C%20like%20in%20the%20above%20%5C%22include%20more%20emojis%5C%22%20example%20%28%60await%20oc.getChatCompletion%28%7Bmessages%3A%20%5B%7Bauthor%3A%5C%22user%5C%22%2C%20content%3A%5C%22...%5C%22%7D%5D%7D%29%60%29.%20It%20prompts%20an%20LLM%20to%20do%20the%20editing%2C%20so%20it%20can%20intelligently%20do%20many%20things%20that%20would%20be%20hard%20to%20implement%20using%20regular%20JavaScript%20code.%20Use%20it%20as%20a%20general%20%5C%22text%20transformation%2Fediting%2Fsummarization%2Fetc%5C%22%20tool.%20This%20is%20much%20better%20than%20using%20replace%2FreplaceAll%20unless%20it%20is%20a%20fairly%20simple%20task%20for%20a%20regex%20replace.%29%22%2C%22modelName%22%3A%22gpt-3.5-turbo%22%2C%22fitMessagesInContextMethod%22%3A%22summarizeOld%22%2C%22associativeMemoryMethod%22%3A%22none%22%2C%22associativeMemoryEmbeddingModelName%22%3A%22text-embedding-ada-002%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20character%20uses%20the%20%5Bcustom%20code%20docs%5D%28https%3A%2F%2Fgithub.com%2Fjosephrocca%2FOpenCharacters%2Fblob%2Fmain%2Fdocs%2Fcustom-code.md%29%20and%20tries%20to%20help%20you%20write%20custom%20code.%20It%20will%20probably%20make%20lots%20of%20mistakes%20and%20in%20general%20just%20do%20silly%20things.%20You%20should%20definitely%20%2a%2aswitch%20the%20model%20to%20GPT-4%2a%2a%20if%20you%20can%20afford%20it%20-%20it%27s%20%2a%2amuch%2a%2a%20smarter.%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%5D%2C%22avatar%22%3A%7B%22url%22%3A%22https%3A%2F%2Fi.imgur.com%2FZ8NL9u6.jpg%22%2C%22size%22%3A1%2C%22shape%22%3A%22square%22%7D%2C%22scene%22%3A%7B%22background%22%3A%7B%22url%22%3A%22%22%7D%2C%22music%22%3A%7B%22url%22%3A%22%22%7D%7D%2C%22userCharacter%22%3A%7B%22avatar%22%3A%7B%7D%7D%2C%22streamingResponse%22%3Atrue%7D%7D`,
        ];
        for(let i = 0; i < starterCharacters.length; i++) {
          // convert URL format to object:
          if(typeof starterCharacters[i] === "string") {
            starterCharacters[i] = JSON.parse(decodeURIComponent(starterCharacters[i].split("#")[1])).addCharacter;
          }
          starterCharacters[i].id = null;
        }


        $.starterCharacterList.innerHTML = starterCharacters.map(character => createCharacterCardHtml(upgradeCharacterFromOldVersion(character))).join("");
        $.starterCharacterList.querySelectorAll(".character").forEach((characterEl, i) => {
          characterEl.addEventListener("click", async function(e) {
            let character = starterCharacters[i];
            const result = await characterDetailsPrompt(character);
            if(!result) return;
            const characterObj = await addCharacter(result);
            await createNewThreadWithCharacterId(characterObj.id);
          });
        });

        $.characterFoldersList.querySelectorAll(".characterFolder").forEach(characterFolderEl => {
          characterFolderEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            $.characterFoldersList.dataset.currentFolderPath = characterFolderEl.dataset.folderPath;
            await renderCharacterList();
          });
        });

        $.characterFoldersList.querySelectorAll(".editFolderName").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            const folderPath = btn.closest(".characterFolder").dataset.folderPath;
            
            let label;
            if(folderPath.split("/").length === 1) {
              label = `Edit the name of this folder:`;
            } else {
              label = `Edit the name of this folder by changing '${folderPath.split("/").at(-1)}' to something else, or move all items inside the '${folderPath.split("/").at(-1)}' folder to a new location by editing the whole folder path:`;
            }
            let characterFolderData = (await db.misc.get("characterFolderData"))?.value || {};

            let result = await prompt2({
              newFolderPath: {type:"textLine", label, defaultValue:folderPath},
              emoji: {type:"textLine", label:"Folder emoji or image URL:", defaultValue:characterFolderData[folderPath]?.emoji || ""},
            });
            if(!result) return;

            if(result.emoji) {
              if(!characterFolderData[folderPath]) characterFolderData[folderPath] = {};
              characterFolderData[folderPath].emoji = result.emoji;
            }

            await db.misc.put({key:"characterFolderData", value:characterFolderData});

            let newFolderPath = result.newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
            // each character has a folderPath property, which is a string like "folder1/folder2/folder3" or just "" (empty string) if it's in the root folder
            await db.characters.toCollection().modify(function(character) {
              // we need to move all characters that start with folderPath to newFolderPath
              if(character.folderPath === folderPath) {
                character.folderPath = newFolderPath;
              } else if(character.folderPath.startsWith(folderPath+"/")) {
                character.folderPath = newFolderPath + character.folderPath.slice(folderPath.length);
              }
            });
            await renderCharacterList();
          });
        });

        // Add an onclick handler to each character which starts a new thread with that character.
        $.characterList.querySelectorAll(".character").forEach(characterEl => {

          // copy link to clipboard and show a little notification at top of page if they click the share button
          characterEl.querySelector(".share").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            const character = (await db.characters.where("id").equals(characterId).toArray())[0];
            delete character.id;
            delete character.creationTime;
            delete character.lastMessageTime;
            character.folderName = "";
            for(let key in character.customData) {
              if(key === "PUBLIC") continue; // data within oc.character.customData.PUBLIC is shared within share links - all other data is not
              delete character.customData[key];
            }
            let warnThatAvatarUrlWasRemoved = false;
            let avatarUrl = character.avatar.url;
            if(avatarUrl && avatarUrl.startsWith("data:")) {
              character.avatar.url = "";
              warnThatAvatarUrlWasRemoved = true;
            }
            let urlHashData = encodeURIComponent(JSON.stringify({addCharacter:character})).replace(/[!'()*]/g, function(c) {
              return '%' + c.charCodeAt(0).toString(16); // since encodeURIComponent doesn't encode some characters (like parentheses) and I think they mess up markdown links
            });
            const url = `${window.location.origin+window.location.pathname}#${urlHashData}`;
            await navigator.clipboard.writeText(url);
            $.topNotificationContent.innerHTML = `Copied character link to clipboard!`;
            showEl($.topNotification);

            if(warnThatAvatarUrlWasRemoved) {
              await new Promise(resolve => setTimeout(resolve, 1000));
              let result = await prompt2({
                message: {type:"none", "html":`<p style="margin:0;">All character data is embedded within OpenCharacters share links, but this character's avatar image was stored as text (using a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs" target="_blank">'data' URL</a>), and that would result in a huge share URL, so the avatar image was removed from the share link.<br><br>If you click 'Open avatar in new tab', then you can right-click/long-press it and save the avatar image, and then upload it to catbox.moe or a similar website, and then edit your character and replacing the 'data:' avatar URL with the new 'https:' URL that you got from the image hosting service. That way your share link will include the avatar image.</p>`},
              }, {cancelButtonText:"Share charater without avatar", submitButtonText:"Open avatar in new tab"});
              if(result !== null) {
                let blobUrl = await dataUrlToCachedBlobUrl(avatarUrl);
                window.open(blobUrl, "_blank");
              }
            }

            setTimeout(() => hideEl($.topNotification), 3000);
          });

          // edit character details if they click the edit button
          characterEl.querySelector(".edit").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            await editCharacterById(characterId);
          });

          // duplicate
          characterEl.querySelector(".duplicate").addEventListener("click", async function(e) {
            e.stopPropagation();
            const originalCharacterId = parseInt(characterEl.dataset.characterId);
            let originalCharacter = await db.characters.get(originalCharacterId);
            const result = await characterDetailsPrompt(originalCharacter);
            if(!result) return;
            const character = await addCharacter(result);
            await createNewThreadWithCharacterId(character.id);
          });

          // delete character if they click the delete button
          characterEl.querySelector(".delete").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            if(confirm(`Are you sure you want to delete this character? This will delete ALL THREADS associated with this character.`)) {
              await safelyDeleteCharacterById(characterId);
              await renderCharacterList();
              await renderThreadList();
            }
          });

          characterEl.querySelector(".changeFolderPath").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            let character = await db.characters.get(characterId);
            let newFolderPath = prompt("Enter new folder path for this character. You can add subfolders with forward-slashes like 'folder/subfolder/...'", character.folderPath);
            if(newFolderPath !== null) {
              newFolderPath = newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
              await db.characters.update(characterId, { folderPath: newFolderPath });
              await renderCharacterList();
            }
          });
          
          // create a new thread if they click a character
          characterEl.addEventListener("click", async function() {
            let loadingModal = createLoadingModal("Loading...");
            let characterId = parseInt(characterEl.dataset.characterId);
            await createNewThreadWithCharacterId(characterId);
            loadingModal.delete();
          });
        });
      }

      $.newCharacterButton.addEventListener("click", async function() {
        const result = await characterDetailsPrompt();
        if(!result) return;
        const character = await addCharacter(result);
        await createNewThreadWithCharacterId(character.id);
      });

      // $.newFolderCharacterButton.addEventListener("click", async function() {
      //   let folderName = prompt("Folder name:");
      //   if(!folderName) return;
      // });



      async function safelyDeleteCharacterById(characterId) {
        let character = await db.characters.get(characterId);
        await db.characters.delete(characterId);
        // delete all threads and messages associated with this character
        const threads = await db.threads.where("characterId").equals(characterId).toArray();
        for(let thread of threads) {
          await safelyDeleteThreadById(thread.id)
        }


        // for any message that has this character's id as its message.characterId, set message.characterId to the thread character id and embed the name and avatar of the character in the message
        // messages can have non-thread-character ids because of the `/ai @CharName#123` command
        let threadIdToCharacterId = {};
        let allThreads = await db.threads.toArray();
        for(let thread of allThreads) {
          threadIdToCharacterId[thread.id] = thread.characterId;
        }
        await db.messages.toCollection().modify(function(message) {
          if(message.characterId === characterId) {
            message.characterId = threadIdToCharacterId[message.threadId];
            message.name = character.name;
            message.avatar.url = character.avatar.url;
          }
        });
      }

      window.safelyDeleteThreadById = async function safelyDeleteThreadById(threadId) {
        // let thread = await db.threads.get(threadId);
        await db.threads.delete(threadId);
        let messageIds = await db.messages.where("threadId").equals(threadId).toArray().then(arr => arr.map(m => m.id));
        await safelyDeleteMessagesByIds(messageIds);
        // delete messages, summaries, memories, and usagestats for this thread:
        await db.summaries.where("threadId").equals(threadId).delete();
        await db.memories.where("threadId").equals(threadId).delete();
        await db.usageStats.where("threadId").equals(threadId).delete();
      }

      // this function deletes and "cleans up references" to messages - e.g. ids in `message.messageIdsUsed`
      async function safelyDeleteMessagesByIds(idsToDelete, opts={}) {
        // IMPORTANT: If you make changes here, ensure it it doesn't break the 'undo deletion' feature for messages.
        // It's okay (for now, at least) if diagnostic information (like messageIdsUsed), but 'critical' info that is deleted should be undone.

        let messagesTable;
        if(opts.tx) messagesTable = opts.tx.table("messages");
        else messagesTable = db.messages;

        if(idsToDelete.length === 0) return;
        // get thread id:
        let threadId = await messagesTable.get(idsToDelete[0]).then(m => m.threadId);
        // delete messages:
        await messagesTable.where("id").anyOf(idsToDelete).delete();
        // clean up references to the deleted messages:
        let remainingMessages = await messagesTable.where("threadId").equals(threadId).toArray();
        
        for(let m of remainingMessages) {
          let changed = false;
          
          // if the deleted messages were reference by other messages via messageIdsUsed, we need to change those references to -1
          let originalNumMessageIdsUsed = m.messageIdsUsed.length;
          m.messageIdsUsed = m.messageIdsUsed.map(id => idsToDelete.includes(id) ? -1 : id);
          if(m.messageIdsUsed.length !== originalNumMessageIdsUsed) {
            changed = true;
          }

          if(changed) {
            await messagesTable.put(m);
          }
        }
      }

      async function editCharacterById(characterId) {
        const character = await db.characters.get(characterId);
        const result = await characterDetailsPrompt(character);
        if(!result) return;

        await db.characters.update(characterId, result);

        if(result.customCode?.trim() && result.customCode !== character.customCode) {
          // get all threads with this character and delete custom code iframes for them if they exist
          const threads = await db.threads.where("characterId").equals(characterId).toArray();
          for(let thread of threads) {
            if(customCodeIframes[thread.id]) {
              delete customCodeIframes[thread.id];
            }
          }
          // create new iframe for currently-active thread, if there is one
          let threadId = activeThreadId;
          if(threadId !== null) {
            await createNewCustomCodeIframeForThread(threadId);
          }
          if($.messageFeed.offsetWidth > 0) {
            await updateThreadScene();
          }
        }

        // Note: we don't need to recompute memory embeddings if they change textEmbeddingModelName because textEmbeddingModelName is now thread-specific (inherited from character at time of creation)

        await renderCharacterList();
        await renderThreadList();
      }


      const defaultThreadName = "Unnamed Thread";
      const defaultSystemName = "System";

      async function createNewThreadWithCharacterId(characterId) {
        let folderPath = $.chatThreads.dataset.currentFolderPath;
        const thread = await addThread({name:defaultThreadName, characterId, folderPath});

        await renderThreadList();
        
        const character = await db.characters.get(characterId);
        let userCharacter = await getUserCharacterObj(thread.id);

        let userName = thread.userCharacter.name ?? userCharacter.name;
        let characterName = thread.character.name ?? character.name;

        // add initial messages
        for(let m of character.initialMessages) {
          let characterId;
          if(m.author === "user") characterId = -1;
          if(m.author === "system") characterId = -2;
          if(m.author === "ai") characterId = character.id;
          if(characterId === undefined) alert("Error in createNewThreadWithCharacterId - invalid message author?");

          let data = {threadId:thread.id, message:m.content, characterId};
          
          data.expectsReply = m.expectsReply;

          if(m.hiddenFrom) data.hiddenFrom = m.hiddenFrom;
          
          data.message = data.message.replaceAll("{{user}}", userName);
          data.message = data.message.replaceAll("{{char}}", characterName);

          let messageObj = createMessageObj(data);
          await addMessageToDb(messageObj)
        }

        await renderThreadList();
        await showThread(thread.id);
      }
      

      $.threadModelSelector.addEventListener("change", async function() {
        let threadId = activeThreadId;
        let thread = await db.threads.get(threadId);
        let modelName = $.threadModelSelector.value;
        await db.threads.update(threadId, {modelName});
        if(userModelCapabilities[modelName]?.canRun === false) {
          alert(userModelCapabilities[modelName].reason);
        } else {
          await renderThreadList();
        }
      });

      // $.threadSettingsButton.addEventListener("click", async function() {
      //   let threadId = activeThreadId;
      //   let thread = await db.threads.get(threadId);

      //   const result = await prompt2({
      //     modelName: { label: "Model name:", type:"select", options:[availableModels.filter(m => m.type === "completion" || m.type === "chat-completion").map(m => ({value:m.name, content:m.shortLabel ?? m.name}))], defaultValue: thread.modelName },
      //     fitMessagesInContextMethod: { hidden:true, label: "Method for fitting messages within model's context limit.", type:"select", options:[{value:"dropOld", content:"drop oldest messages"}, {value:"summarizeOld", content:"summarize oldest messages"}], defaultValue: defaultValues.fitMessagesInContextMethod },
      //     autoGenerateMemories: { hidden:true, show:d=>d.fitMessagesInContextMethod==="summarizeOld", label: "Persistent, 'infinite' character memory:", infoTooltip:"This increases the cost by up to 2x and makes responses a bit slower, but gives the character the ability to 'save' memories, and 'recall' them when they're relevant. Currently this only works within individual threads - i.e. characters can't recall details from *other* threads.", type:"select", options:[{value:"none", content:"disabled"}, {value:"v1", content:"enabled"}], defaultValue: defaultValues.associativeMemoryMethod },
      //     textEmbeddingModelName: { hidden:true, label: "Memory embedding model:", infoTooltip:"Yep, there's currently only one option for this. Will add more in the future. It's what converts each memory (text) into a list of numbers that can be efficiently used for search/similarity/lookup.", type:"select", options:[...broadlyAvailableModels.filter(m => m.type === "text-embedding").map(m => ({value:m.name, content:m.name}))], defaultValue: defaultValues.textEmbeddingModelName },
      //   }, {submitButtonText: "save", showHiddenInputsText: "show advanced options"});
      //   if(!result) return;

      //   ## todo: update that code that re-computes all embeddings if they change the embedding model- that's not needed at the character-level anymore, but we need it here at the thread-level edits.

      // });

      let threadLoadingModal;
      let activeThreadId = null; // <-- used globally
      let activeCharacterId = null; // <-- used globally
      async function showThread(threadId) {
        let thread = await db.threads.get(threadId);

        if(thread.currentSummaryHashChain === undefined) {
          let { instructionHashChain } = await computeAndSaveThreadSummaryIfNeeded({threadId, exitOnFirstHashMissAndReturnHashChain:true});
          thread.currentSummaryHashChain = instructionHashChain;
          await db.threads.update(threadId, {currentSummaryHashChain:instructionHashChain});
        }

        activeThreadId = threadId;
        activeCharacterId = thread.characterId;

        $.threadModelSelector.value = thread.modelName;

        let characterObj = await db.characters.get(thread.characterId);

        updateFavicon(characterObj.avatar.url);
        document.title = `${characterObj.name} - ${thread.name} - PrivateGPT`;

        $.chatThreads.dataset.currentFolderPath = thread.folderPath;
        await renderThreadList();

        // thread could be past the "show more threads" button, so we render all threads if so:
        let threadEl = $.chatThreads.querySelector(`.thread[data-thread-id="${threadId}"]`);
        if(!threadEl) {
          await renderThreadList({maxShownThreads:Infinity});
        }
        threadEl = $.chatThreads.querySelector(`.thread[data-thread-id="${threadId}"]`);

        $.messageFeed.innerHTML = "";

        $.musicPlayer.pause();

        if(threadLoadingModal) {
          threadLoadingModal.delete();
        }
        
        // to prevent flash for fast-loading threads:
        let loadingModalCreationTimeout = setTimeout(() => {
          threadLoadingModal = createLoadingModal("Loading...", $.middleColumn);
        }, 200);
        
        document.querySelectorAll("#chatThreads .thread").forEach(el => el.classList.remove("selected"));
        threadEl.classList.add("selected");
        
        document.querySelectorAll("#middleColumn > .middleColumnScreen").forEach(el => hideEl(el));
        showEl($.chatInterface);

        if(isMobile) {
          closeLeftColumn();
        }

        $.threadModelSelector.value = thread.modelName;

        // thus must come before rendering the message feed because we may need to render the messages with `oc.messageRenderingPipeline`
        if(!customCodeIframes[threadId] && characterObj.customCode.trim()) {
          await createNewCustomCodeIframeForThread(threadId); // this adds iframe as here: customCodeIframes[threadId]
        }

        await renderMessageFeed(threadId);

        await db.threads.where({id:threadId}).modify({lastViewTime:Date.now()});

        await updateCustomCodeIframeVisibility();

        await renderShortcutButtons(thread);

        $.messageInput.value = thread.unsentMessageText;

        clearTimeout(loadingModalCreationTimeout);
        if(threadLoadingModal) threadLoadingModal.delete();

      }

      async function renderShortcutButtons(thread=null) {
        if(!thread) {
          thread = await db.threads.get(activeThreadId);
        }
        shortcutButtonsCtn.innerHTML = "";
        let buttonWrapper = htmlToElement(`<div style="width:max-content;"></div>`);
        if(thread.shortcutButtons.length > 0) {
          shortcutButtonsCtn.appendChild(buttonWrapper);
          for(let shortcut of thread.shortcutButtons) {
            let shortcutBtn = htmlToElement(`<button>${shortcut.name}</button>`);
            buttonWrapper.appendChild(shortcutBtn);
            shortcutBtn.addEventListener("click", async function() {
              if(shortcut.type === "message") {
                if(shortcut.insertionType === "replace") {
                  $.messageInput.value = shortcut.message;
                } else if(shortcut.insertionType === "append") {
                  $.messageInput.value += shortcut.message;
                } else if(shortcut.insertionType === "prepend") {
                  $.messageInput.value = shortcut.message + $.messageInput.value;
                }
                if(shortcut.autoSend) {
                  await sendButtonClickHandler();
                }
              }
            });
          }
       }
       if(shortcutButtonsCtn.innerHTML !== "") {
          let bulkEditButton = htmlToElement(`<button>✏️</button>`);
          bulkEditButton.addEventListener("click", async function() {
            let shortcutsInTextFormat = thread.shortcutButtons.map(s => `@name=${s.name}\n@message=${s.message}\n@insertionType=${s.insertionType}\n@autoSend=${s.autoSend ? "yes" : "no"}`).join("\n\n");
            let result = await prompt2({
              shortcutsInTextFormat: {label: "Bulk-edit shortcuts:", type: "text", defaultValue:shortcutsInTextFormat, height:"fit-content"},
            });
            if(!result) return;

            // parse shortcuts:
            const regex = /(?:^|\n+)@name=(.*?)\n@message=(.*?)\n@insertionType=(replace|append|prepend)\n@autoSend=(yes|no)/gs;
            let matches;
            let parsedShortcuts = [];

            while((matches = regex.exec(result.shortcutsInTextFormat))) {
              let shortcut = {
                name: matches[1],
                message: matches[2],
                insertionType: matches[3],
                autoSend: matches[4] === 'yes',
                type: "message",
              };
              parsedShortcuts.push(shortcut);
            }
            await db.threads.where({id:thread.id}).modify({shortcutButtons:parsedShortcuts});
            thread.shortcutButtons = parsedShortcuts;
            await renderShortcutButtons(thread);
          });
          buttonWrapper.insertBefore(bulkEditButton, buttonWrapper.firstChild);
        }
      }

      // NOTE: spaces aren't actually allowed by OpenAI - I replace them with underscores in prepareMessagesForBot
      // If you change this, update stuff in prepareMessagesForBot too
      const characterNameValidationPattern = "^[A-Za-z0-9_\\- ]{1,64}$"; // needed due to OpenAI API limitations

      async function characterDetailsPrompt(defaultValues={}, opts={}) {
        defaultValues = structuredClone(defaultValues);

        let existingCharacter;
        if(opts.editingExistingCharacter) {
          existingCharacter = await db.characters.get({uuid:defaultValues.uuid});
        }
        
        let initialMessagesText;
        if(defaultValues.initialMessages) initialMessagesText = generateTextFormatFromMessages(defaultValues.initialMessages);
        else initialMessagesText = "";

        let loreBookUrlsText;
        if(defaultValues.loreBookUrls) loreBookUrlsText = defaultValues.loreBookUrls.join("\n");
        else loreBookUrlsText = "";

        const result = await prompt2({
          header: { html: opts.editingExistingCharacter ? `<div style="border-radius:3px;font-size: 0.8rem;padding: 0.5rem;border: 1px solid var(--border-color);">You're currently <b>editing</b> an existing character named '${existingCharacter.name}'.</div>` : "", type:"none" },
          name: { label: "🪪 Character name:", type:"textLine", placeholder: "Sammy", defaultValue: defaultValues.name || "", validationPattern:characterNameValidationPattern },
          roleInstruction: { label: "🎭 Instruction/role/personality (<a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/instruction-and-reminder.md' target='_blank'>advanced</a>)", infoTooltip:"This message defines the personality or 'role' that the AI will take during the chat. Every request to the API will include this as the first message. If you later decide to edit this, all existing and new threads will be immediately updated. This message does not get summarized by the summarization algorithm - it will always be present as the first message.", type:"text", height:"fit-content", placeholder: "You are Sammy, an opinionated, friendly assistant. You have opinions.", defaultValue: defaultValues.roleInstruction || "" },
          reminderMessage: { label: "💭 Reminder message - an invisible system message that is placed before every AI response (<a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/instruction-and-reminder.md' target='_blank'>advanced</a>)", infoTooltip:"This message is inserted as a reminder at the end of the chat right before each AI response. This will always be the last/most-recent message that the AI sees when writing its response. If you later decide to edit this, all existing and new threads will be immediately updated. This message is not seen/summarized by the summarization algorithm - it will always be present as the final message.", height:"fit-content", minHeight:"3rem", type:"text", placeholder: "Stay in character! Sammy will now respond without breaking character.", defaultValue: defaultValues.reminderMessage || "" },
          initialMessagesText: { label: `💬 Initial chat messages (optional). Useful for extra alignment to character. Follow the format explained <a href="https://github.com/josephrocca/OpenCharacters/blob/main/docs/initial-messages.md" target='blank'>here</a>.`, infoTooltip:"During the initialization of every new thread with this character, these messages will be created and placed at the start of the thread. Note that the summarization algorithm will eventually summarize these messages - so they won't stay around forever (unlike the instruction and reminder messages, which *do* stay around forever). Also note that if you edit the initial messages, only *new* threads will have the updated initial messages. In other words, once a chat thread has been created, the initial messages that are added to a thread during init 'belong' to that thread, not to the character.", type:"text", height:"fit-content", placeholder: "[USER]: Hey Sammy, do you have opinions?\n[SYSTEM]: The next message will include an emoji.\n[AI]: Yes! I have lots of opinions. 🤔\n[SYSTEM; hiddenFrom=ai]: The AI can't see this message. Useful for user instructions.", defaultValue: initialMessagesText ?? "" },
          avatarUrl: { label: "👤 Avatar URL (png/jpg/etc):", type:"textLine", placeholder: "(optional)", defaultValue: defaultValues.avatar?.url || "" },
          modelName: { hidden:true, label: "🤖 Model name:", infoTooltip:"GPT-4 is really smart, but expensive (about 15x price of gpt-3.5-turbo). If you use gpt-3.5-turbo and set the 'temperature' option (see advanced settings) to 1, then apparently (according to community members) it's pretty close to DaVinci in terms of creativity and overall quality. DaVinci is overpriced given its performance - GPT-4 is significantly better and only ~1.5x the price.", type:"select", options:[{content:"GOOD/CHEAP (currently: gpt-3.5-turbo)", value:"good"}, {content:"GREAT/EXPENSIVE (currently: gpt-4)", value:"great"}, ...broadlyAvailableModels.filter(m => m.type === "completion" || m.type === "chat-completion").map(m => ({value:m.name, content:m.shortLabel}))], defaultValue: defaultValues.modelName || "good" },
          maxTokensPerMessage: { hidden:true, label: "📏 Max tokens per message:", infoTooltip:"This can be used to limit the length of the AI's responses. A 'token' is basically a word - 500 tokens is about 400 words in most tokenizers. Leave this blank to allow unlimited tokens to be generated per message. Note that you can also control the length of the AI's responses in the reminder message by saying something like 'Your response should be at most 3 sentences' or whatever.", type:"textLine", defaultValue:defaultValues.maxTokensPerMessage || "" },
          fitMessagesInContextMethod: { hidden:true, label: "Method for fitting messages within model's context limit.", type:"select", options:[{value:"dropOld", content:"drop oldest messages"}, {value:"summarizeOld", content:"summarize oldest messages"}], defaultValue: defaultValues.fitMessagesInContextMethod ?? "summarizeOld" },
          textEmbeddingModelName: { hidden:true, label: "Text embedding model:", infoTooltip:"Yep, there's currently only one option for this. Will add more in the future. It's what converts each memory/lore entry (text) into a bunch of numbers that can be efficiently used for search/similarity/lookup.", type:"select", options:[...broadlyAvailableModels.filter(m => m.type === "text-embedding").map(m => ({value:m.name, content:m.name}))], defaultValue: defaultValues.textEmbeddingModelName ?? "text-embedding-ada-002" },
          autoGenerateMemories: { hidden:true, show:d=>d.fitMessagesInContextMethod==="summarizeOld", label: "💽 Auto-generated character memories:", infoTooltip:"You can use /mem and /lore commands to manually add memories and lore. If you enable this feature, memories will be created by the character during each summarization step. This increases the cost a bit (maybe +20%) and makes responses a bit slower, but gives the character the ability to 'save' memories, and 'recall' them when they're relevant. Currently this only works within individual threads - i.e. characters can't recall details from *other* threads. You can manually copy memories and lore over into a new thread if needed.", type:"select", options:[{value:"none", content:"disabled"}, {value:"v1", content:"enabled"}], defaultValue: defaultValues.autoGenerateMemories ?? "v1" },
          avatarSize: { hidden:true, label: "Avatar size, as a multiple of the default size.", type:"textLine", defaultValue: defaultValues.avatar?.size ?? "1" },
          avatarShape: { hidden:true, label: "Avatar shape:", type:"select", options:[{value:"square"}, {value:"circle"}, {value:"portrait"}], defaultValue: defaultValues.avatar?.shape ?? "square" },
          sceneBackgroundUrl: { hidden:true, label: "🖼️ Chat background image/video URL (jpg, webp, webm, mp4, etc.)", type:"textLine", defaultValue: defaultValues.scene?.background?.url ?? "" },
          sceneMusicUrl: { hidden:true, label: "🎵 Chat background music/audio URL (mp3, webm, mp4, etc.)", infoTooltip:"Permission is always requested from the user before playing audio - i.e. music will not autoplay because that could annoy some users. You can use a video file for audio - the visuals will obviously not be shown.", type:"textLine", defaultValue: defaultValues.scene?.music?.url ?? "" },
          userCharacterName: { hidden:true, label: "User's name. This overrides the user's default username when chatting with this character.", type:"textLine", defaultValue: defaultValues.userCharacter?.name || "" },
          userCharacterAvatarUrl: { hidden:true, label: "User's avatar. This overrides the user's default avatar when chatting to this character.", type:"textLine", defaultValue: defaultValues.userCharacter?.avatar?.url || "" },
          // initialThreadMemories: { hidden:true, show:d=>d.autoGenerateMemories!=="none", label: "Initial thread-specific memories. The character will create memories based on the chat, but you can add some starter memories/lore here.", infoTooltip:"Manually-written memories can be used as 'dynamic' instruction/role/reminders that engage when relevant. This saves you from having to pack too much text into your instruction/reminder, which will 'eat up' your context, which means the AI will be able to see fewer recent messages, and summarization will have to be done more often.", type:"text", defaultValue: defaultValues.textEmbeddingModelName ?? "" },
          temperature: { hidden:true, label: "🌡️ Creativity ('temperature'). Choose a value between 0 and 2. Higher values will make the output more random, while lower values will make it more focused and deterministic.", infoTooltip:"People seem to get good results between 0.7 and 1.2 - higher values may sacrifice some 'correctness' but should result in more 'imagination'.", type:"textLine", defaultValue: defaultValues.temperature ?? 0.85 },
          loreBookUrlsText: { hidden:true, height:"fit-content", cssText:"white-space:pre; font-family:monospace;", label: "📖 Lorebook URLs - one per line. Use <a href='https://rentry.org' target='_blank'>rentry.org</a> or similar. Should be a url to the 'raw' text file, where your lore entries are separated by blank lines. For changes to propagate to <b>existing</b> threads, you need to use the <b>/lore</b> command and click the reload button. Visit <a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/memories-and-lore.md' target='_blank'>this page</a> to learn more.", type:"text", height:"fit-content", defaultValue: loreBookUrlsText },
          customCode: { hidden:true, height:"fit-content", cssText:"white-space:pre; font-family:monospace;", label: "🧑‍💻 Custom JavaScript code. This allows you to e.g. give your bot access to the internet. Visit <a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/custom-code.md' target='_blank'>this page</a> to learn more.", type:"text", height:"fit-content", defaultValue: defaultValues.customCode ?? "" },
          systemCharacterName: { hidden:true, label: "System's name:", type:"textLine", defaultValue: defaultValues.systemCharacter?.name || "" },
          systemCharacterAvatarUrl: { hidden:true, label: "System's avatar:", type:"textLine", defaultValue: defaultValues.systemCharacter?.avatar?.url || "" },
        }, {submitButtonText: opts.submitButtonText || "save character", showHiddenInputsText: "show advanced options"});
        
        if(!result) return;
        
        result.name = result.name.trim();

        if(result.name === "") result.name = "_";
        result.name = result.name.replaceAll("#", ""); // just to be sure - a hash is used for `/ai @charName#123 <instruction>` so it's important that it's not in the name

        if(result.customCode.trim() === "") result.customCode = ""; // if the custom code box just contained whitespace, remove it
        
        if(result.maxTokensPerMessage.trim() === "") result.maxTokensPerMessage = null;
        if(result.maxTokensPerMessage) result.maxTokensPerMessage = Number(result.maxTokensPerMessage);
        

        // process prompt results back into well-formed character object:

        if(result.initialMessagesText?.trim()) {
          result.initialMessages = parseMessagesFromTextFormat(result.initialMessagesText);
          if(result.initialMessages === null) { // invalid, so just throw it all into a single message (mainly so they don't lose their work)
            result.initialMessages = [{content:result.initialMessagesText, author:"ai", hiddenFrom:[]}];
          }
        } else {
          result.initialMessages = [];
        }
        delete result.initialMessagesText;

        if(result.loreBookUrlsText?.trim()) {
          result.loreBookUrls = result.loreBookUrlsText.trim().split("\n").map(url => url.trim()).filter(url => url);
          for(let i = 0; i < result.loreBookUrls.length; i++) {
            let url = new URL(result.loreBookUrls[i]);
            if(url.hostname === "rentry.org" || url.hostname === "rentry.co") {
              url.pathname = url.pathname.replace(/\/$/, "");
              if(!url.pathname.endsWith("/raw")) {
                url.pathname += "/raw";
              }
              result.loreBookUrls[i] = url.toString();
            }
          }
        } else {
          result.loreBookUrls = [];
        }
        delete result.loreBookUrlsText;

        result.avatar = {
          url: result.avatarUrl,
          size: Number(result.avatarSize),
          shape: result.avatarShape,
        };
        delete result.avatarUrl;
        delete result.avatarSize;
        delete result.avatarShape;

        result.scene = {
          background: {
            url: result.sceneBackgroundUrl,
          },
          music: {
            url: result.sceneMusicUrl,
          },
        };
        delete result.sceneBackgroundUrl;
        delete result.sceneMusicUrl;
        
        result.temperature = Number(result.temperature);

        if(isNaN(result.temperature)) result.temperature = 0.8;

        // user character object overrides:
        result.userCharacter = {avatar:{}};
        if(result.userCharacterName.trim()) result.userCharacter.name = result.userCharacterName;
        delete result.userCharacterName;
        if(result.userCharacterAvatarUrl.trim()) result.userCharacter.avatar.url = result.userCharacterAvatarUrl;
        delete result.userCharacterAvatarUrl;
        
        // system character object overrides:
        result.systemCharacter = {avatar:{}};
        if(result.systemCharacterName.trim()) result.systemCharacter.name = result.systemCharacterName;
        delete result.systemCharacterName;
        if(result.systemCharacterAvatarUrl.trim()) result.systemCharacter.avatar.url = result.systemCharacterAvatarUrl;
        delete result.systemCharacterAvatarUrl;

        // this is not editable in the UI, but it's needed for a valid character obj
        result.streamingResponse = true;

        result.folderPath = defaultValues.folderPath ?? "";
        result.customData = defaultValues.customData ?? "";

        if(existingCharacter) {
          result.uuid = existingCharacter.uuid;
        } else {
          result.uuid = defaultValues.uuid ?? null;
        }

        // If it contains [AI], [SYSTEM], or [USER], but doesn't *start* with one of those, warn them that it's being treated as one big system message
        if(/(^|\s)\[(AI|SYSTEM|USER)\]:/.test(result.reminderMessage) && !/^\[(AI|SYSTEM|USER)\]:/.test(result.reminderMessage.trim())) {
          alert("It looks like you're using the advanced [AI]/[USER]/[SYSTEM] reminder message format, but your reminder message doesn't start with either [AI]: or [USER]: or [SYSTEM]:. If you want to use the advanced format, make sure your reminder message starts with [AI]: or [USER]: or [SYSTEM]:, otherwise your whole reminder message will be assumed to be one big 'SYSTEM' message (i.e. it assumes you're not using the advanced format).");
        }

        return result;
      }

      function generateTextFormatFromMessages(messages) {
        let text = '';

        messages.forEach(message => {
          const author = message.author.toUpperCase();
          let paramsObj = {};
          if(message.hiddenFrom && message.hiddenFrom.length > 0) paramsObj.hiddenFrom = message.hiddenFrom;
          // note: currently expectsReply is not supported in initial messages
          const parameters = Object.entries(paramsObj)
            .map(([key, value]) => `${key}=${value}`)
            .join('; ');

          const paramString = parameters ? `; ${parameters}` : '';
          const content = message.content.replace(/\n/g, '\n');

          text += `[${author}${paramString}]: ${content}\n`;
        });

        return text.trim();
      }

      function parseMessagesFromTextFormat(text) {
        if(!/^\[(SYSTEM|USER|AI)(?:;[\s]*[\w]+=[\w]+)*\]:/.test(text)) {
          return null;
        }
        const lines = text.split('\n');
        const messages = [];
        let currentMessage = null;

        lines.forEach(line => {
          const match = line.match(/^\[(SYSTEM|USER|AI);?(.*?)\]:\s*(.*)/);

          if(match) {
            if(currentMessage) {
              messages.push(currentMessage);
            }

            currentMessage = {
              author: match[1].toLowerCase(),
              content: match[3],
              parameters: {}
            };

            if(match[2]) {
              const params = match[2].trim().split(';');
              params.forEach(param => {
                const [key, value] = param.split('=');
                currentMessage.parameters[key.trim()] = value.trim();
              });
            }
          } else if(currentMessage) {
            currentMessage.content += '\n' + line;
          }
        });

        if (currentMessage) {
          messages.push(currentMessage);
        }

        // parse out valid parameters:
        for(let m of messages) {
          if(m.parameters.hiddenFrom) {
            if(m.parameters.hiddenFrom === "ai") m.hiddenFrom = ["ai"];
            if(m.parameters.hiddenFrom === "user") m.hiddenFrom = ["user"];
            if(m.parameters.hiddenFrom === "both") m.hiddenFrom = ["ai", "user"];
          }
          if(!m.hiddenFrom) m.hiddenFrom = [];
          // note: currently expectsReply is not supported in initial messages
          delete m.parameters;
        }

        for(let m of messages) {
          m.content = m.content.trim(); // to allow messages to be separated by multiple newlines, and to allow a space after [AI]:/[USER]:/[SYSTEM]:
        }

        return messages;
      }

      async function addCharacter(inputs) {
        const characterObj = {
          ...inputs,
          creationTime: Date.now(),
          lastMessageTime: Date.now(),
        };
        await db.characters.add(characterObj);
        return characterObj;
      }

      async function getOpenAiApiKey() {
        let apiKey = (await db.misc.get("openAiApiKey"))?.value;
        while(!apiKey) {
          let result = await prompt2({
            openAiApiKey: { label: "Please create a new OpenAI API secret key and paste it here. Go to <a style='color:blue' href='https://platform.openai.com/account/api-keys' target='_blank'>this page</a> to do that. You can change or delete this later by clicking the 'settings' button.", type:"textLine", placeholder:"sk-...", focus:true },
          });
          if(!result || !result.openAiApiKey) continue;
          apiKey = result.openAiApiKey;
          break;
        }
        await db.misc.put({ key: "openAiApiKey", value: apiKey });
        return apiKey;
      }


      function createMessageObj({threadId, message, characterId, hiddenFrom, creationTime, expectsReply, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed, scene, avatar, name, customData, wrapperStyle, order, instruction}) {
        if(threadId === undefined || message === undefined || characterId === undefined) throw new Error(`createMessageObj: threadId, message, and characterId are required: ${threadId}, ${message}, ${characterId}`);
        return {
          threadId,
          message,
          characterId,
          hiddenFrom: Array.isArray(hiddenFrom) ? hiddenFrom : [],
          expectsReply: expectsReply ?? undefined,
          creationTime: creationTime ?? Date.now(),
          variants: [null], // null is the placeholder for the currently-selected variant (i.e. the one in the `message` property)
          memoryIdBatchesUsed: memoryIdBatchesUsed ?? [],
          loreIdsUsed: loreIdsUsed ?? [],
          summaryHashUsed: summaryHashUsed ?? null,
          memoryQueriesUsed: memoryQueriesUsed ?? [],
          messageIdsUsed: messageIdsUsed ?? [],
          name: name ?? null,
          scene: scene ?? null,
          avatar: avatar ?? {},
          customData: customData ?? {},
          wrapperStyle: wrapperStyle ?? "",
          order: order ?? undefined,
          instruction: instruction ?? null,
          // RE `order` being undefined - this can happen if it's just being created (but not when e.g. being called from messagesFromCustomCodeFormat)
        };
      }

      async function addMessageToDb(messageObj, opts={}) {

        messageObj = structuredClone(messageObj);
        delete messageObj.character; // just in case I'm sloppy somewhere

        if(messageObj.order === undefined) {
          let messages = await db.messages.where({threadId:messageObj.threadId}).toArray();
          messages.sort((a,b) => a.order - b.order);
          messageObj.order = messages.length > 0 ? messages.at(-1).order + 1 : 0;
        }

        let id = await db.messages.add(messageObj);
        // update the thread's lastMessageTime.
        await db.threads.update(messageObj.threadId, { lastMessageTime: messageObj.creationTime });
        
        // if this isn't at the top of the thread list, re-render the thread list
        let threadId = messageObj.threadId;
        let thread = await db.threads.get(threadId);
        let threadElements = [...$.chatThreads.querySelectorAll(".thread")];
        if(!thread.isFav) threadElements = threadElements.filter(el => el.querySelector(".favStar").dataset.isFav==="false");
        if(threadElements[0].dataset.threadId !== threadId.toString()) {
          await renderThreadList();
        }

        return id;
      }

      // determine which models the user has access to and can run:
      let userModelCapabilities = {};
      (async function() {
        userModelCapabilities = (await db.misc.get("userModelCapabilities"))?.value ?? {};
        
        while(1) {
          await delay(1000);
          if(!await db.isOpen()) {
            continue;
          }
          // wait for user's API key to be set
          let openAiApiKey = (await db.misc.get("openAiApiKey"))?.value;
          if(!openAiApiKey) {
            continue;
          }
        }

        if(!userModelCapabilities["gpt-4"]) {
          let canRun = await fetch("https://api.openai.com/v1/chat/completions", {
            "headers": { "authorization": `Bearer ${openAiApiKey}`, "content-type": "application/json" },
            "body": JSON.stringify({
              model: "gpt-4",
              messages: [{role:"user", text:"Hi."}],
              max_tokens: 5,
            }),
            "method": "POST",
          }).then(r => r.json()).then(json => !json.error).catch(e => false);

          userModelCapabilities["gpt-4"] = {
            canRun,
            reason: canRun ? null : "You don't have access to the GPT-4 model. You need to join the waitlist: https://openai.com/waitlist/gpt-4-api",
          };
        }

        await db.misc.put({ key:"userModelCapabilities", value:userModelCapabilities });
      })();

      async function addThread({name, characterId, folderPath}) {
        let aiCharacter = await db.characters.get(characterId);

        let modelName = aiCharacter.modelName;
        if(modelName === "good") modelName = "gpt-3.5-turbo";
        if(modelName === "great") {
          if(userModelCapabilities["gpt-4"]?.canRun) modelName = "gpt-4";
          else modelName = Date.now() < new Date("2024-01-04").getTime() ? "text-davinci-003" : "gpt-3.5-turbo-instruct";
        }

        // get highest bookId value:
        let loreBookId = (await db.lore.orderBy("bookId").last() ?? {bookId:-1}).bookId;
        loreBookId++;
        
        const threadObj = {
          name,
          characterId,
          creationTime: Date.now(),
          lastMessageTime: Date.now(),
          lastViewTime: Date.now(),
          isFav: false,
          userCharacter: { // note: we don't use await getUserCharacterObj because that is for *existing* threads (requires threadId as input param)
            name: (await db.misc.get("userName"))?.value || defaultUserName,
            avatar: {
              url: (await db.misc.get("userAvatarUrl"))?.value || "",
              // we leave `shape` and `size` as thread default
            },
          },
          systemCharacter: {name:defaultSystemName, avatar:{}},
          character: {avatar:{}}, // thread-specific ai character overrides
          modelName,
          customCodeWindow: {visible:false, width:null},
          customData: {},
          folderPath: folderPath || "",
          loreBookId,
          textEmbeddingModelName: aiCharacter.textEmbeddingModelName,
          userMessagesSentHistory: [],
          unsentMessageText: "",
          shortcutButtons: [],
          currentSummaryHashChain: [],
        };

        if(aiCharacter.loreBookUrls.length > 0) {
          await getOpenAiApiKey(); // so we have it for embedTexts
        }

        await ensureLoreUrlsAreLoaded({loreBookUrls:aiCharacter.loreBookUrls, modelName:aiCharacter.textEmbeddingModelName}).catch(e => {
          console.error("Error loading lore urls:", e);
          alert("Error loading lore urls: "+e);
        });

        // when a thread is first created, we copy across the character's userCharacter as a starting point for the `thread.userCharacter` - after that, the `aiCharacter.userCharacter` is not relevant to the thread (i.e. thread's userCharacter can diverge from the character's 'template' userCharacter)
        applyObjectOverrides({object:threadObj.userCharacter, overrides:aiCharacter.userCharacter});
        // same for systemCharacter
        applyObjectOverrides({object:threadObj.systemCharacter, overrides:aiCharacter.systemCharacter});

        await db.threads.add(threadObj);
        return threadObj;
      }

      async function ensureLoreUrlsAreLoaded({loreBookUrls, modelName}) {
        let loadingModal = createLoadingModal("Downloading lore...");
        let urlI = 0;
        for(let url of loreBookUrls) {
          let downloadUrl;
          let origin = new URL(url).origin;
          if(origin.endsWith("jsdelivr.net")
            || (origin.endsWith("huggingface.co") && url.includes("/resolve/"))
            || origin === "https://raw.githubusercontent.com"
          ) {
            // the server has correct CORS headers, so we don't need the proxy:
            downloadUrl = url;
          } else {
            // code for this CORS proxy server is here: https://replit.com/@joe64/opencharacters-cors-proxy
            downloadUrl = "https://opencharacters-cors-proxy.joe64.repl.co?url=" + encodeURIComponent(url);
          }
          let text = await fetch(downloadUrl).then(r => r.text());
          let entryTextArr = text.replace(/\r/g, "").split(/\n{2,}/).map(entry => entry.trim()).filter(entry => entry);
          
          let textHashes = await Promise.all(entryTextArr.map(e => sha256Text(e)));
          let entries = entryTextArr.map((e, i) => ({
            text: e,
            textHash: textHashes[i],
            bookUrl: url,
            bookId: null,
            triggers: [],
          }));
          
          // Add embeddings to entries:
          let onProgressMessage = (data) => loadingModal.updateContent(`Adding lore entries (URL #${urlI})... ` + Math.round(data.progress * 100) + "%");
          // Note that `embedTexts` will try to get embeddings from textEmbeddingCache first
          let embeddings = await embedTexts({textArr:entries.map(e => e.text), modelName, onProgressMessage, shouldCache:true});
          entries.forEach((e, i) => {
            e.embeddings = {[modelName]:embeddings[i]};
          });
          let textToEntry = new Map(entries.map(e => [e.text, e]));

          let entryTextsThatAreAlreadyInDb = new Set();
          await db.lore.where({bookUrl:url}).modify((entry, ref) => {
            if(!textToEntry.has(entry.text)) {
              delete ref.value; // delete this entry because it no longer exists as an entry in the text at this url
              return;
            }
            entryTextsThatAreAlreadyInDb.add(entry.text);
            if(!entry.embeddings[modelName]) { // <-- it's possible that the entry exists, but doesn't have an embedding for this model
              entry.embeddings[modelName] = textToEntry.get(entry.text).embeddings[modelName];
            }
          });

          let entriesToAdd = entries.filter(e => !entryTextsThatAreAlreadyInDb.has(e.text));
          for(let entry of entriesToAdd) {
            delete entry.textHash;
          }
          if(entriesToAdd.length > 0) {
            await db.lore.bulkAdd(entriesToAdd);
            console.log(`Added lore entries for ${url}:`, entriesToAdd);
          }
          urlI++;
        }
        loadingModal.delete();
      }

      let modelNameToTokenizerCache = {};
      let gpt3Tokenizer;
      async function getTokenizerByModelName(modelName) {
        if(modelNameToTokenizerCache[modelName]) return modelNameToTokenizerCache[modelName];

        let modelObj = availableModels[modelName];

        // TODO: get actual GPT-4 tokenizer
        if(modelName.startsWith("gpt-3.5-turbo") || modelName.startsWith("text-davinci-003") || modelName.startsWith("gpt-4")) {
          if(!gpt3Tokenizer) gpt3Tokenizer = createGpt3Tokenizer();
          modelNameToTokenizerCache[modelName] = gpt3Tokenizer;
          return gpt3Tokenizer;
        }

        if(!modelObj.modelUrl) throw new Error("Model doesn't have a modelUrl: "+modelName);

        if(!window.AutoTokenizer) {
          let { AutoTokenizer } = await import("https://cdn.jsdelivr.net/npm/@xenova/transformers@2.0.0-alpha.0/dist/transformers.js");
          window.AutoTokenizer = AutoTokenizer;
        }
        
        let tokenizer = await window.AutoTokenizer.from_pretrained(modelName); // returns data in this form: { data: [1, 15043, 3186], dims: [1, 3], size: 3, type: "int64" } where 'int64' ==> BigInt64
        function textToTokenIds(text) {
          return [...tokenizer(text).input_ids.data].map(n => Number(n)); // cast BigInt64 to Number
        }
        modelNameToTokenizerCache[modelName] = textToTokenIds;
        return textToTokenIds;
      }

      async function countTokens(str, modelName) {
        if(!str) return 0;
        let tokenizer = await getTokenizerByModelName(modelName);
        
        // We just use GPT-3 tokenizer for all models as an ESTIMATE for now.
        // It's better than `Math.ceil(str.length/4)` because it can handle non-ASCII characters (which very rarely are 4 characters per token).
        // But it's still just an estimate.
        // TODO: have a tokenizer per modelName, and use the right one here.
        return await tokenizer(str).length
      }

      let messageHashToTokenCountCache = {};
      async function countTokensInMessages(messages, modelName) {
        let sum = 0;
        for(let messageText of messages.map(m => `\n\n[${m.name || m.role}]: ${m.content || m.message}`)) {
          let hash = await sha256Text(messageText);
          if(messageHashToTokenCountCache[hash] === undefined) {
            messageHashToTokenCountCache[hash] = await countTokens(messageText, modelName);
          }
          sum += messageHashToTokenCountCache[hash];
        }
        return sum;
      }

      async function embedTexts({textArr, modelName, onProgressMessage, shouldCache=false}={}) {
        // we need to return the embeddings in the same order despite our caching-retrieval process:
        let textsRemaining = textArr.slice(0).map((t, i) => ({text:t, order:i}));

        // try to get embeddings from cache.
        // first add text hashes:
        let textHashes = await Promise.all(textsRemaining.map(e => sha256Text(e.text)));
        textsRemaining.forEach((e, i) => e.textHash = textHashes[i]);
        // then get cached embeddings:
        let cachedEmbeddings = await db.textEmbeddingCache.where("textHash").anyOf(textHashes).toArray();
        cachedEmbeddings = cachedEmbeddings.filter(e => e.modelName === modelName);
        // then add cached embeddings to textsRemaining:
        let textHashToCachedEmbedding = {};
        cachedEmbeddings.forEach(e => textHashToCachedEmbedding[e.textHash] = e.embedding);
        textsRemaining.forEach(e => {
          if(textHashToCachedEmbedding[e.textHash]) {
            e.embedding = textHashToCachedEmbedding[e.textHash];
          }
        });
        
        let embeddings = textsRemaining.filter(e => e.embedding);
        textsRemaining = textsRemaining.filter(e => !e.embedding);

        let apiKey = await getOpenAiApiKey();

        let endpointUrl = "https://api.openai.com/v1/embeddings";
        let headers = {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`,
        };
        if(new URL(endpointUrl).hostname.includes("azure")) {
          headers["api-key"] = apiKey;
        }

        // batch textArr into chunks of 100
        while(textsRemaining.length > 0) {
          let textsToEmbed = textsRemaining.splice(0, 100);
          let result = await fetch(endpointUrl, {
            method: "POST",
            headers,
            body: JSON.stringify({
              input: textsToEmbed.map(e => e.text),
              model: modelName,
            })
          }).then(response => response.json()); // TODO: this returns token counts under result.usage.total_tokens - I should add it to cost usageStats for cost estimation
          if(!result.data) {
            alert("Error:\n" + JSON.stringify(result, null, 2));
            throw new Error("Error getting text embeddings from OpenAI API");
          }
          let embeddingsForThisBatch = result.data.map((o, i) => {
            return {
              text: textsToEmbed[i].text,
              textHash: textsToEmbed[i].textHash,
              embedding: o.embedding,
              order: textsToEmbed[i].order,
              modelName,
              notFromCache: true,
            };
          });
          embeddings.push(...embeddingsForThisBatch);
          if(onProgressMessage) onProgressMessage({progress:1-textsRemaining.length/textArr.length});
        }
        embeddings.sort((a,b) => a.order-b.order)
        let embeddingVectorsToReturn = embeddings.map(e => e.embedding);

        // add to cache:
        let alreadyGotTexts = new Set(); // just in case textArr contains duplicates
        let entriesToAddToCache = [];
        for(let entry of embeddings) {
          if(entry.notFromCache && !alreadyGotTexts.has(entry.text)) {
            delete entry.order;
            delete entry.notFromCache;
            entriesToAddToCache.push(entry);
            alreadyGotTexts.add(entry.text);
          }
        }
        if(shouldCache) {
          await db.textEmbeddingCache.bulkAdd(entriesToAddToCache);
        }

        if(onProgressMessage) onProgressMessage({progress:1});
        return embeddingVectorsToReturn;
      }


      async function compressText({text, tokenLimit, modelName, onProgressMessage, threadId}) {
        // note: the threadId is just used to track token usage

        let originalText = text;
        let currentText = text;

        let modelTokenLimit = availableModels[modelName].maxSequenceLength;

        let compressionStep = 0;
        let textArr = [currentText]; // just for debugging
        while(await countTokens(currentText, modelName) > tokenLimit) {
          if(onProgressMessage) onProgressMessage({message:`compressing text (${compressionStep})`});

          // split text into chunks no longer than modelTokenLimit/2, with some overlap between chunks
          let textChunks = [];
          let chunkOverlap = 0.15;
          {
            let textChunksRemaining = [currentText];
            while(textChunksRemaining.length > 0) {
              let textChunk = textChunksRemaining.shift();
              if(await countTokens(textChunk, modelName) > modelTokenLimit/2) {
                // split the chunk into two
                let splitIndex = Math.floor(textChunk.length / 2);
                let overlap = Math.floor(chunkOverlap * splitIndex);

                textChunksRemaining.unshift(textChunk.slice(splitIndex));
                textChunksRemaining.unshift(textChunk.slice(0, splitIndex + overlap));
              } else {
                textChunks.push(textChunk);
              }
            }
          }

          // compress all the chunks of currentText into a newText by iteratively adding each chunk to the running summary
          // note: we do it this way so that GPT has the summary-so-far as context, versus trying to summarize a random-looking chunk of text with no context
          let chunkI = 0;
          let newText;
          for(let chunk of textChunks) {
            let messages = [{role: "system", content: "You are a helpful writing assistant. You respond with exactly the text that the user requests - nothing more, nothing less."}];
            let resultText;
            if(chunkI === 0) {
              if(compressionStep < 2) { 
                messages.push({role: "user", content: `Please respond with the following text, almost verbatim, but slightly shorter:\n\n------\n\n${chunk}${textChunks.length > 1 ? "..." : ""}\n\n------\n\nYour response should start with "NEW TEXT:" and should repeat the above text verbatim, but **SLIGHTLY** shorter. Don't cut out ANY details at all. It should be a VERY LONG, HIGHLY-DETAILED summary, capturing every single detail of the original text. Start your response with "NEW TEXT:". A concise version of *EVERY* individual sentence/paragraph should be included in the summary.`});
              } else {
                messages.push({role: "user", content: `Please respond with a summary of the following text:\n\n------\n\n${chunk}${textChunks.length > 1 ? "..." : ""}\n\n------\n\nYour response should start with "NEW TEXT:" and should be a bit shorter. Make sure to include ALL important details in the summary. The summary MUST NOT be short. It must be a LONG, HIGHLY-DETAILED summary.`});
              }
              resultText = await getChatCompletion({messages, modelName, temperature:0.7, threadId});
              resultText = resultText.trim().replace(/^NEW TEXT: ?/, "").trim();
            } else {
              if(compressionStep < 2) { 
                messages.push({role: "user", content: `I'm rewriting/summarizing a document to make it slightly shorter. Below is my work so far.\n\nSO FAR: ${newText}\n\n-----\n\nHere's what I need to add to the "SO FAR" next:\n\nNEXT PART: [...] ${chunk}${textChunks.length > chunkI+1 ? "..." : ""}\n\n-----\n\nPlease continue the "SO FAR" text by adding a more concise version of the "NEXT PART" section to the end of it. Add every single sentence/paragraph/etc. from "NEXT PART" to the "SO FAR" text, almost verbatim, except with slighly shorter (e.g. drop superfluous words and shorten/drop uninformative sentences where possible). Just respond with the newly-extended "SO FAR" section - nothing else. Your response should start with "SO FAR: ${newText.slice(0, 70)}..." and integrate a more concise version of the "NEXT PART" text to produce a new, LONGER summary.`});
              } else {
                messages.push({role: "user", content: `I'm rewriting/summarizing a document to make it a bit shorter. Below is my work so far.\n\nSO FAR: ${newText}\n\n-----\n\nHere's what I need to add to the "SO FAR" next:\n\nNEXT PART: [...] ${chunk}${textChunks.length > chunkI+1 ? "..." : ""}\n\n-----\n\nPlease continue the "SO FAR" text by adding a summarized version of the "NEXT PART" section to the end of it. Just respond with the newly-extended "SO FAR" section - nothing else. Your response should start with "SO FAR:" and add a summarized version of the "NEXT PART" text to the end of it. Make sure to include ALL important details in the new "SO FAR:" section - it should be LONGER than the existing one.`});
              }
              resultText = await getChatCompletion({messages, modelName, temperature:0.7, threadId});
              resultText = resultText.trim().replace(/^SO FAR: ?/, "").trim();
            }
            newText = resultText;
            chunkI++;
          }
          
          
          if(!newText) {
            if(onProgressMessage) onProgressMessage({message:`error, retrying compression...`});
            await delay(3000);
          } else {
            currentText = newText;
            textArr.push(text);
            console.log(`compressed text (${await countTokens(currentText, modelName)} tokens): ${currentText}`);
          }
          compressionStep++;
          if(compressionStep >= 10 && compressionStep%10 === 0) {
            await prompt2({
              display:{html:`<div style="white-space:pre-wrap;">For some reason the summarizer is struggling to summarize your text. If you close this message it will continue trying to compress the summary, but be aware that it may use a lot of API credits if it's caught in a loop. Refresh the page if you'd like to stop, or click close to continue. This could be a bug in OpenCharacters, so please report it on Github or Discord if this happens regularly. It should happen very rarely if at all. You can manually edit the summary by typing <b>/sum</b> in the chat. Here's the sequence of compression steps it has taken so far:\n\n${textArr.map((t, i) => `<b>Summary ${i}:</b>\n${t}`).join("\n\n")}</div>`, type:"none"},
            }, { submitButtonText: "close", cancelButtonText: null });
          }
        }
        return currentText;
      }

      async function getThreadSummaryHashChain(threadOrThreadId) {
        let thread = typeof threadOrThreadId === "number" ? await db.threads.get(threadOrThreadId) : threadOrThreadId;

        if(thread.currentSummaryHashChain === undefined) {
          let { instructionHashChain } = await computeAndSaveThreadSummaryIfNeeded({threadId:thread.id, exitOnFirstHashMissAndReturnHashChain:true});
          thread.currentSummaryHashChain = instructionHashChain;
          await db.threads.update(thread.id, {currentSummaryHashChain:instructionHashChain});
        }

        return thread.currentSummaryHashChain;
      }

      let alreadyComputingSummaryForThreadPromises = {};
      let alreadyComputingSummaryForThreadResolvers = {};
      async function computeAndSaveThreadSummaryIfNeeded({threadId, upToMessageId, onProgressMessage, signals, exitOnFirstHashMissAndReturnHashChain, continuePastCurrentSummary}) {

        // Note:
        //  - continuePastCurrentSummary is so that we can load summaries "ahead of time" (it just computes - causes this function to not return anything)
        //  - exitOnFirstHashMissAndReturnHashChain is so that we can allow people to delete summaries for a thread (the current threadId on each summary is erroneous, since there could be a second thread using it)

        function finalize() {
          // this function is called in the finally clause of the below try/finally block, so it gets called right before any `return` statement in the `try` clause
          let resolver = alreadyComputingSummaryForThreadResolvers[threadId];
          delete alreadyComputingSummaryForThreadPromises[threadId];
          delete alreadyComputingSummaryForThreadResolvers[threadId];
          resolver();
        }
        
        try {
          while(alreadyComputingSummaryForThreadPromises[threadId]) { // we need `while` instead of `if` because there could have been *multiple* calls for this threadId waiting, and we only want to let one of them through at a time
            if(onProgressMessage) onProgressMessage({message:`existing summary in progress...`});
            await alreadyComputingSummaryForThreadPromises[threadId];
          }
          alreadyComputingSummaryForThreadPromises[threadId] = new Promise((resolve) => {
            alreadyComputingSummaryForThreadResolvers[threadId] = resolve;
          });

          if(!signals) signals = {};
          // here's the overall idea: "consume" old messages (remove them from the start of the messages array) until you get to `messageTokensToConsumePerSummary` tokens, and then summarize them (use an existing summary if we already have it - it's kinda treated like the first message), and then keep repeating until the total number of tokens in the messages array falls below `tokenLimit` minus some tokens for the bot's response.
          // note: upToMessageId is inclusive. it's needed for things like regenerateMessage, where it may be that not all messages in the thread are visible to the bot.

          let thread = await db.threads.get(threadId);
          let aiCharacter = await db.characters.get(thread.characterId);
          let userCharacter = await getUserCharacterObj(threadId);

          // WARNING: If you change this, you'll probably have to change the summarization prompts.
          let modelName;
          if(await threadIsUsingOpenAiModel(thread)) {
            if(thread.modelName === "gpt-3.5-turbo-16k") {
              modelName = "gpt-3.5-turbo-16k";
            } else {
              modelName = "gpt-3.5-turbo";
            }
          } else {
            modelName = thread.modelName;
          }

          const characterId = aiCharacter.id;

          let originalMessages = await db.messages.where({threadId}).toArray();
          originalMessages.sort((a,b) => a.order - b.order);

          if(upToMessageId === undefined) upToMessageId = originalMessages.at(-1).id;
          originalMessages = originalMessages.slice(0, originalMessages.findIndex(m => m.id === upToMessageId)+1);

          let originalMessagesPreparedForBot = await prepareMessagesForBot({messages:originalMessages, onProgressMessage});
          let remainingMessages = originalMessagesPreparedForBot.slice(0);

          const tokenLimitForSummaryAndMessages = await getTokenLimitForSummaryAndMessages(aiCharacter, thread);

          if(tokenLimitForSummaryAndMessages < 500) {
            alert("Heads up: It looks like you may have an instruction or reminder that is really long - this means that there's only a very small amount of room for the messages and the summary. If your character's instruction/reminder isn't very long, then this could be a bug - in which case, please report this on Github or the Discord server.");
          }

          // these two can't really be any bigger, because we need to leave the final ~third for the *new* summary (although I think, practically, the summary will tend to be a lot smaller than 0.3*token limit, since the model naturally prevents summaries from getting too long)
          // CAUTION: if you change these, users will have to recompute all their summaries (since hashes will change) but you can fix this by checking for an instruction hash match every time we add a message to the batch (TODO)
          const maxTokenCountOfSummary = Math.round(tokenLimitForSummaryAndMessages/3); // <-- probably don't want summary to be any longer than the first third of our token budget
          const messageTokensToConsumePerSummary = Math.round(availableModels[modelName].maxSequenceLength*0.3);

          if(maxTokenCountOfSummary + messageTokensToConsumePerSummary > availableModels[modelName].maxSequenceLength-500) { // -500 due to token estimation and to make room for summarization prompt
            throw new Error("The specified values of `maxTokenCountOfSummary` and `messageTokensToConsumePerSummary` are such that the summarization process could go over this model's token limit.");
          }

          let memoryIdsToSetToCurrent = [];
          let highestMemoryIndexInCurrentMemories = -1;
          // let memories = await db.memories.where({threadId});
          // memories.sort((a,b) => a.index - b.index);
          // if(aiCharacter.autoGenerateMemories === "v1") {
          //   // set isCurrent to false on all memories of this character so we can re-validate them along with the summaries - in case the thread has been edited
          //   await db.memories.where({threadId, status:"current"}).modify({status:"noncurrent"});
          //   await db.memories.where({summaryHash:"", threadId}).modify({status:"current"}); // <-- bit hacky, but this is needed for user-added memories before any summaries were done (so they don't belong to a summaryHash). could maybe make *all* user-added memories use "" (empty string) as summaryHash, but for now I just add them to the summary that they were closest to, or if there is no summary yet, then ""
          // }
          
          // get total tokens in all messages
          let initialTokenCount = await countTokensInMessages(remainingMessages, modelName);
          let currentTokenCount = initialTokenCount;
          let numTokensToSummarize; // we don't know this until we've looped through and found the first hash with no matching summary in our database
          let prevSummary;
          let prevSummaryObj;
          let prevInstructionHash;
          let instructionHashChain = [];
          let i = 0;
          let numSummariesGenerated = 0; // <-- i.e. where we didn't have an existing matching summary
          let alreadyWarnedAboutLoop = false;

          let condition = () => currentTokenCount > tokenLimitForSummaryAndMessages; // while the total token count is too high, grab batches of old messages, and summarize them
          if(continuePastCurrentSummary) condition = () => true; // we break out of the while loop when we run out of messages to summarize (or, to be more accurate, when we don't have a 'full' batch of messages to summarize)
          
          while(condition()) {
            if(signals.stop) {
              return {};
            }
            let progess = 1 - ((currentTokenCount-tokenLimitForSummaryAndMessages) / (initialTokenCount-tokenLimitForSummaryAndMessages));
            if(onProgressMessage) onProgressMessage({message:`summarizing (step ${i}, ${Math.round(progess*100)}% done)`});
            
            // grab old messages until we have at least `messageTokensToConsumePerSummary` tokens worth of text
            let messageBatchTokenCount = 0;
            let messageBatchArr = [];
            while(messageBatchTokenCount < messageTokensToConsumePerSummary) {
              if(signals.stop) {
                return {};
              }
              if(remainingMessages.length === 0) {
                if(continuePastCurrentSummary) {
                  // there isn't a full batch of messages to summarize, so we're done with the "computing ahead of current summary"
                  // it's important that we return here because there are other operations done below that we don't want to do if this is a 'continuePastCurrentSummary' type call, rather than actually getting the summary (e.g. setting the thread's currentSummaryHashChain)
                  return;
                }
                break; // no more messages
              }
              
              let m = remainingMessages[0];
              let tokens = await countTokensInMessages([m], modelName);
              if(messageBatchTokenCount > 0 && messageBatchTokenCount+tokens >= messageTokensToConsumePerSummary) {
                break; // don't add this message to the batch, because it would put us over the limit
              }

              if(messageBatchTokenCount+tokens >= messageTokensToConsumePerSummary) {
                // we were forced to add a message to the batch that puts us over the limit (since the batch would otherwise be empty), so we need to compress it:
                let newText;
                let uncompressedTextHash = await sha256Text(m.content);
                let cacheEntry = await db.textCompressionCache.where({uncompressedTextHash, modelName, tokenLimit:messageTokensToConsumePerSummary}).first();
                if(cacheEntry) {
                  newText = cacheEntry.compressedText;
                } else {
                  newText = await compressText({text:m.content, modelName, tokenLimit:messageTokensToConsumePerSummary, onProgressMessage, threadId});
                  await db.textCompressionCache.put({uncompressedTextHash, modelName, tokenLimit:messageTokensToConsumePerSummary, compressedText:newText, threadId});
                }
                m.content = newText;
                tokens = await countTokensInMessages([m], modelName);
                if(onProgressMessage) onProgressMessage({message:`summarizing (step ${i}, ${Math.round(progess*100)}% done)`});
              }

              messageBatchArr.push(m);
              messageBatchTokenCount += tokens;
              remainingMessages.shift();
            }

            if(messageBatchTokenCount > availableModels[modelName].maxSequenceLength*0.8) {
              console.error("The messageBatchTokenCount is nearly the full size of the model's token limit.");
              console.error("messageBatchTokenCount:", messageBatchTokenCount);  
            }

            let messageBatchSummarizationInstruction;
            if(aiCharacter.autoGenerateMemories === "v1") {
              if(i > 0) { // if i>0, then we have prevSummary 
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `
  Here's an overall summary of what has happened previously:

  ------
  ${prevSummary}
  ------  

  And here are some recent happenings/messages:

  ------
  ${messageBatchText}
  ------

  I have two tasks for you:

  1. Given that we already knew about the stuff in the summary, write a list of new things that we learned by reading the recent happenings/messages. Include all important details. Every learning should start with the text "We learned that".
  2. Write a new version of the above *overall* summary that integrates what has recently happened. DO NOT MISS ANY IMPORTANT DETAILS. The summary can be LONG. Retain ALL important details from the previous summary.

  Your reply should start with "NEW LEARNINGS:" and follow this exact template (nothing more, nothing less):

  NEW LEARNINGS:
  * We learned that <something we learned about the story/characters from the messages. include relevant context & info - e.g. "X happened due to Y, right after Z happened" instead of just "X happened">
  * We learned that <add another thing here. you should always reference with names instead of pronouns>
  * We learned that <write as many points as needed - don't miss any info! we want to record ALL useful information)

  NEW OVERALL SUMMARY:
  <write a new summary here - it should start with "${prevSummary.split(" ").slice(0, 5).join(" ")}..." and should include ALL the important details that were in the previous summary - it's okay for the summary to be LONG if needed>`.trim();
              } else {
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `
  Here are some messages:

  ------
  ${messageBatchText}
  ------

  I have two tasks for you:

  1. Write a list of things that a reader would learn by reading the messages. Include all important details. Every learning should start with the text "We learned that".
  2. Write a summary of the messages. DO NOT MISS ANY IMPORTANT DETAILS. The summary can be LONG.

  Your reply should start with "LEARNINGS:" and follow this exact template (nothing more, nothing less):

  LEARNINGS:
  * We learned that <something we learned about the story/characters from the messages. include relevant context & info - e.g. "X happened due to Y, right after Z happened" instead of just "X happened">
  * We learned that <add another thing here. you should always reference with names instead of pronouns>
  * We learned that <write as many points as needed - don't miss any info! we want to record ALL useful information)

  OVERALL SUMMARY:
  <write a summary here - it should include ALL the important details - it's okay for the summary to be LONG if needed>`.trim();
              }
            } else {
              if(i > 0) { // if i>0, then we have prevSummary 
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `Here's what has recently happened:\n\n------\n${messageBatchText}\n------\n\nHere's a summary of what happened previously:\n\n------\n${prevSummary}\n------\n\nPlease reply with a new version of this summary that ALSO includes what has recently happened. Include ALL the KEY details. DO NOT MISS ANY IMPORTANT DETAILS. You MUST include all the details that were in the previous summary in your response. Your response should start with "${prevSummary.split(" ").slice(0, 5).join(" ")}" and it should compress all the important details into a new summary. It's okay for the summary to be LONG if needed.`.trim();
              } else {
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `Please summarize the content of these messages:\n\n------\n${messageBatchText}\n------\n\nRespond with the summary only - nothing else. Include all relevant details. Be concise, but DO NOT leave out any important details. It's okay for the summary to be LONG if needed.`.trim();
              }
            }


            // Note: Hash corresponds to only the inputs (i.e. prevSummary and messageBatchArr).
            // User can edit summaries and that doesn't mess with our hashing stuff (if they edited a *non-latest* summary, then summaries would need to be recomputed [which wouldn't be a big deal], but they can only edit latest one anyway).
            
            // I was originally using the whole messageBatchSummarizationInstruction as the hash, but that's not ideal because then everytime I update the instruction prompt, every thread will need to have all its summaries recomputed.
            // With this approach they'll only ever need to recompute summaries and memories if the actual messages change.
            // If I ever want to force everyone to recompute summaries and memories (e.g. because I introduced a really bad bug that makes it worth it) then I can increment the summarizationVersion.
            
            // CAUTION: incrementing summarizationVersion or editing textToHash will cause everyone to need to recompute all summaries - can cost multiple dollars for very long threads.
            const summarizationVersion = 1;
            let textToHash = summarizationVersion + " " + (prevSummary || "") + messageBatchArr.map(m => m.content).join("\n\n\n");
            let hash = await sha256Text(textToHash);

            instructionHashChain.push(hash);

            if(signals.stop) {
              return {};
            }

            // check if we have a summary for this text yet
            let summaryObj = await db.summaries.get(hash);
            let summary = summaryObj?.summary;
            if(!summary) {
              if(exitOnFirstHashMissAndReturnHashChain) {
                return {instructionHashChain};
              }
              if(numTokensToSummarize === null) {
                numTokensToSummarize = currentTokenCount;
              }
              let result;
              while(1) {
                if(signals.stop) {
                  return {};
                }
                result = await getChatCompletion({
                  messages: [
                    {role: "system", content: "You are an expert text summarization assistant. You respond only with what the user requests - nothing more, nothing less."},
                    {role: "user", content: messageBatchSummarizationInstruction},
                  ],
                  modelName,
                  temperature: 0.7,
                  threadId, // just used to track token usage
                });
                if(result) break;
                if(onProgressMessage) onProgressMessage({message:`error, retrying summary...`});
                await delay(3000);
              }
              numSummariesGenerated++;
              if(!alreadyWarnedAboutLoop && numSummariesGenerated > 5*(numTokensToSummarize/messageTokensToConsumePerSummary)) { // the 5* is because it's very unlikely that each summary only consumed 1/5 of messageTokensToConsumePerSummary
                alert("The summary system might be caught in a loop? This could be a bug. If you click OK, it will continue, but please watch it to ensure it doesn't infinitely loop and spend lots of API credits.");
                alreadyWarnedAboutLoop = true;
              }
              if(aiCharacter.autoGenerateMemories === "v1") {
                let [ memoriesText, summaryText ] = result.split(/OVERALL SUMMARY:|NEW OVERALL SUMMARY:/);
                let memories = memoriesText.trim().replace(/^LEARNINGS:|NEW LEARNINGS:/, "").trim().split("\n").map(m => m.trim().replace(/^\* (We learned that )?/, "").trim()).filter(m => m);
                memories = memories.map(m => m.replace(/\n+/g, "\n")); // not ideal, but: memories cannot have two consecutive newlines, since in the memory editing UI two newlines indicate a gap between entries
                memories = memories.map(m => m[0].toUpperCase() + m.slice(1)); // capitalize first letter of each memory

                let embeddingModelName = thread.textEmbeddingModelName;

                // Warn user if they're using a non-OpenAI model and have character memories enabled (TODO: add option for locally-computed embeddings)
                if(!await threadIsUsingOpenAiModel(thread)) {
                  let userPermissionToUseOpenAiByThread = (await db.misc.get("userPermissionToUseOpenAiModelByThread")) || {};
                  if(!userPermissionToUseOpenAiByThread[thread.id]) {
                    let confirm = window.confirm(`You're using a non-OpenAI model (${thread.modelName}), but you currently have character memories enabled. Character memories currenly rely on an OpenAI API, so this message is to inform you that text from this chat will be processed via OpenAI's text embedding service. Do you want to continue?`);
                    userPermissionToUseOpenAiByThread[thread.id] = confirm;
                    await db.misc.put({key:"userPermissionToUseOpenAiModelByThread", value:userPermissionToUseOpenAiModelByThread});
                    if(!confirm) {
                      return {};
                    }
                  }
                }

                let embeddings = await embedTexts({textArr:memories, modelName:embeddingModelName, shouldCache:true});

                // let existingThreadMemories = await db.memories.where({threadId, status:"current"}).toArray();
                // existingThreadMemories.sort((a,b) => a.index - b.index);
                // let previousMemory = existingThreadMemories.at(-1);
                // let previousMemoryIndex = previousMemory ? previousMemory.index : -1;
                let i = 0;
                let memoryObjsToAdd = [];
                let previousMemoryIndex = highestMemoryIndexInCurrentMemories;
                for(let memory of memories) {
                  let embedding = embeddings[i];
                  memoryObjsToAdd.push({summaryHash:hash, threadId, text:memory, characterId, embeddings:{[embeddingModelName]:embedding}, status:"current", index:previousMemoryIndex+1, triggers:[]});
                  previousMemoryIndex++;
                  highestMemoryIndexInCurrentMemories = previousMemoryIndex;
                  addToDebugLog(`<b>added memory:</b> ${memory}`);
                  console.log("added memory:", memory);
                  i++;
                }

                if(signals.stop) {
                  return {};
                }

                await db.transaction('rw', db.memories, async tx => {
                  // counter-intuitively, in rare cases it's possible for us to already have memories for this batch of messages (i.e. for this summary hash).
                  // e.g. if the user closed the tab right as the memories were being added to the db, but the summary didn't get a chance to be added.
                  // so we delete any existing memories that we have for these messages by checking for matches on the summaryHash.
                  await tx.table("memories").where({summaryHash:hash, threadId}).delete();

                  let ids = await tx.table("memories").bulkAdd(memoryObjsToAdd, undefined, {allKeys: true});
                  memoryIdsToSetToCurrent.push(...ids);
                });

                summary = summaryText.trim();
              } else {
                summary = result.trim();
              }
              console.log("computed summary:", summary);
              addToDebugLog(`<b>computed summary:</b> ${summary}`);
              let messageIds = messageBatchArr.map(m => m.id);
              let prevSummaryHash = prevSummaryObj ? prevSummaryObj.hash : null;
              await db.summaries.put({hash, summary, threadId, messageIds, prevSummaryHash});
            } else {
              // There's already an existing summary that matches this instruction hash.
              // mark the existing memories that match this summary has as current/valid:
              let memories = await db.memories.where({summaryHash:hash, threadId}).toArray();
              for(let m of memories) {
                if(m.index > highestMemoryIndexInCurrentMemories) {
                   highestMemoryIndexInCurrentMemories = m.index;
                }
              }
              memoryIdsToSetToCurrent.push(...memories.map(m => m.id));
            }

            if(signals.stop) {
              return {};
            }

            // Compress summary if needed.
            // Note this is *outside* of the above `if` block because user will be able to adjust maxTokenCountOfSummary, and we want to re-compute/compress summaries if they change that value.
            // (this also helps with backwards-compat since maxTokenCountOfSummary previously didn't exist, we so we may need to compress some old summaries)
            if(await countTokens(summary, modelName) > maxTokenCountOfSummary) {
              addToDebugLog(`<b>summary to compress:</b> ${summary}`);
              summary = await compressText({text:summary, tokenLimit:maxTokenCountOfSummary, modelName, onProgressMessage, threadId});
              await db.summaries.where({hash}).modify({summary});
              addToDebugLog(`<b>compressed summary:</b> ${summary}`);
            }

            if(signals.stop) {
              return {};
            }
            
            summaryObj = await db.summaries.get(hash);

            // get size difference between summary and original messages
            // let summaryTokenChange = countTokens(prevSummary || "") - countTokens(summary);
            // let messageArrTokenChange = -messageBatchTokenCount; // since all these messages were "removed" (squashed into the summary)
            // let overallTokenChange = summaryTokenChange + messageArrTokenChange;
            // currentTokenCount += overallTokenChange; // overallTokenChange is almost certainly negative but we can't assume that for sure, since it's not technically *impossible* for the LLM to return a summary that's longer than message batch

            currentTokenCount = await countTokens(summary||"", modelName) + await countTokensInMessages(remainingMessages, modelName);
            prevSummary = summary;
            prevSummaryObj = summaryObj;
            prevInstructionHash = hash;
            i++;
          }

          // it's possible that there are no remainingMessages due to the summarization happening to consume them all in the final batch.
          // in this case we add some messages back until we reach the token limit.
          // it means that there will be overlap between the summary and the messages, but that's fine.
          if(remainingMessages.length === 0) {
            let messagesToMaybeAdd = originalMessagesPreparedForBot.slice(0);
            while(1) {
              let currentTokenCount = await countTokens(prevSummary||"", modelName) + await countTokensInMessages(remainingMessages, modelName);
              if(currentTokenCount >= tokenLimitForSummaryAndMessages) break;
              if(remainingMessages.length > 3) break;
              if(messagesToMaybeAdd.length === 0) break;
              remainingMessages.unshift(messagesToMaybeAdd.pop());
            }
          }

          if(signals.stop) {
            return {};
          }

          await db.transaction('rw', db.memories, async tx => {
            await tx.table("memories").where({threadId, status:"current"}).modify({status:"noncurrent"});
            await tx.table("memories").where("id").anyOf(memoryIdsToSetToCurrent).modify({status:"current"});
            await tx.table("memories").where({summaryHash:"", threadId}).modify({status:"current"}); // <-- bit hacky, but this is needed for user-added memories before any summaries were done (so they don't belong to a summaryHash). could maybe make *all* user-added memories use "" (empty string) as summaryHash, but for now I just add them to the summary that they were closest to, or if there is no summary yet, then ""
          });
          
          if(signals.stop) {
            return {};
          }

          await db.threads.where({id:threadId}).modify({currentSummaryHashChain:instructionHashChain});

          // NOTE: prevSummary can be undefined - i.e. no summaries were needed to get messages under the tokenLimitForSummaryAndMessages limit
          return {summary:prevSummary, instructionHash:prevInstructionHash, instructionHashChain, remainingMessages}; // remainingMessages = unsummarized messages (the ones that follow the summary)

        } finally {
          finalize();
        }
      }

      

      // const systemName = "System"; // name for the role:system messages (needed for non-chat models like gpt-3.5-turbo-instruct e.g. "System: Sammy has joined the chat")



      async function prepareMessagesForBot({messages, onProgressMessage}) {
        // note that we don't need to handle {{user}}/{{char}} stuff in this function because that's just for instruction, reminder, and initial messages. Initial messages have already had {{char}} stuff "rendered" when they were added to the thread.

        if(messages.length === 0) return [];

        let threadId = messages[0].threadId;

        let thread = await db.threads.get(threadId);

        let messageCharacters = await db.characters.where("id").anyOf([...new Set(messages.map(m => m.characterId))]).toArray();
        let characterIdToCharacter = {};
        for(let c of messageCharacters) {
          characterIdToCharacter[c.id] = c;
        }
        characterIdToCharacter[-1] = await getUserCharacterObj(thread.id);
        characterIdToCharacter[-2] = await getSystemCharacterObj(thread.id);

        for(let m of messages) {
          m.message = m.message.replace(/<!--hidden-from-ai-start-->.+?<!--hidden-from-ai-end-->/gs, "");
        }
        
        messages = await renderMessagesForReader({messages, reader:"ai", threadId, onProgressMessage});

        // TODO: not sure that this will work as expected for the "reply with..." function, since the in-place-of-user bot will see the hidden-from-ai messages (like the user would - do we want that?)
        messages = structuredClone(messages).filter(m => {
          if(m.hiddenFrom && m.hiddenFrom.includes("ai")) return false;
          return true;
        });

        messages = messages.map(m => {
          let role;
          if(m.characterId === -1) role = "user";
          else if(m.characterId === -2) role = "system";
          else role = "assistant";

          let name = messageObjToCharacterName(m, {thread, character:characterIdToCharacter[m.characterId]});
     
          if(name === undefined) throw new Error("message name is undefined in prepareMessagesForBot");

          name = name.replaceAll(" ", "_");
          name = name.replace(/[^A-Za-z0-9_\-]/g, ""); // <-- we need to replace invalid characters here since the name could have been set with custom code, and in that case it wouldn't have been validated as happens when name is set in the character editor UI

          return { role, content: m.message+"", name, id: m.id }; // id is used for summary upToMessageId stuff, and tracking the messages that were used in each summary and memory (brain button popup)
        });

        return messages;
      }

      async function renderMessagesForReader({messages, reader, threadId, onProgressMessage}) {
        // `reader` can be "ai" or "user"

        if(messages.length === 0) return [];

        let thread = await db.threads.get(threadId);
        let aiCharacter = await db.characters.get(thread.characterId);
        let userCharacter = await getUserCharacterObj(threadId);

        if(!aiCharacter.customCode.trim()) return messages;

        // sometimes we need to render messages for a thread that isn't active (e.g. if user clicks thread export, and then we need to compute thread.currentSummaryHashChain because it hasn't been 'lazily' upgraded yet)
        if(!customCodeIframes[threadId] && aiCharacter.customCode.trim()) {
          await createNewCustomCodeIframeForThread(threadId); // this adds iframe as here: customCodeIframes[threadId]
        }

        if(onProgressMessage) onProgressMessage({message:"waiting for custom code iframe..."});
        while(!customCodeIframes[threadId]) {
          await delay(100);
        }
        if(onProgressMessage) onProgressMessage({message:"rendering messages..."});
        let functionText = `async function({messages}) {
          let messagePromises = [];
          // we process messages in parallel, but process handlers for each message in series
          for(let message of messages) {
            messagePromises.push((async function() {
              for(let fn of oc.messageRenderingPipeline) {
                await fn({message, reader:"${reader}"});
              }
            })());
          }
          await Promise.all(messagePromises);
          return messages;
        }`;

        let originalCustomCodeFormatMessages = await messagesToCustomCodeFormat({messages});
        let functionArg = {messages:originalCustomCodeFormatMessages};
        let renderedMessagesInCustomCodeFormat = await sendCustomCodeIframeMessage(threadId, {type:"function", functionText, functionArg});

        let renderedMessages = await messagesFromCustomCodeFormat({messages:renderedMessagesInCustomCodeFormat, originalMessages:messages, threadId});

        if(!renderedMessages[0].variants) {
          throw new Error("reader message rendering shouldn't be stripping properties from messages");
        }

        return renderedMessages;
      }

      async function messagesToCustomCodeFormat({messages, thread}) {
        if(messages.length === 0) return [];
        if(!thread) {
          thread = await db.threads.get(messages[0].threadId);
        }

        let characters = await db.characters.where("id").anyOf([...new Set(messages.map(m => m.characterId))]).toArray();
        let characterIdToCharacter = {};
        for(let c of characters) {
          characterIdToCharacter[c.id] = c;
        }
        characterIdToCharacter[-1] = await getUserCharacterObj(thread.id);
        characterIdToCharacter[-2] = await getSystemCharacterObj(thread.id);

        messages = structuredClone(messages);
        messages = messages.map((m, i) => {
          let author;
          if(m.characterId == -1) author = "user";
          else if(m.characterId == -2) author = "system";
          else author = "ai";

          let name = messageObjToCharacterName(m, {thread, character:characterIdToCharacter[m.characterId]});
          
          let hiddenFrom = m.hiddenFrom || [];

          // note: we need to pass `id` to custom code because it's used in stuff like renderMessagesForReader - we could map the ids to "public" ones, but it's probably not necessary
          return {id:m.id, author, content:m.message, hiddenFrom, expectsReply:m.expectsReply, name, scene:m.scene, avatar:m.avatar, customData:m.customData, wrapperStyle:m.wrapperStyle, wrapperStyle:m.wrapperStyle, instruction:m.instruction};
        });
        return messages;
      }

      function messageObjToCharacterName(m, {thread, character}) {
        // CAUTION: If you edit this, you may need to edit the equivalent code in createMessageElement (which I haven't bothered to refactor to use this function yet)
        let name;
        if(m.characterId === -1) name = m.name ?? thread.userCharacter.name ?? character.name;
        else if(m.characterId === -2) name = m.name ?? thread.systemCharacter.name ?? character.name;
        // note that we check m.characterId===thread.characterId because thread character is special since custom code can overwrite its name with `thread.character.name`
        else name = m.name ?? (m.characterId === thread.characterId ? (thread.character.name ?? character.name) : character.name);

        return name;
      }

      async function messagesFromCustomCodeFormat({messages, originalMessages, threadId}) {
        messages = structuredClone(messages);

        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);
        let userCharacter = await getUserCharacterObj(thread.id);
        
        let messageCharacters = await db.characters.where("id").anyOf([...new Set(originalMessages.map(m => m.characterId))]).toArray();
        let characterIdToCharacter = {};
        for(let c of messageCharacters) {
          characterIdToCharacter[c.id] = c;
        }
        characterIdToCharacter[-1] = await getUserCharacterObj(thread.id);
        characterIdToCharacter[-2] = await getSystemCharacterObj(thread.id);

        let messageIdToCharacterName = {};
        for(let m of originalMessages) {
          messageIdToCharacterName[m.id] = messageObjToCharacterName(m, {thread, character:characterIdToCharacter[m.characterId]});
        }
        
        // NOTE: originalMessages is needed to "hydrate" the messages with any missing data, assuming that `messages` have `id`s (which they might not, since custom code can completely overwrite messages)
        let allOriginalMessageKeys = [...new Set(originalMessages.map(m => Object.keys(m)).flat())];
        let idToOriginalMessage = {};
        for(let m of originalMessages) {
          idToOriginalMessage[m.id] = m;
        }

        let doneSceneWarning = false;
        let doneAvatarWarning = false;

        messages = messages.map(m => {
          let originalMessage = idToOriginalMessage[m.id];

          m.characterId = -2; // default to 'system'
          if(m.author == "ai") m.characterId = originalMessage?.characterId ?? threadCharacter.id;
          if(m.author == "user") m.characterId = -1;
          delete m.author;

          if(originalMessage) {
            // if they didn't change the name, and the original name was 'null' (which is the case for 'normal' messages - i.e. messages which don't overwrite the name of the character), then we delete the name
            let nameThatWasSentToCustomCode = messageIdToCharacterName[m.id];
            if(!originalMessage.name && m.name === nameThatWasSentToCustomCode) {
              delete m.name;
            }
          }

          if(!Array.isArray(m.hiddenFrom)) {
            m.hiddenFrom = [];
          }
          m.hiddenFrom = m.hiddenFrom.filter(h => h==="ai" || h==="user");
          
          if(![true, false, undefined].includes(m.expectsReply)) {
            m.expectsReply = undefined;
          }
          
          if(m.scene) {
            let exampleStructure = {background:{url:"", filter:""}, music:{url:"", volume:0}};
            let matches = objectKeysAndTypesAreValid(m.scene, exampleStructure);
            if(!matches) {
              if(!doneSceneWarning) alert(`Invalid scene object produced by custom code. Please ensure structure and types are valid. Here's your object:\n\n${JSON.stringify(m.scene, null, 2)}\n\nAnd here's an example structure with valid types:\n\n${JSON.stringify(exampleStructure, null, 2)}\n\nYou don't need to include all properties - you just need to make sure that you don't include invalid ones, and that the types of the ones you include are valid.`);
              doneSceneWarning = true;
              m.scene = null;
            }
          } else {
            m.scene = null;
          }

          if(m.avatar) {
            let exampleStructure = {url:"", shape:"", size:0};
            let matches = objectKeysAndTypesAreValid(m.avatar, exampleStructure);
            if(!matches) {
              debugger;
              if(!doneAvatarWarning) alert(`Invalid avatar object produced by custom code. Please ensure structure and types are valid. Here's your object:\n\n${JSON.stringify(m.avatar, null, 2)}\n\nAnd here's an example structure with valid types:\n\n${JSON.stringify(exampleStructure, null, 2)}\n\nYou don't need to include all properties - you just need to make sure that you don't include invalid ones, and that the types of the ones you include are valid.`);
              doneAvatarWarning = true;
              m.avatar = {};
            }
          } else {
            m.avatar = {};
          }

          // note: it's possible for m.id to be undefined, since custom code can completely replace messages
          // but if it does exist, then we 'rehydrate' it with private data based on the `id`
          if(m.id) {
            let originalMessage = idToOriginalMessage[m.id];
            if(originalMessage) {
              for(let key of allOriginalMessageKeys) {
                // if original message had it, and new one doesn't, then we add it to the new one
                if(originalMessage.hasOwnProperty(key) && !m.hasOwnProperty(key)) {
                  m[key] = originalMessage[key];
                }
              }
            } else {
              // It's possible for the custom code to produce a message with an id that doesn't exist in the original messages because it could have "held on" to a message that existed earlier, but which not longer exists, and then pushed that on to the oc.thread.messages array layer.
              // In this case we just delete the id so that a new one message object will be generated.
              // The new message object will not inherit any of the properties of the old one, which is fine.
              delete m.id;
            }
          }

          m.threadId = threadId;
          m.message = m.content+"";
          delete m.content;
          m.wrapperStyle = (m.wrapperStyle ?? "")+"";
          m.instruction = (!m.instruction || !(m.instruction+"").trim()) ? null : m.instruction+"";

          let obj = createMessageObj(m);
          obj.id = m.id; // see messagesToCustomCodeFormat for why we need ids
          return obj;
        });

        return messages;
      }

      async function threadHasMemoriesOrLore(threadId) {
        let thread = await db.threads.get(threadId);
        let character = await db.characters.get(thread.characterId);

        let loreBookIdEntries = await db.lore.where({bookId:thread.loreBookId}).count();
        let loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(character.loreBookUrls).count();
        let memories = await db.memories.where({threadId, status:"current"}).count();

        return loreBookIdEntries > 0 || loreBookUrlEntries > 0 || memories > 0;
      }

      const retrievedMemoriesTokenLimitFraction = 0.075;

      async function getTokenLimitForSummaryAndMessages(character, thread) {

        let reminderMessage = character.reminderMessage || "";
        if(typeof thread.character.reminderMessage === "string") {
          reminderMessage = thread.character.reminderMessage;
        }

        let roleInstruction = character.roleInstruction || "";
        if(typeof thread.character.roleInstruction === "string") {
          roleInstruction = thread.character.roleInstruction;
        }

        let maxTokenLimit = availableModels[thread.modelName].maxSequenceLength;
        let tokenLimit = maxTokenLimit;
        // TODO: let user set aiCharacter.tokenLimit (via oc.character.tokenLimit) here to override this if it's smaller than the model's max token limit
        
        // buffer due to token count being an estimate
        if(thread.modelName === "gpt-4") {
          tokenLimit -= Math.round(maxTokenLimit*0.10);
        } else {
          tokenLimit -= Math.round(maxTokenLimit*0.05); // for non-gpt-4 models we have the proper tokenizer
        }

        tokenLimit -= await countTokens(roleInstruction, thread.modelName); // allow for system message tokens
        tokenLimit -= await countTokens( "("+(reminderMessage||"")+")" , thread.modelName); // allow for reminder message tokens
        tokenLimit -= Math.round(maxTokenLimit*0.15); // allow for bot response
        if(await threadHasMemoriesOrLore(thread.id)) {
          tokenLimit -= Math.round(maxTokenLimit*retrievedMemoriesTokenLimitFraction); // allow for retrieved memories
        }
        return tokenLimit;
      }

      function updateFavicon(url) {
        let link = document.querySelector("link[rel~='icon']");
        if(!link) {
          link = document.createElement('link');
          link.rel = 'icon';
          document.head.appendChild(link);
        }
        link.href = url || "./assets/privategpt128.png";
      }
      updateFavicon();

      const openAiErrorTypeToReadableError = {
        "insufficient_quota": "Looks like you've used up all your OpenAI credits. You can buy more here:\nhttps://platform.openai.com/account\n\nNote that OpenCharacters does not receive any money from this. OpenAI is the company that provides the 'brain' for your AI. OpenCharacters itself is completely free.",
      };

      let currentBotReplySignals;
      // Note: the reason this doesn't just take threadId as a param is because we use it for regenerateMessage() which doesn't necessarily use all messages in a thread, and we also use it for "reply with..." which can use a different AI character
      async function getBotReply({messages, threadId, replyingCharacter=null, replyInstruction=null, onStreamingReplyChunk, onProgressMessage, signals={}, modelNameOverride}={}) {
        currentBotReplySignals = signals;

        // NOTE: Currently, if replyingCharacter only overrides the reminder and instruction.
        // This function doesn't currently use the lorebooks of the replyingCharacter, or the modelName, or other stuff.
        // It just swaps the reminder and instruction. But could change this in the future.

        let originalSendButtonDisabledState = $.sendButton.disabled;
        $.sendButton.disabled = true;

        let thread = await db.threads.get(threadId);

        if(replyingCharacter === null) { // replyingCharacter can be passed in to this function and its reminder/instruction/etc. will be used instead of the thread character's 
          replyingCharacter = await db.characters.get(thread.characterId);
        }
        let threadCharacter = await db.characters.get(thread.characterId);
        const userCharacter = await getUserCharacterObj(thread.id);

        let fullMessagesArr = await prepareMessagesForBot({messages, onProgressMessage});

        onProgressMessage({message:"starting..."});
        
        let modelName = thread.modelName;

        if(modelNameOverride) {
          modelName = modelNameOverride;
        }
        
        let tokenLimitForSummaryAndMessages = await getTokenLimitForSummaryAndMessages(replyingCharacter, thread);
        
        console.log("getBotReply - fullMessagesArr:", fullMessagesArr);
        
        let messagesArr = [];
        let numTokensInContext = await countTokensInMessages(fullMessagesArr, modelName);

        let summaryUsed = null;
        let summaryHashUsed = null;
        
        if(numTokensInContext > tokenLimitForSummaryAndMessages) {
          let fitMessagesInContextMethod = threadCharacter.fitMessagesInContextMethod ?? "summarizeOld";
          
          if(fitMessagesInContextMethod === "dropOld") {
            // push messages into messagesArrToSend until total content reaches token limit
            numTokensInContext = 0;
            for(let i = fullMessagesArr.length-1; i >= 0; i--) {
              if(numTokensInContext + fullMessagesArr[i].content.length > tokenLimitForSummaryAndMessages) break;
              messagesArr.unshift(fullMessagesArr[i]);
              numTokensInContext += await countTokensInMessages([fullMessagesArr[i]], modelName);
            }
          } else if(fitMessagesInContextMethod === "summarizeOld") {
            
            // note: we need upToMessageId because this could be a call from regenerateMessage() which doesn't necessarily use all messages in a thread
            // upToMessageId is inclusive.
            let {summary, instructionHash, remainingMessages} = await computeAndSaveThreadSummaryIfNeeded({threadId, upToMessageId: fullMessagesArr.at(-1).id, onProgressMessage, signals});
            if(signals.stop) return {};
            if(summary === undefined) throw new Error("There should be a summary, since numTokensInContext > tokenLimitForSummaryAndMessages");
            
            summaryUsed = summary;
            summaryHashUsed = instructionHash;

            messagesArr = remainingMessages;
            messagesArr.unshift({
              role: "system",
              content: "Here's a summary of what happened previously:\n\n"+summary,
              _isSummary: true, // this is used for correct placement of memories (it's deleted before sending to API)
            });
            
          } else {
            throw new Error("Invalid fitIntoContextMethod");
          }
        } else {
          messagesArr = fullMessagesArr.slice(0);
        }

        let messageIdsUsed = [];
        for(let m of messagesArr) {
          if(m._isSummary) continue;
          if(m.id === undefined) throw new Error("Message ID is undefined.");
          messageIdsUsed.push(m.id);
        }

        if(signals.stop === true) {
          return {};
        }

        const authorToRoleMap = {
          ai: "assistant",
          user: "user",
          system: "system",
        };

        let userName = thread.userCharacter.name ?? userCharacter.name;
        let replyingCharacterName = replyingCharacter.name;
        let threadCharacterName = thread.character.name ?? threadCharacter.name;
        let systemName = thread.systemCharacter.name ?? defaultSystemName;

        let roleInstruction = replyingCharacter.roleInstruction?.trim();
        if(thread.character.roleInstruction?.trim()) roleInstruction = thread.character.roleInstruction?.trim();

        if(roleInstruction) {
          let messages = parseMessagesFromTextFormat(roleInstruction);
          if(messages === null) {
            let content = roleInstruction;
            content = content.replaceAll("{{user}}", userName);
            content = content.replaceAll("{{char}}", threadCharacterName);
            messagesArr.unshift({role:"system", content});
          } else {
            let messagesToAdd = [];
            for(let message of messages) {
              if(message.hiddenFrom?.includes("ai")) continue; // doesn't really make sense to hide from ai in reminder message - this is just to be consistent
              let content = message.content;
              content = content.replaceAll("{{user}}", userName);
              content = content.replaceAll("{{char}}", threadCharacterName);
              messagesToAdd.push({role:authorToRoleMap[message.author], content});
              // can't just unshift on to messagesArr here because messages would be in wrong order
            }
            messagesArr = [...messagesToAdd, ...messagesArr];
          }          
        }

        let reminderMessage = replyingCharacter.reminderMessage?.trim();
        if(thread.character.reminderMessage?.trim()) reminderMessage = thread.character.reminderMessage?.trim();

        if(reminderMessage) {
          let messages = parseMessagesFromTextFormat(reminderMessage);
          if(messages === null) {
            let content = reminderMessage;
            content = content.replaceAll("{{user}}", userName);
            content = content.replaceAll("{{char}}", threadCharacterName);
            messagesArr.push({role:"system", content, _isReminder:true});
          } else {
            for(let message of messages) {
              if(message.hiddenFrom?.includes("ai")) continue; // doesn't really make sense to hide from ai in reminder message - this is just to be consistent
              let content = message.content;
              content = content.replaceAll("{{user}}", userName);
              content = content.replaceAll("{{char}}", threadCharacterName);
              messagesArr.push({role:authorToRoleMap[message.author], content, _isReminder:true});
            }
          }          
        }

        for(let m of messagesArr) {
          delete m.id; // id is added by prepareMessagesForBot() because it's needed for some functions (e.g. summarization), but we don't want to send it to the API
        }

        // this is already done in prepareMessagesForBot() but we do it again here to ensure we've removed hidden stuff from reminder message, instruction message, etc.
        for(let m of messagesArr) {
          m.content = m.content.replace(/<!--hidden-from-ai-start-->.+?<!--hidden-from-ai-end-->/gs, "");
        }

        let postReminderMessageContent;
        if(replyingCharacterName !== threadCharacterName || new Set(messagesArr.map(m => m.name)).size > 2) {
          postReminderMessageContent = `The next message will be written by ${replyingCharacterName}.`;
        }
        if(replyInstruction) {
          postReminderMessageContent += ` The next message should be written according to this instruction: ${replyInstruction}.`;
        }
        if(postReminderMessageContent) {
          messagesArr.push({role:"system", content:"("+postReminderMessageContent+")"});
        }


        let memoryIdBatchesUsed = [];
        let loreIdsUsed = [];
        let memoryQueriesUsed = [];

        let loreBookIdEntries = await db.lore.where({bookId:thread.loreBookId}).toArray();
        let loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(threadCharacter.loreBookUrls).toArray();
        let loreEntries = [...loreBookIdEntries, ...loreBookUrlEntries];
        let memories = await db.memories.where({threadId, status:"current"}).toArray();
        memories.sort((a,b) => a.index - b.index);
        if(memories.length > 0 || loreEntries.length > 0) {
          onProgressMessage({message:"get mem/lore queries"});

          memories.forEach(m => m._type="memory");
          loreEntries.forEach(m => m._type="lore");
          let memoriesAndLore = [...memories, ...loreEntries];

          // NOTE: I replace newlines in messages with spaces because I *think* the AI was getting confused about the structure of the messages
          const messagesToTextFormat = (messages) => messages.filter(m => !m._isReminder).slice(-10).map(m => `[[${m.name || "System"}]]: ${m.content.replace(/\n/g, " ")}`).join("\n\n");
          
          let mostRecentMessage = messagesArr.filter(m => m.role === "user" && !m._isReminder).at(-1);
          if(!mostRecentMessage) mostRecentMessage = messagesArr.at(-1);

          let searchQueries = [];
          
          // get memory search queries:
          let rawResult = await getChatCompletion({
            messages: [
              {role:"user", content: `Here's the list of messages:\n\n${messagesToTextFormat(messagesArr)}\n\n(this is the end of the messages)`},
              // {role:"user", content: `${replyingCharacterName} will reply next. ${replyingCharacterName} is actually an AI/bot who has a database of memories. Please write a list of suggested keyphrases to help ${replyingCharacterName} search their memory database for facts that may be relevant to their reply. Try to surface facts that are relevant to their *very next* message - rephrase/reword keyphrases multiple times if needed. Look for specific entities/things/claims/topics/people/places/questions/etc. in the previous message (the one ending with "...${mostRecentMessage.content.slice(-100)}" and the ones before that) that may be important. Write several rephrasings of important queries. No need to query for stuff that you already know the answer to. Reply with this template:\n\nMEMORY SEARCH KEYPHRASES:\n- <keyphrase 1>\n- <keyphrase 2>\n- ...`},
              // {role:"user", content: `The next message will come from ${replyingCharacterName}. If you were tasked with writing that message as ${replyingCharacterName}, and you had access to a database of ${replyingCharacterName}'s memories, what search queries would you use on that database? Respond with a list of keyphrases that you would use to search the memory database for things that would be useful if you were trying to write an accurate/in-character/correct message as ${replyingCharacterName}. Try to surface facts that are relevant to their *very next* message - rephrase/reword keyphrases multiple times if needed. Look for specific entities/things/claims/topics/people/places/questions/etc. in the previous message (the one ending with "...${mostRecentMessage.content.slice(-100)}" and the ones before that) that may be important. Write several rephrasings of important queries. Try to search the database for things you don't know, but which might be important for writing a reply that makes sense. Reply with this template:\n\nMEMORY SEARCH KEYPHRASES:\n- <keyphrase 1>\n- <keyphrase 2>\n- ...`},
              {role:"user", content: `You are tasked with writing the next message on behalf of ${replyingCharacterName}. However, there is a large database of memories/lore/facts/etc. which you'll need to use to make sure your reply makes sense, and doesn't contradict established facts/lore/memories. Respond with a list of keyphrases that you would like to use to search the database for useful information. Try to surface facts that are relevant to ${replyingCharacterName}'s *very next* message - rephrase/reword keyphrases multiple times if needed. Look for specific entities/things/claims/topics/people/places/questions/etc. in the previous message (the one ending with "...${mostRecentMessage.content.slice(-100)}" and the ones before that) that may be important. Write several rephrasings of important queries. Try to search the database for things you don't know, but which might be important for writing a reply that doesn't contradict established world lore/facts/etc. Reply with this template:\n\nMEMORY SEARCH KEYPHRASES:\n- <keyphrase 1>\n- <keyphrase 2>\n- ...`},
            ],
            modelName,
            temperature: 0.7,
            threadId, // just used to track token usage
            signals,
          });
          if(!rawResult) {
            if(!signals.stop) alert("There was an error getting the memory search queries. Please try again.");
            return {};
          }

          if(signals.stop === true) return {};

          onProgressMessage({message:"got queries"});

          searchQueries.push(...rawResult.trim().split("\n").filter(l => l.startsWith("- ") || l.startsWith(" - ")).map(l => l.trim().replace(/^ ?- /, "").trim()).slice(0, 10));

          searchQueries = searchQueries.map(q => q.replace(/^"(.+)"$/, "$1"));

          console.log(`MEMORY/LORE SEARCH QUERIES:\n${searchQueries.join("\n")}`);
          addToDebugLog(`<b>Memory queries:</b><br>${searchQueries.join("<br>")}`);

          memoryQueriesUsed.push(...searchQueries);

          onProgressMessage({message:"embed queries"});

          let embeddingModelName = thread.textEmbeddingModelName;
          let searchEmbeddings = await embedTexts({textArr:searchQueries, modelName:embeddingModelName});

          if(signals.stop === true) return {};

          const scoreThreshold = 0; // this is zero now because we subtract the average inverseDistance from the score when computing the score
          console.log("memory/lore score threshold:", scoreThreshold);

          onProgressMessage({message:"calc mem/lore scores"});

          for(let entry of memoriesAndLore) {
            if(!entry.embeddings[embeddingModelName]) {
              // embeddings should have been computed during addThread
              if(entry._type === "memory") {
                throw new Error(`memory doesn't have embedding for model ${embeddingModelName}:\ntext:${entry.text}`);
              } else {
                throw new Error(`lore doesn't have embedding for model ${embeddingModelName}:\ntext:${entry.text}\nbookUrl:${entry.bookUrl}\nbookId:${entry.bookId}`);
              }
            }
          }

          for(let entry of memoriesAndLore) {
            if(entry._relevanceScore === undefined) entry._relevanceScore = 0;
            let i = 0;
            for(let searchEmbedding of searchEmbeddings) {
              let multiplier = 1;
              if(i === 0) multiplier = 3; // first search query is likely to be much more relevant (later ones tend to be grasping at straws)
              let inverseDistance = (1 / cosineDistance(searchEmbedding, entry.embeddings[embeddingModelName]));
              let score = (inverseDistance-4) * multiplier; // subtract 4 because that seems to be roughly the average distance between two random embeddings
              entry._relevanceScore += score;
              i++;
            }

            // for debugging:
            if(memoriesAndLore.length < 100) console.log(`score of ${entry._relevanceScore.toFixed(1)} for this ${entry._type} entry: ${entry.text}`);
          }
          
          let relevantMemoriesAndLore = memoriesAndLore.filter(m => m._relevanceScore > scoreThreshold).sort((a, b) => b._relevanceScore - a._relevanceScore);
          console.log("relevant memories/lore:", relevantMemoriesAndLore.slice(0, 1000));

          onProgressMessage({message:"get top mem/lore"});

          let relevantMemories = relevantMemoriesAndLore.filter(m => m._type === "memory");
          let relevantLore = relevantMemoriesAndLore.filter(m => m._type === "lore");
          
          // we create "batches" of memories - i.e. chronologically ordered groups of memories that are relevant and adjacent
          // use top memories as "seeds" for each batch:
          // CAUTION: We need to `slice(0, 20)` not to stay under token limit (we drop them later if there are too many), but because we extend batches based on adjacent memories that occur in `memoryBatches`, and that can result in a looonng loop if we include every memory as a batch.
          let memoryBatches = relevantMemories.slice(0, 20).sort((a,b) => a.index-b.index).map(m => ({memories:[m], seedMemory:m}));
          memoryBatches.sort((a,b) => b.seedMemory._relevanceScore - a.seedMemory._relevanceScore);

          let maxMemoryIndex = memories.at(-1)?.index ?? 0;
          let minMemoryIndex = memories[0]?.index ?? 0; // note: the term `index` is actually a misnomer here - should be `order` or something, since the `status:"noncurrent"` memories can create gaps in the `status:"current"` memories.

          for(let i = 0; i < memoryBatches.length; i++) {
            let batch = memoryBatches[i];
            let numPreviousAdded = 0;
            let numNextAdded = 0;
            let numPreviousToAdd = 1;
            let numNextToAdd = 1;
            let addedNext;
            let addedPrevious;
            while(true) {
              if(batch.memories.length >= 1+numPreviousToAdd+numNextToAdd) break;
              addedNext = false;
              addedPrevious = false;

              if(numNextAdded < numNextToAdd) {
                let lastMemory = batch.memories.at(-1);
                if(lastMemory === undefined) debugger;
                let mI = memories.findIndex(m => m === lastMemory);
                if(memories[mI+1]) {
                  batch.memories.push(memories[mI+1]);
                  addedNext = true;
                  numNextAdded++;
                }
              }

              if(numPreviousAdded < numPreviousToAdd) {
                let firstMemory = batch.memories[0];
                if(firstMemory === undefined) debugger;
                let mI = memories.findIndex(m => m === firstMemory);
                if(memories[mI-1]) {
                  batch.memories.unshift(memories[mI-1]);
                  addedPrevious = true;
                  numPreviousAdded++;
                }
              }

              // if we added a nextMemory or previousMemory that's the same as one of the seeds in the batches that
              // we haven't processed yet, then we should remove that batch and widen the limits on this batch
              if(addedNext) {
                let lastMemory = batch.memories.at(-1);
                let batchToRemove = memoryBatches.slice(i+1).find(b => b.seedMemory.id === lastMemory.id);
                if(batchToRemove) {
                  memoryBatches.splice(memoryBatches.indexOf(batchToRemove), 1);
                  numNextToAdd++;
                }
              }
              if(addedPrevious) {
                let firstMemory = batch.memories[0];
                let batchToRemove = memoryBatches.slice(i+1).find(b => b.seedMemory.id === firstMemory.id);
                if(batchToRemove) {
                  memoryBatches.splice(memoryBatches.indexOf(batchToRemove), 1);
                  numPreviousToAdd++;
                }
              }

              if(!addedNext && !addedPrevious) break;
            }
          }

          for(let batch of memoryBatches) {
            // use the max rather than the mean, because the memories around a SUPER-relevant memory could be irrelevant (at least, score-wise) and thus drag it down
            batch._relevanceScore = batch.memories.reduce((max, m) => Math.max(max, m._relevanceScore), -99999999);
          }
          memoryBatches.sort((a,b) => b._relevanceScore - a._relevanceScore);
          relevantLore.sort((a,b) => b._relevanceScore - a._relevanceScore);

          console.log("memoryBatches:", memoryBatches.slice(0));
          console.log("relevantLore:", relevantLore.slice(0));
          if(memoryBatches.length > 0 || relevantLore.length > 0) {
            
            let retrievalPrefixText = `Some potentially helpful things/facts/happenings that may or may not be relevant:`;
            let memoryPrefixText = `# Some stuff that happened previously:\n`;
            let lorePrefixText = `# A fact or piece of world 'lore':\n`;
            let memoryJoinerText = ` → `;

            const createMemoriesAndLoreMessageContent = () => {
              if(memoryBatches.length === 0 && relevantLore.length === 0) return "";

              let chunks = [retrievalPrefixText];
              if(memoryBatches.length > 0) {
                for(let batch of memoryBatches) {
                  chunks.push(`${memoryPrefixText}${batch.memories.map(m => m.text).join(memoryJoinerText)}`);
                }
              }
              if(relevantLore.length > 0) {
                for(let entry of relevantLore) {
                  chunks.push(`${lorePrefixText}${entry.text}`);
                }
              }
              return chunks.join("\n\n");
            };

            onProgressMessage({message:"dropping mem/lore"});
            await delay(10); // to ensure progress message is rendered in case of infinite loop below - helpful for bug reports

            for(let batch of memoryBatches) {
              for(let memory of batch.memories) {
                memory._tokenCount = await countTokens(memory.text, modelName);
              }
            }
            for(let entry of relevantLore) {
              entry._tokenCount = await countTokens(entry.text, modelName);
            }
            let retrievalPrefixTextTokenCount = await countTokens(retrievalPrefixText, modelName);
            let memoryPrefixTextTokenCount = await countTokens(memoryPrefixText, modelName);
            let lorePrefixTextTokenCount = await countTokens(lorePrefixText, modelName);
            let memoryJoinerTokenCount = await countTokens(memoryJoinerText, modelName);

            function countTokensInRetrievalText() {
              let tokensInPrefixes = retrievalPrefixTextTokenCount + memoryPrefixTextTokenCount*memoryBatches.length + lorePrefixTextTokenCount*relevantLore.length;
              let tokensInMemories = memoryBatches.reduce((count, b) => count + b.memories.reduce((count, m) => count+m._tokenCount, 0), 0);
              let tokensInLore = relevantLore.reduce((count, e) => count + e._tokenCount, 0);
              let tokensInJoiners = memoryJoinerTokenCount*(memoryBatches.length-1);
              return tokensInPrefixes + tokensInMemories + tokensInLore + tokensInJoiners;
            }

            let retrievalTextTokenCount;

            function dropBatchOrMemoryFromBatch() {
              let b = memoryBatches.pop();
              let tokensInDroppedBatch = b.memories.reduce((count, m) => count+m._tokenCount, 0);
              if(tokensInDroppedBatch > 0.3*retrievalTextTokenCount) {
                // if the dropped batch is a significant fraction of the total, then we should just drop one memory from it instead - the one from either end that has lowest score
                if(b.memories.at(0)._relevanceScore < b.memories.at(-1)._relevanceScore) {
                  b.memories.shift();
                } else {
                  b.memories.pop();
                }
                if(b.memories.length > 0) {
                  memoryBatches.push(b);
                }
              }
            }
            
            // drop worst entries/batches until we're under token limit allocated to memories:
            while(1) {
              retrievalTextTokenCount = await countTokensInRetrievalText();
              if(retrievalTextTokenCount < retrievedMemoriesTokenLimitFraction * availableModels[modelName].maxSequenceLength) {
                break;
              }

              if(relevantLore.length === 0) {
                dropBatchOrMemoryFromBatch();
              } else if(memoryBatches.length === 0) {
                relevantLore.pop();
              } else {
                if(memoryBatches.at(-1)._relevanceScore < relevantLore.at(-1)._relevanceScore) dropBatchOrMemoryFromBatch();
                else if(memoryBatches.at(-1)._relevanceScore >= relevantLore.at(-1)._relevanceScore) relevantLore.pop();
                else throw new Error("This shouldn't happen - weird relevance score bug while dropping memories/lore.");
              }
            }
            // put memoryBatches in chronological order:
            memoryBatches.sort((a,b) => a.seedMemory.id - b.seedMemory.id);
            if(memoryBatches.length > 0 || relevantLore.length > 0) {

              // batch merging:
              for(let i = 0; i < memoryBatches.length; i++) {
                let batch = memoryBatches[i];
                // if any of the memories in this batch are in the next batch, then we should remove the overlapping memories from the next batch and then add the remaining memories to this batch:
                let nextBatch = memoryBatches[i+1];
                if(nextBatch) {
                  let memoryIdsInThisBatch = batch.memories.map(m => m.id);
                  let memoryIdsInNextBatch = nextBatch.memories.map(m => m.id);
                  let thereAreOverlappingMemories = memoryIdsInThisBatch.some(id => memoryIdsInNextBatch.includes(id));
                  if(thereAreOverlappingMemories) {
                    // add the non-overlapping memories to this batch:
                    batch.memories.push(...nextBatch.memories.filter(m => !memoryIdsInThisBatch.includes(m.id)));
                    // as a quick sanity check, ensure that all memory.index values are larger than the previous one:
                    for(let j = 1; j < batch.memories.length; j++) {
                      if(batch.memories[j].index <= batch.memories[j-1].index) {
                        console.error("memory.index values are not in chronological order - during memory batch merging");
                        debugger; // this shouldn't happen
                      }
                    }
                    // remove next batch:
                    memoryBatches.splice(i+1, 1);
                    // we need to re-check this batch against the next batch, so decrement i:
                    i--;
                  }
                }
              }

              memoryIdBatchesUsed = memoryBatches.map(b => b.memories.map(m => m.id));
              loreIdsUsed = relevantLore.map(l => l.id);

              if(memoryIdBatchesUsed.flat().filter(id => id === undefined).length > 0) {
                debugger; // this shouldn't happen
              }

              let summaryMessageIndex = messagesArr.findIndex(m => m._isSummary);
              let content = createMemoriesAndLoreMessageContent();
              if(content) {
                let memoriesMessage = {role:"system", content};
                if(summaryMessageIndex === -1) {
                  // this can happen if the user has manually added memories before the summarization stuff has started
                  messagesArr.unshift(memoriesMessage);
                } else {
                  // insert memories message after summary message:
                  messagesArr.splice(summaryMessageIndex+1, 0, memoriesMessage);
                }
              }
            }
          }
        }

        if(signals.stop === true) {
          return {};
        }

        for(let message of messagesArr) {
          // _isSummary and _isReminder are used above for memory stuff
          if(message._isSummary !== undefined) delete message._isSummary;
          if(message._isReminder !== undefined) delete message._isReminder;
        }

        onProgressMessage({message:"querying api..."});

        console.log("getBotReply - messagesArr:", messagesArr);

        let modelObj = availableModels[modelName];
        let apiKey = modelObj.apiKey;
        
        if(apiKey === "<OPENAI>") {
          apiKey = await getOpenAiApiKey();
        }

        async function handleStreamingResponse(reader) {
          result = ""; // `result` comes from parent scope
          let chunkI = 0;
          let prevText = null;
          let textBuffer = "";
          const streamId = (await sha256Text(Math.random().toString()+Math.random().toString())).slice(0, 16);

          function processLine(line) {
            if(!line.trim()) return;
            if(line.startsWith("data: ")) line = line.slice(6);
            if(line === "[DONE]") return;

            let json;
            try {
              json = JSON.parse(line);
            } catch(e) {
              alert(`The streaming API response had some invalid JSON:\n\n${line}\n\n---\n\n${textBuffer}`);
              console.error(e, line, textBuffer);
            }
            let text;

            if(json.choices[0].text !== undefined) { // this indicates that we're streaming from a 'completion' (non-chat) model
              text = json.choices[0].text;
              if(chunkI===0) text = text.trimStart(); // trimStart due to the way we prompt 'completion' models (we show messages with a space after `[name]:`)
            } else {
              if(json.choices[0].delta.role) return; // first response always starts with a role=assistant delta to indicate that the assistant is the one talking
              if(!json.choices[0].delta.content) return; // final response alway has empty delta object
              text = json.choices[0].delta.content;
            }
            
            result += text;
            onStreamingReplyChunk({text, isFirst:chunkI===0});

            // we keep the StreamingMessageChunk events "one step behind" so that we can set last:true on the last chunk
            if(prevText === null) {
              prevText = text;
            } else {
              triggerStreamingMessageChunkCustomCodeEvent(threadId, {text:prevText, index:chunkI-1, last:false, streamId});
              prevText = text;
            }

            chunkI++;
          }

          while(true) {
            const res = await reader?.read();
            if(res?.done) {
              // process all remaining lines:
              for(let line of textBuffer.split("\n")) {
                processLine(line);
              }
              break;
            }
            if(chunkI === 0 && res?.value.trim().startsWith("{")) { // errors don't start with 'data'
              let json = JSON.parse(res.value);
              if(!signals.stop) alert("Error streaming message:\n\n"+JSON.stringify(json.error, null, 2));
              break;
            } else {
              textBuffer += res.value;

              // keep consuming up to first new line while a newline exists:
              while(textBuffer.indexOf("\n") !== -1) {
                let newLineIndex = textBuffer.indexOf("\n");
                let line = textBuffer.slice(0, newLineIndex);
                textBuffer = textBuffer.slice(newLineIndex+1);
                processLine(line);
              }
            }
            if(signals.stop === true) {
              break;
            }
          }
          triggerStreamingMessageChunkCustomCodeEvent(threadId, {text:prevText, index:chunkI-1, last:true, streamId});
        }


        let modelType = availableModels[modelName].type;
        if(!modelType) throw new Error("modelType is undefined for model "+modelName);
        let getStreamingResponse = threadCharacter.streamingResponse;

        let result = undefined;
        let apiTokenUsage;

        let headers = {"Content-Type": "application/json"};
        if(apiKey) headers.authorization = `Bearer ${apiKey}`;
        if(apiKey && new URL(modelObj.endpointUrl).hostname.includes("azure")) headers["api-key"] = apiKey;

        let abortController = new AbortController();
        let abortSignal = abortController.signal;
        let abortCheckInterval = setInterval(() => {
          if(signals.stop) {
            abortController.abort();
            clearInterval(abortCheckInterval);
          }
        }, 100);
        setTimeout(() => {
          clearInterval(abortCheckInterval); // hacky, but just in case this code below throws an error before it reaches the clearInterval
        }, 1000*60*10) // <-- must be longer than the longest possible response time

        if(modelType === "chat-completion") {

          let tokensInPrompt = await countTokensInMessages(messagesArr, modelName);

          let data = {
            model: modelName,
            messages: messagesArr,
            temperature: replyingCharacter.temperature ?? 0.7,
          };
          if(replyingCharacter.topP) data.top_p = replyingCharacter.topP;
          if(replyingCharacter.frequencyPenalty) data.frequency_penalty = replyingCharacter.frequencyPenalty;
          if(replyingCharacter.presencePenalty) data.presence_penalty = replyingCharacter.presencePenalty;
          if(replyingCharacter.stopSequences && replyingCharacter.stopSequences.length > 0) data.stop = replyingCharacter.stopSequences;

          if(replyingCharacter.maxTokensPerMessage) {
            // note that the chat completion endpoint defaults to unlimited max_tokens (i.e. uses [up to] the full context size), so we only need to mess with it if the user has set a limit
            let max_tokens = Math.round((availableModels[modelName].maxSequenceLength - tokensInPrompt) * 0.95); // *0.95 just to add a bit of a buffer in case of a few off-by-one errors, or whatever
            if(max_tokens > replyingCharacter.maxTokensPerMessage) {
              max_tokens = replyingCharacter.maxTokensPerMessage;
            }
            data.max_tokens = max_tokens;
          }

          if(getStreamingResponse) {
            data.stream = true;
            apiTokenUsage = {prompt:tokensInPrompt, completion:0, total:tokensInPrompt};
            
            let response = await fetch(modelObj.endpointUrl, {
              headers,
              body: JSON.stringify(data),
              method: "POST",
              signal: abortSignal,
            }).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:chat:streaming > fetch: \n\n"+e.stack);
              }
            });
            
            if(response) { // <-- e.g. request was aborted by user
              const reader = response.body?.pipeThrough(new TextDecoderStream()).getReader();
              await handleStreamingResponse(reader).catch(e => {  // this appends chunks to the `result` variable
                if(!signals.stop) alert("getBotReply > modelType:chat > handleStreamingResponse:\n\n"+e.stack);
              });
              apiTokenUsage.completion += await countTokens(result, modelName);
              apiTokenUsage.total += await countTokens(result, modelName);
            }
            
          } else {
            let json = await fetch(modelObj.endpointUrl, {
              method: 'POST',
              headers,
              body: JSON.stringify(data),
              signal: abortSignal,
            }).then(r => r.json()).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:chat:non-streaming > fetch: \n\n"+e.stack);
              }
            });

            if(json?.error) {
              console.error(json.error);
              if(!signals.stop) alert(`Error during getBotReply:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
            }
            if(json?.usage) {
              apiTokenUsage = {prompt:json?.usage.prompt_tokens, completion:json?.usage.completion_tokens, total:json?.usage.total_tokens};
            }
            result = json?.choices?.[0].message.content;
          }

        } else {

          let promptIntro = `Below are some message logs between ${replyingCharacterName} and other characters. Some messages are "System" messages which do not originate from any character.\n\nThe chat begins now:\n\n\n\n`;
          let prompt = promptIntro + messagesArr.map(m => (m.role=="user"?`[[${m.name ?? userName}]]: `:m.role=="system"?`[[SYSTEM]]: `:`[[${m.name}]]: `)+m.content).join("\n\n") + `\n\n[[${replyingCharacterName}]]:`;
          
          // davinci *requires* max_tokens else it defaults to 16 (unlike turbo which defaults to infinity)
          let max_tokens = Math.round((availableModels[modelName].maxSequenceLength - await countTokens(prompt, modelName)) * 0.95); // *0.95 just to add a bit of a buffer in case of a few off-by-one errors, or whatever
          
          if(replyingCharacter.maxTokensPerMessage && max_tokens > replyingCharacter.maxTokensPerMessage) {
            max_tokens = replyingCharacter.maxTokensPerMessage;
          }

          let data = {
            model: modelName,
            prompt,
            temperature: replyingCharacter.temperature ?? 0.7,
            stop: [`\n\n[[`],
            max_tokens,  // see note above
          };
          if(replyingCharacter.topP) data.top_p = replyingCharacter.topP;
          if(replyingCharacter.frequencyPenalty) data.frequency_penalty = replyingCharacter.frequencyPenalty;
          if(replyingCharacter.presencePenalty) data.presence_penalty = replyingCharacter.presencePenalty;
          if(replyingCharacter.stopSequences && replyingCharacter.stopSequences.length > 0) data.stop.push(...replyingCharacter.stopSequences);

          if(getStreamingResponse) {
            data.stream = true;
            let tokensInPrompt = await countTokensInMessages(messagesArr, modelName);
            apiTokenUsage = {prompt:tokensInPrompt, completion:0, total:tokensInPrompt};

            let response = await fetch(modelObj.endpointUrl, {
              headers,
              body: JSON.stringify(data),
              method: "POST",
              signal: abortSignal,
            }).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:general:streaming > fetch: \n\n"+e.stack);
              }
            });
            
            if(response) { // <-- e.g. request was aborted by user
              const reader = response.body?.pipeThrough(new TextDecoderStream()).getReader();
              await handleStreamingResponse(reader).catch(e => {  // this appends chunks to the `result` variable
                if(!signals.stop) alert("getBotReply > modelType:chat > handleStreamingResponse:\n\n"+e.stack);
              });
              apiTokenUsage.completion += await countTokens(result, modelName);
              apiTokenUsage.total += await countTokens(result, modelName);
            }

          } else {
            let json = await fetch(modelObj.endpointUrl, {
              method: "POST",
              headers,
              body: JSON.stringify(data),
              signal: abortSignal,
            }).then(r => r.json()).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:general:non-streaming > fetch: \n\n"+e.stack);
              }
            });
            
            if(json?.error) {
              console.error(json.error);
              if(!signals.stop) alert(`Error during getBotReply:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
            }

            if(json?.usage) {
              apiTokenUsage = {prompt:json?.usage.prompt_tokens, completion:json?.usage.completion_tokens, total:json?.usage.total_tokens};
            }
            result = json?.choices?.[0].text.trim();
          }
        }

        if(apiTokenUsage) {
          await trackTokenUsage({threadId, modelName, usageData:apiTokenUsage});
        }
        
        onProgressMessage({message:"finished"});

        // sometimes the gpt-turbo / chat models prefix messages with "characterName:"
        if(result && result.startsWith(`${replyingCharacterName}:`)) {
          result = result.slice(replyingCharacterName.length+1).trim();
        }

        clearInterval(abortCheckInterval);

        $.sendButton.disabled = originalSendButtonDisabledState;

        return {message:result, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed};
      }

      function getCurrentDateHour() {
        // get date object, rounded down to nearest hour
        let date = new Date();
        date.setMinutes(0, 0, 0); // set minutes, seconds, ms, all to 0
        return date.getTime();
      }

      async function trackTokenUsage({threadId, modelName, usageData}) {
        // get the character id:
        let thread = await db.threads.get(threadId);
        let characterId = thread.characterId;
        // get current usage:
        let dateHour = getCurrentDateHour();
        let entry = await db.usageStats.get({dateHour, threadId, modelName});
        // create entry if it doesn't exist:
        if(!entry) {
          entry = {dateHour, threadId, modelName, characterId, tokens:{prompt:0, completion:0, total:0}};
          await db.usageStats.add(entry);
        }
        // update db with new usage:
        entry.tokens.completion += usageData.completion;
        entry.tokens.prompt += usageData.prompt;
        entry.tokens.total += usageData.total;
        // need to use `where+modify` instead of `update` because I can't update schema to change the mistaken primary key of threadId to [dateHour+threadId+modelName] without making a mess: https://github.com/dexie/Dexie.js/issues/1025
        // await db.usageStats.where({dateHour, threadId, modelName}).modify(e => e.tokens=entry.tokens);
        await db.usageStats.put(entry);
        // update ui:
        await updateThreadUsageStatsSpendDisplay(threadId);
      }


      async function getChatCompletion(opts) {
        if(!opts.signals) opts.signals = {};
        if(opts.attemptsSoFar === undefined) opts.attemptsSoFar = 0;
        if(opts.maxAttempts === undefined) opts.maxAttempts = 2;
        let {messages, modelName, temperature, stopSequences, topP, frequencyPenalty, presencePenalty, threadId, retries, triesAttempted, signals} = opts;
        // note: threadId is just for tracking token usage

        messages = structuredClone(messages);

        messages = messages.filter(m => !m.hiddenFrom || !m.hiddenFrom.includes("ai"));

        for(let m of messages) {
          m.content = m.content.replace(/<!--hidden-from-ai-start-->.+?<!--hidden-from-ai-end-->/gs, "");
        }

        let modelObj = availableModels[modelName];
        let apiKey = modelObj.apiKey;
        if(apiKey === "<OPENAI>") {
          apiKey = (await db.misc.get("openAiApiKey"))?.value;
        }

        let modelType = availableModels[modelName].type;
        if(!modelType) throw new Error("modelType not found for model: "+modelName);

        let result;
        let apiTokenUsage;

        let headers = {"content-type": "application/json"};
        if(apiKey) headers.authorization = `Bearer ${apiKey}`;
        if(apiKey && new URL(modelObj.endpointUrl).hostname.includes("azure")) headers["api-key"] = apiKey;

        let abortController = new AbortController();
        let abortSignal = abortController.signal;
        let abortCheckInterval = setInterval(() => {
          if(signals.stop) {
            abortController.abort();
            clearInterval(abortCheckInterval);
          }
        }, 100);
        setTimeout(() => {
          clearInterval(abortCheckInterval); // hacky, but just in case this code below throws an error before it reaches the clearInterval
        }, 1000*60);

        if(modelType === "chat-completion") {

          let data = {
            model:modelName,
            messages,
            temperature: temperature ?? 0.7,
          };
          if(stopSequences) data.stop = stopSequences;
          if(topP) data.top_p = topP;
          if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
          if(presencePenalty) data.presence_penalty = presencePenalty;

          let json = await fetch(modelObj.endpointUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(data),
            signal: abortSignal,
          }).then(r => r.json()).catch(e => {
            if(!signals.stop) {
              if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
              else alert("getChatCompletion: "+e.stack);
            }
          });
          
          if(json?.error) {
            console.error(json.error);
            alert(`Error during getChatCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
          }

          apiTokenUsage = json?.usage;

          result = json?.choices?.[0].message.content;

        } else {

          let aiName = messages.find(m => m.role === "ai")?.name ?? "Assistant";
          let userName = messages.find(m => m.role === "user")?.name ?? "User";
          let systemName = messages.find(m => m.role === "system")?.name ?? defaultSystemName;
          let messagesFinal = structuredClone(messages);
          for(let m of messagesFinal) {
            if(m.role === "ai" && !m.name) m.name = aiName;
            if(m.role === "user" && !m.name) m.name = userName;
            if(m.role === "system" && !m.name) m.name = systemName;
          }

          let data = {
            model:modelName,
            prompt: messagesFinal.map(m => `[[${m.name}]]: ${m.content}`).join("\n\n") + `\n\n[[${aiName}]]: `,
            temperature: temperature ?? 0.7,
            stop: [`\n\n[[`],
          };
          if(stopSequences) data.stop.push(...stopSequences);
          if(topP) data.top_p = topP;
          if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
          if(presencePenalty) data.presence_penalty = presencePenalty;

          let json = await fetch(modelObj.endpointUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(data),
            signal: abortSignal,
          }).then(r => r.json()).catch(e => {
            if(!signals.stop) {
              if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
              else alert("getChatCompletion > modelType:general > fetch: \n\n"+e.stack);
            }
          });
          
          if(json?.error) {
            console.error(json.error);
            alert(`Error during getChatCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
          }

          apiTokenUsage = json?.usage;

          result = json?.choices?.[0].text.trim();
        }

        if(apiTokenUsage) {
          let usageData = {prompt:apiTokenUsage.prompt_tokens, completion:apiTokenUsage.completion_tokens, total:apiTokenUsage.total_tokens};
          await trackTokenUsage({threadId, modelName, usageData});
        }

        opts.attemptsSoFar++;

        if(!result) {
          if(opts.attemptsSoFar >= opts.maxAttempts) {
            return null;
          } else {
            return await getChatCompletion(opts);
          }
        }

        clearInterval(abortCheckInterval);

        return result;
      }

      // for debugging:
      window.embedTexts = embedTexts;
      window.cosineDistance = cosineDistance;
      window.getChatCompletion = getChatCompletion;


      // async function getCompletion({prompt, modelName, temperature, stopSequences, topP, frequencyPenalty, presencePenalty}) {

      //   // NOTE: This function is currently unused.
      //   // TODO: before using this function, you need to fix/add this stuff like in getChatCompletion:
      //   // - openAiErrorTypeToReadableError
      //   // - trackTokenUsage
      //   // - modelNameToModelType
      //   // - modelNameToMaxTokenLimit
      //   // ********You basically need to go through getChatCompletion line-by-line and copy over the relevant stuff.********

      //   // let tokenLimit = modelNameToMaxTokenLimit[modelName];
      //   // tokenLimit -= tokenLimit*0.15; // buffer due to token count being an estimate
      //   // let numTokensInContext = await countTokensInMessages(messages);

      //   let modelObj = availableModels[modelName];
      //   let apiKey = modelObj.apiKey;
      //   if(apiKey === "<OPENAI>") {
      //     apiKey = (await db.misc.get("openAiApiKey"))?.value;
      //   }

      //   let modelType = availableModels[modelName].type;
      //   if(!modelType) throw new Error(`getCompletion: modelType not found for modelName: ${modelName}`);

      //   let result;

      //   if(modelType === "completion") {

      //     let data = {
      //       model:modelName,
      //       prompt,
      //       temperature: temperature ?? 0.7,
      //     };
      //     if(stopSequences) data.stop = stopSequences;
      //     if(topP) data.top_p = topP;
      //     if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
      //     if(presencePenalty) data.presence_penalty = presencePenalty;

      //     let json = await fetch(modelObj.endpointUrl, {
      //       method: "POST",
      //       headers: apiKey ? { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" } : undefined,
      //       body: JSON.stringify(data),
      //     }).then(r => r.json()).catch(e => alert("getCompletion: "+e.stack));
          
      //     if(json?.error) {
      //       console.error(json.error);
      //       alert(`Error during getCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
      //     }

      //     result = json?.choices[0].text.trim();

      //   } else {

      //     let leadInTextLength = 20;

      //     let data = {
      //       model:modelName,
      //       messages: [
      //         {
      //           role: "system",
      //           content: "You are a text completion assistant. You respond with the most likely completion of the prompt that the user provides."
      //         },
      //         {
      //           role: "user",
      //           content: `${prompt}\n\n---\n\nPlease continue the above text. Your reply must start with "${prompt.slice(-leadInTextLength)}", and should ONLY include the completion of the prompt - nothing else. Reply with a plausible completion and start your message with: "${prompt.slice(-leadInTextLength)}"`,
      //         },
      //       ],
      //       temperature: temperature ?? 0.7,
      //     };
      //     if(stopSequences) data.stop = stopSequences;
      //     if(topP) data.top_p = topP;
      //     if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
      //     if(presencePenalty) data.presence_penalty = presencePenalty;

      //     let json = await fetch(modelObj.endpointUrl, {
      //       method: 'POST',
      //       headers: apiKey ? { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' } : undefined,
      //       body: JSON.stringify(data),
      //     }).then(r => r.json()).catch(e => alert("getCompletion: "+e.stack));
          
      //     if(json?.error) {
      //       console.error(json.error);
      //       alert(`Error during getCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
      //     }

      //     result = json.choices[0].message.content;
      //     result = result.slice(leadInTextLength); // remove the "lead in" text
      //   }
      //   return result;
      // }

      let hljs = null;
      let initiatedHighlightJsLoad = false;
      async function highlightCodeBlocks(el) {
        if(el.querySelectorAll("pre").length === 0) return;
        if(!initiatedHighlightJsLoad) {
          initiatedHighlightJsLoad = true;
          // importStylesheet("https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/default.min.css");
          importStylesheet("https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css");
          hljs = await import("https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/es/highlight.min.js").then(m => m.default);
        }
        while(!hljs) {
          await new Promise(r => setTimeout(r, 100));
        }
        // i was originally checking el.isConnected as an optimisation, but it sometimes returns false (not exactly sure why) so I'm not checking it anymore
        el.querySelectorAll("pre[data-markdown-codeblock]").forEach(pre => {
          let language = pre.dataset.markdownCodeblock;
          if(language && hljs.getLanguage(language)) {
            hljs.highlightElement(pre, { language });
          } else {
            hljs.highlightElement(pre); // auto-detect language
          }
        });
      }

      function handleStreamingReplyChunk(chunk, messageEl) {
        let messageTextEl = messageEl.querySelector(".messageText");
        if(chunk.isFirst) messageEl.dataset.streamedMessageText = "";
        messageEl.dataset.streamedMessageText += chunk.text;
        let streamedMessageText = messageEl.dataset.streamedMessageText;

        let shouldScrollDown = messageFeedIsNearBottom();

        // if there's an unclosed codeblock, close it during streaming:
        if([...streamedMessageText.matchAll(/\n```/g)].length % 2 === 1) {
          streamedMessageText += "\n```";
        }

        messageTextEl.innerHTML = DOMPurify.sanitize(marked.parse(streamedMessageText), domPurifyOptions);
        // messageTextEl.querySelectorAll("pre > code").forEach(el => el.outerHTML = el.innerHTML); // not sure why `marked` is adding <pre><code>...</code></pre> around code blocks, but this fixes it
        
        highlightCodeBlocks(messageTextEl);

        if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
      }

      async function threadIsUsingOpenAiModel(threadOrThreadId) {
        let thread;
        if(typeof threadOrThreadId === "number") {
          thread = await db.threads.get(threadOrThreadId);
        } else {
          thread = threadOrThreadId;
        }
        let modelObj = availableModels[thread.modelName];
        return modelObj.endpointUrl.startsWith("https://api.openai.com");
      }


      async function autoNameThreadIfNeeded(threadId) {
        let thread = await db.threads.get(threadId);
        let userCharacter = await getUserCharacterObj(threadId);
        let aiCharacter = await db.characters.get(thread.characterId);
        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        messages = messages.slice(0, 10);

        if(thread.name === defaultThreadName && messages.length > 8) {

          let modelName;
          if(await threadIsUsingOpenAiModel(thread)) {
            modelName = "gpt-3.5-turbo"; // if they're using any OpenAI model, then we use turbo for summarization
          } else {
            modelName = thread.modelName;
          }

          let preparedMessages = await prepareMessagesForBot({messages});

          for(let m of preparedMessages) {
            m.content = m.content.length > 1000 ? m.content.slice(0, 1000)+"..... (message has been truncated)" : m.content;
          }

          while(await countTokensInMessages(preparedMessages, modelName) > 2000 && preparedMessages.length > 1) {
            preparedMessages.pop();
          }

          let chatCompletionMessages = [
            {role: "system", content: "You are an expert chat thread naming assistant. You help the user come up with a very short name that succinctly summarizes a text chat."},
            {role: "user", content: `Here are some logs from a text chat:\n\n---\n\n${preparedMessages.map(m => `[[${m.name}]]: ${m.content}`).join("\n\n")}\n\n---\n\nPlease come up with a very short name for this thread (just a few words) that succinctly summarizes the chat. You MUST reply with this exact template:\n\nSUMMARY: <a couple of sentences describing the chat thread>\nSHORT NAME: <proposed name of the thread - only a few words>`},
          ];
          let response = await getChatCompletion({messages:chatCompletionMessages, modelName, temperature:0.7, threadId});
          let newName = response.match(/\nSHORT NAME: (.*)/)?.[1]?.slice(0, 50);
          if(newName?.trim()) {
            await db.threads.update(threadId, { name: newName });
            await renderThreadList();
          }
        }
      }


      let lastBotReplyTime = 0;
      let botIsCurrentlyReplying = false;
      async function doBotReplyIfNeeded({forceReply=false, replyInstruction=null, signals=null, result={}, characterOverride=null, expectsReply=undefined}={}) {
        while(Date.now()-lastBotReplyTime < 1000) {
          await delay(200); // don't reply too fast in case of infinite bot reply loop (e.g. due to custom code stuff)
        }

        lastBotReplyTime = Date.now();

        // if thread is not currently visible, don't reply
        let messageThreadIsVisible = messageFeed.offsetHeight > 0;
        if(!messageThreadIsVisible) return;

        // if page is not visible, wait for it to become visible (don't want to accidentally burn credits in the background - e.g. if character's custom code is causing a reply loop)
        while(document.visibilityState !== "visible") {
          await delay(300);
        }

        // get all messages in the thread so far, so we can send them to bot
        const threadId = activeThreadId;
        const messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);

        let messagesVisibleToAi = messages.filter(m => {
          if(m.hiddenFrom && m.hiddenFrom.includes("ai")) return false;
          return true;
        });

        const characterId = characterOverride?.id ?? activeCharacterId;
        const character = await db.characters.get(characterId);
        
        if(!forceReply) {
          let lastMessage = messagesVisibleToAi.at(-1);
          if(botIsCurrentlyReplying) return;
          if(!lastMessage) return;
          if(lastMessage.expectsReply === false) {
            return; // there is a message, and bot isn't replying, but the message explicitely says not to reply
          } else if(lastMessage.expectsReply === true) {
            // do response
          } else {
            // expectsReply was neither false, nor true, so we use the default behavior:
            if(lastMessage.characterId === characterId) {
              return; // last message was from bot, so don't reply
            } else {
              // do response
            }
          }
        }
        botIsCurrentlyReplying = true;

        // this is to prevent custom code data updates during bot replies, because otherwise it deletes the "typing indicator" and streaming response message during the renderMessageFeed() that follows
        let botIsCurrentlyReplyingPromiseResolve;
        botIsCurrentlyReplyingPromise = new Promise(r => botIsCurrentlyReplyingPromiseResolve = r);
        try {
          let messageObj = createMessageObj({threadId, message:"...", characterId, instruction:replyInstruction || null});
          
          let messageEl = await addMessageToFeed(messageObj, {character, skipReaderRendering:true});
          messageEl.querySelector(".messageText").innerHTML = createPaddedTypingIndicatorHtml();
          messageEl.dataset.canDelete = "false"; // to tell delete handler that this message "doesn't exist" yet - we handle the deletion in this function instead

          if(!signals) signals = {stop:false, wasDeleted:false};

          messageEl.querySelector(".info .deleteButton").addEventListener("click", async e => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            signals.wasDeleted = true;
            botIsCurrentlyReplying = false;
            messageEl.remove();
            await updateInlineReminderMessage();
            $.sendButton.disabled = false;
          });

          $.statusNotifier.innerHTML = "<button style='font-size: 0.9rem; margin-top:1.5rem;'>🛑 stop response</button>";
          $.statusNotifier.querySelector("button").addEventListener("click", async (e) => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            // we don't set botIsCurrentlyReplying=false here because getBotReply will return "successfully", except with a partially-streamed message
            if(!character.streamingResponse || (character.streamingResponse && streamingChunkCount === 0)) {
              messageEl.remove();
              signals.wasDeleted = true;
              botIsCurrentlyReplying = false;
            }
            await updateInlineReminderMessage();
            $.statusNotifier.innerHTML = "";
            hideEl($.statusNotifier);
            $.sendButton.disabled = false;
          });
          showEl($.statusNotifier);

          let streamingChunkCount = 0;
          function onStreamingReplyChunk(c) {
            handleStreamingReplyChunk(c, messageEl);
            streamingChunkCount++;
          }

          const onProgressMessage = (e) => messageEl.querySelector(".statusMessage").innerHTML=e.message;
          const {message, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed} = await getBotReply({messages, replyingCharacter:character, threadId, replyInstruction, onProgressMessage, onStreamingReplyChunk, signals}).catch(e => {
            if(e.name !== "AbortError") {
              alert("There was an error during doBotReplyIfNeeded:\n\n"+e.stack);
            }
            messageEl.remove();
            return {};
          });
          messageEl.querySelector(".statusMessage").innerHTML = "";

          hideEl($.statusNotifier);
          $.statusNotifier.innerHTML = "";

          if(signals.wasDeleted || message === undefined) {
            // we don't need to set botIsCurrentlyReplying=false here because it's done in delete handler, and setting it here would disrupt other calls to this function since it's global
            return;
          }

          messageObj.memoryIdBatchesUsed = memoryIdBatchesUsed;
          messageObj.loreIdsUsed = loreIdsUsed;
          messageObj.summaryHashUsed = summaryHashUsed;
          messageObj.memoryQueriesUsed = memoryQueriesUsed;
          messageObj.messageIdsUsed = messageIdsUsed;

          messageObj.expectsReply = expectsReply;
          
          // if `message` is not a string, it means the bot failed to reply, so delete the message
          if(typeof message !== "string" && message) { // I've added `&& message` because I think with streaming enabled, it could be an empty string even though there was an error? no harm either way.
            messageEl.remove();
          } else {
            messageObj.message = message;
            result.message = message;

            messageObj.id = await addMessageToDb(messageObj);
            messageEl.dataset.id = messageObj.id;

            let shouldScrollDown = messageFeedIsNearBottom();
            await addMessageToFeed(messageObj, {character, inPlaceOf:messageEl})
            if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

            if(character.fitMessagesInContextMethod === "summarizeOld") {
              // we don't await this because we want to do it in the background
              computeAndSaveThreadSummaryIfNeeded({threadId, continuePastCurrentSummary:true});
            }
            
            messageEl.dataset.canDelete = "true";
            await triggerMessageActionCustomCodeEvent({threadId, eventData:{}, eventName:"MessageAdded"});
          }

        } catch(e) {
          if(e.name !== "AbortError") { // AbortError is thrown by AbortController.abort() when user clicks "stop response" - for some reason I can't catch it
            console.error(e);
            alert(e.stack);
            botIsCurrentlyReplying = false;
          }
        }
        
        autoNameThreadIfNeeded(threadId);

        botIsCurrentlyReplying = false;
        botIsCurrentlyReplyingPromiseResolve();
        botIsCurrentlyReplyingPromise = null;

        $.sendButton.disabled = false;
      }

      let alreadyRecomputingBotReply = false;
      async function regenerateMessage(messageEl, opts={}) {
        if(alreadyRecomputingBotReply) return;
        alreadyRecomputingBotReply = true;
        try {

          if(currentBotReplySignals) {
            currentBotReplySignals.stop = true;
            currentBotReplySignals.wasDeleted = true;
            await delay(100);
          }

          messageEl.querySelector(".messageText").innerHTML = createPaddedTypingIndicatorHtml();

          let messageId = parseInt(messageEl.dataset.id);
          const messageObj = await db.messages.get(messageId);
          const threadId = messageObj.threadId;
          let thread = await db.threads.get(threadId);
          
          let messages = await db.messages.where("threadId").equals(threadId).toArray();
          messages.sort((a,b) => a.order - b.order);

          const isLastMessage = messageId === messages.at(-1).id;

          // remove this message and all following messages from the array
          let contextMessages = messages.slice(0, messages.findIndex(m => m.id === messageObj.id));

          const threadCharacter = await db.characters.get(thread.characterId);
          let replyingCharacter; // <-- can of course be the same as the thread character
          if(messageObj.characterId === -1) {
            replyingCharacter = await getUserCharacterObj(threadId);
          } else {
            replyingCharacter = await db.characters.get(messageObj.characterId);
          }

          let signals = {stop:false, wasDeleted:false};

          messageEl.querySelector(".info .deleteButton").addEventListener("click", async e => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            signals.wasDeleted = true;
            messageEl.remove();
          });

          $.statusNotifier.innerHTML = "<button data-stop-reponse-button='1' style='font-size: 0.9rem; margin-top:1.5rem;'>🛑 stop response</button>";
          $.statusNotifier.querySelector("button").addEventListener("click", async (e) => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            $.statusNotifier.innerHTML = "";
            hideEl($.statusNotifier);
          });
          showEl($.statusNotifier);

          let streamingChunkCount = 0;
          function onStreamingReplyChunk(c) {
            handleStreamingReplyChunk(c, messageEl);
            streamingChunkCount++;
          }

          const onProgressMessage = (e) => messageEl.querySelector(".statusMessage").innerHTML=e.message;

          let botReplyOpts = {messages:contextMessages, threadId, signals, onProgressMessage, onStreamingReplyChunk};
          if(opts.modelNameOverride) botReplyOpts.modelNameOverride = opts.modelNameOverride;
          if(messageObj.instruction) botReplyOpts.replyInstruction = messageObj.instruction;
          if(messageObj.characterId !== threadCharacter.id) {
            botReplyOpts.replyingCharacter = replyingCharacter;
          }
          
          const {message, memoryIdBatchesUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed} = await getBotReply(botReplyOpts);
          messageEl.querySelector(".statusMessage").innerHTML = "";

          hideEl($.statusNotifier);
          $.statusNotifier.innerHTML = "";

          if(signals.wasDeleted || message === undefined) {
            return;
          }

          if(message === undefined) {
            await addMessageToFeed(messageObj, {inPlaceOf:messageEl});
            return;
          }

          messageObj.memoryIdBatchesUsed = memoryIdBatchesUsed;
          messageObj.summaryHashUsed = summaryHashUsed;
          messageObj.memoryQueriesUsed = memoryQueriesUsed;
          messageObj.messageIdsUsed = messageIdsUsed;

          if(message) {
            messageObj.variants[messageObj.variants.findIndex(v => v===null)] = messageObj.message;
            messageObj.variants.push(null);
            messageObj.message = message;

            let shouldScrollDown = messageFeedIsNearBottom();
            let newMessageEl = await addMessageToFeed(messageObj, {inPlaceOf:messageEl});
            if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

            let currentVariantNumber = messageObj.variants.findIndex(v => v===null) + 1;
            newMessageEl.querySelector(".currentVariantNumber").innerHTML = `${currentVariantNumber}<span style="opacity:0.5">/${messageObj.variants.length}</span>`;
            
            if(isMobile) showEl(newMessageEl.querySelector(".messageVariantsCtn"));

            // update db with bot's reply
            await db.messages.put(messageObj);
            // update thread's lastMessageTime
            await db.threads.update(threadId, { lastMessageTime: Date.now() });

            // if this isn't at the top of the thread list, re-render the thread list
            let threadElements = [...$.chatThreads.querySelectorAll(".thread")];
            if(!thread.isFav) threadElements = threadElements.filter(el => el.querySelector(".favStar").dataset.isFav==="false");
            if(threadElements[0].dataset.threadId !== threadId.toString()) {
              await renderThreadList();
            }

            if(!signals.stop) { // <-- don't call custom code if they stopped the message
              await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId:messageObj.id}, eventName:"MessageEdited"});
            }
          }
        } catch(e) {
          console.error(e);
          alert("regenerateMessage failed:\n"+e.stack);
        }

        alreadyRecomputingBotReply = false;
      }

      function createPaddedTypingIndicatorHtml() {
        return `<div style="margin-top:0.25rem; margin-left:0.25rem;">${createTypingIndicatorHtml()}</div>`;
      }
      function createTypingIndicatorHtml() {
        return `<div class="ticontainer"><div class="tiblock"><div class="tidot"></div><div class="tidot"></div><div class="tidot"></div></div></div>`;
      }

      function messageFeedIsNearBottom() {
        return $.messageFeed.scrollHeight - $.messageFeed.scrollTop - $.messageFeed.offsetHeight < 50;
      }

      async function addMessageToFeed(originalMessageObj, opts={}) {
        let threadId = originalMessageObj.threadId;
        let thread = await db.threads.get(threadId);

        let messageObj;
        if(opts.skipReaderRendering) {
          messageObj = originalMessageObj;
        } else {
          [ messageObj ] = await renderMessagesForReader({messages:[originalMessageObj], reader:"user", threadId});
        }
        
        let userCharacter = await getUserCharacterObj(threadId);
        let character = opts.character;
        if(!character) {
          if(messageObj.characterId === -1) character = userCharacter;
          else if(messageObj.characterId === -2) character = await getSystemCharacterObj(threadId);
          else character = await db.characters.get(messageObj.characterId);
        }
        let el = await createMessageElement(messageObj, {character});
        
        if(opts.inPlaceOf) {
          opts.inPlaceOf.replaceWith(el);
        } else if(opts.insertAfter) {
          opts.insertAfter.after(el);
        } else if(opts.insertBefore) {
          opts.insertBefore.before(el);
        } else {
          // otherwise we append:
          let shouldScrollDown = messageFeedIsNearBottom();
          $.messageFeed.appendChild(el);
          if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
        }

        hideEl($.noMessagesNotice);
        attachEventHandlersToMessageEl(el, {showVariantsSelector:opts.showVariantsSelector});
        
        await updateInlineReminderMessage();
        await updateThreadScene();

        for(let undoButton of $.messageFeed.querySelectorAll(".undoMessageDeleteButton")) {
          undoButton.remove();
        }

        return el;
      }

      let mousePos = {x:0, y:0};
      window.addEventListener("mousemove", function(e) {
        mousePos = {x:e.clientX, y:e.clientY};
      });

      async function switchMessageVariant(messageEl, nextOrPrevious) {
        if(nextOrPrevious === "previous") {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          let currentIndex = message.variants.findIndex(v => v===null); // current message is represented with `null` in variant array
          message.variants[currentIndex] = message.message;
          if(currentIndex-1 < 0) currentIndex = message.variants.length;
          message.message = message.variants[currentIndex-1];
          message.variants[currentIndex-1] = null;
          await db.messages.put(message);
          let newMessageEl = await addMessageToFeed(message, {inPlaceOf:messageEl, showVariantsSelector:true});
          newMessageEl.querySelector(".currentVariantNumber").innerHTML = `${(currentIndex-1) + 1}<span style="opacity:0.5">/${message.variants.length}</span>`; // +1 because 1-indexed
        } else if(nextOrPrevious === "next") {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          let currentIndex = message.variants.findIndex(v => v===null); // current message is represented with `null` in variant array
          message.variants[currentIndex] = message.message;
          if(currentIndex+1 >= message.variants.length) currentIndex = -1;
          message.message = message.variants[currentIndex+1];
          message.variants[currentIndex+1] = null;
          await db.messages.put(message);
          let newMessageEl = await addMessageToFeed(message, {inPlaceOf:messageEl, showVariantsSelector:true});
          newMessageEl.querySelector(".currentVariantNumber").innerHTML = `${(currentIndex+1) + 1}<span style="opacity:0.5">/${message.variants.length}</span>`; // +1 because 1-indexed
        } else {
          throw new Error("Invalid nextOrPrevious value: "+nextOrPrevious);
        }
      }

      function attachEventHandlersToMessageEl(messageEl, opts={}) {
        const recomputeButton = messageEl.querySelector(".recomputeButton");

        messageEl.querySelector(".editButton").addEventListener("click", messageEditButtonClickHandler);
        recomputeButton.addEventListener("click", async function() {
          await regenerateMessage(messageEl);
        });

        messageEl.querySelector(".recomputeWithAltModelButton").addEventListener("click", async function() {
          let modelNameOverride = Date.now() < new Date("2024-01-04").getTime() ? "text-davinci-003" : "gpt-3.5-turbo-instruct";
          await regenerateMessage(messageEl, {modelNameOverride});
        });


        messageEl.querySelector(".prevMessageVariantButton").addEventListener("click", async function() {
          await switchMessageVariant(messageEl, "previous");
        });
        messageEl.querySelector(".nextMessageVariantButton").addEventListener("click", async function() {
          await switchMessageVariant(messageEl, "next");
        });

        if(!isMobile) { // on mobile the variants container is always visible after user has created at least 1 variant
          let variantsCtnHideTimeout = null;
          recomputeButton.addEventListener("mouseenter", function(e) {
            clearTimeout(variantsCtnHideTimeout);
            let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
            showEl(variantsCtn);
            // hotizontally position variantsCtn so it sits directly above recomputeButton (centered)
            variantsCtn.style.left =  `${recomputeButton.offsetLeft + (recomputeButton.offsetWidth/2) - (variantsCtn.offsetWidth/2)}px`;
          });

          recomputeButton.addEventListener("mouseleave", async function() {
            let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
            variantsCtnHideTimeout = setTimeout(() => hideEl(variantsCtn), 500);
          });

          messageEl.querySelector(".messageVariantsCtn").addEventListener("mouseenter", function() {
            clearTimeout(variantsCtnHideTimeout);
          });
          messageEl.querySelector(".messageVariantsCtn").addEventListener("mouseleave", function() {
            let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
            variantsCtnHideTimeout = setTimeout(() => hideEl(variantsCtn), 500);
          });
          if(opts.showVariantsSelector) {
            recomputeButton.dispatchEvent(new Event("mouseenter"));
            delay(100).then(() => {
              // if mouse is not on top of variantsCtn, dispatch mouseleave:
              let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
              let variantsCtnRect = variantsCtn.getBoundingClientRect();
              if(!(mousePos.x >= variantsCtnRect.left && mousePos.x <= variantsCtnRect.right && mousePos.y >= variantsCtnRect.top && mousePos.y <= variantsCtnRect.bottom)) {
                // debugger;
                recomputeButton.dispatchEvent(new Event("mouseleave"));
              }
            });
          }
        }

        messageEl.querySelector(".deleteButton").addEventListener("click", messageDeleteButtonClickHandler);
        messageEl.querySelector(".showHiddenMessageButton").addEventListener("click", showHiddenMessageClickHandler);
        // messageEl.querySelector(".messageText").querySelectorAll("pre > code").forEach(el => el.outerHTML = el.innerHTML); // not sure why `marked` is adding <pre><code>...</code></pre> around code blocks, but this fixes it
        messageEl.querySelector(".statusMessage").addEventListener("click", () => summariesWindow.show());

        messageEl.querySelector(".brainButton")?.addEventListener("click", async function() {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          
          let summary;
          let summaryUsed;
          if(message.summaryHashUsed) {
            summary = await db.summaries.get(message.summaryHashUsed);
            summaryUsed = summary.summary;
          }

          let memoriesUsed = await db.memories.where("id").anyOf(message.memoryIdBatchesUsed.flat()).toArray();
          let memoryBatchesUsed = message.memoryIdBatchesUsed;
          // replace ids in memoryBatchesUsed with memories from memoriesUsed:
          for(let batch of memoryBatchesUsed) {
            for(let i = 0; i < batch.length; i++) {
              batch[i] = memoriesUsed.find(m => m.id === batch[i]) ?? {text:"(memory not found - likely because it has since been edited or deleted)"};
            }
          }
          let loreEntriesUsed = await db.lore.where("id").anyOf(message.loreIdsUsed).toArray();

          let content = [];

          if(message.instruction) {
            content.push(`<b>Instruction Used:</b> ${message.instruction}`);
          }

          if(message.summaryHashUsed === undefined) {
            content.push(`<b>Summary Used:</b><div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(This message was created before message-summary-usage tracking was implemented)</div>`);
          } else if(message.summaryHashUsed === null) {
            content.push(`<b>Summary Used:</b><div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(No summary was used to generate this message. This is likely because the conversation was not yet long enough to warrant summarization)</div>`);
          } else {

            let summarySummarized = summary.prevSummaryHash ? await db.summaries.get(summary.prevSummaryHash) : null;
            let messagesSummarized = await db.messages.where("id").anyOf(summary.messageIds).toArray();
            messagesSummarized.sort((a,b) => a.order - b.order);

            messagesSummarized = await prepareMessagesForBot({messages:messagesSummarized});

            let messagesSummarizedHtml = `<details style="opacity:0.5; padding:1rem;"><summary style="cursor:pointer;">Click here to show what was summarized</summary>${summarySummarized ? "\n"+summarySummarized.summary : ""}\n\n${messagesSummarized.map(m => `<b>[${m.name}]:</b> ${sanitizeHtml(m.content)}`).join("\n\n")}</details>`;

            content.push(`<b>Summary Used:</b>\n${sanitizeHtml(summaryUsed)}<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(you can edit the latest summary by typing <b>/sum</b> in the chat)</div>${messagesSummarizedHtml}`);
          }

          if(memoryBatchesUsed.length > 0) {
            content.push(`<b>Memories Used:</b>\n${sanitizeHtml(memoryBatchesUsed.map(batch => batch.map(m => m.text).join(" ⮕ ")).join("\n\n"))}<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(you can add and edit memories by typing <b>/mem</b> in the chat)</div>`);
          } else {
            content.push(`<b>Memories Used:</b>\n<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(No memories were used to generate this message. This is either because the conversation was not yet long enough to warrant memory storage/retrieval, or you don't have memories enabled in the character settings, or lore entries took precedence)</div>`);
          }
          
          if(loreEntriesUsed.length > 0) {
            content.push(`<b>Lore Entries Used:</b>\n${sanitizeHtml(loreEntriesUsed.map(m => m.text).join("\n\n"))}<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(you can add and edit lore by typing <b>/lore</b> in the chat)</div>`);
          } else {
            content.push(`<b>Lore Entries Used:</b>\n<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(No lore entries were used to generate this message. This is either because the conversation was not yet long enough to warrant memory storage/retrieval, or you don't have memories enabled in the character settings, or memory entries took precedence. You can add and edit lore by typing <b>/lore</b> in the chat.)</div>`);
          }

          if(message.memoryQueriesUsed.length > 0) {
            content.push(`<b>Memory/Lore Queries Used:</b>\n${sanitizeHtml(message.memoryQueriesUsed.join("\n"))}`);
          }

          if(message.messageIdsUsed.length > 0) {
            let messages = await db.messages.where("id").anyOf(message.messageIdsUsed.filter(id => id !== -1)).toArray();
            messages.sort((a,b) => a.order - b.order);

            messages = await prepareMessagesForBot({messages});
            
            // we want `null` "holes" in the array for the messages that no longer exist:
            let messagesMap = {};
            messages.forEach((message) => { messagesMap[message.id] = message; });
            let messagesWithHoles = message.messageIdsUsed.map(id => id === -1 ? null : messagesMap[id]);

            content.push(`<b>Messages Used:</b>\n<details style="opacity:0.5; padding:1rem;"><summary style="cursor:pointer;">Click here to show messages</summary>\n${messagesWithHoles.map(m => m ? `<b>[${m.name}]:</b> ${sanitizeHtml(m.content)}` : "<b>[???]</b>: <span style='opacity:0.5;'>(Message no longer exists. May have been deleted by user, or by custom code.)</span>").join("\n\n")}</details>`);
          }
          
          prompt2({
            display:{html:`<div style="white-space:pre-wrap;">Here's some data that the character used to generate this message:\n\n${content.join("\n\n")}</div>`, type:"none"},
          }, { submitButtonText: "close", cancelButtonText: null });
        });
      }

      // right/left arrow to switch message variants:
      window.addEventListener("keydown", async function(e) {
        // if active element is a textarea/input, then return
        if(document.activeElement.tagName === "TEXTAREA" || document.activeElement.tagName === "INPUT") {
          return;
        }
        if($.messageFeed.offsetWidth === 0 || activeThreadId === null) {
          return;
        }

        // if they press right arrow, and the last message is on the final variant, then recompute the final message:
        if(e.key === "ArrowRight" || e.key === "ArrowLeft") {
          let threadId = parseInt($.messageFeed.dataset.threadId);
          let thread = await db.threads.get(threadId);
          let messages = await db.messages.where("threadId").equals(threadId).toArray();
          messages.sort((a,b) => a.order - b.order);
          let lastMessage = messages[messages.length-1];
          let lastMessageEl = [...$.messageFeed.querySelectorAll(".message")].pop();
          if(e.key === "ArrowRight") {
            // the `lastMessage.variants` array has `null` in the position of the 'current' message, so if null is at the end of the array, and they pressed right arrow, then we recompute:
            if(lastMessage.variants[lastMessage.variants.length-1] === null) {
              await regenerateMessage(lastMessageEl);
            } else {
              // otherwise we just move to the next variant:
              await switchMessageVariant(lastMessageEl, "next");
            }
          }
          if(e.key === "ArrowLeft") {
            // if the first variant is null, then we recompute:
            if(lastMessage.variants[0] === null) {
              await regenerateMessage(lastMessageEl);
            } else {
              // otherwise we just move to the previous variant:
              await switchMessageVariant(lastMessageEl, "previous");
            }
          }
        }
      });

      async function showHiddenMessageClickHandler() {
        let messageEl = this.closest(".message");
        let messageObj = db.messages.get(parseInt(messageEl.dataset.id));
        messageEl.classList.remove("hiddenFromUser");
      }

      let dataUrlToBlobUrlCache = new Map();
      async function dataUrlToCachedBlobUrl(dataUrl) {
        if(dataUrlToBlobUrlCache.has(dataUrl)) return dataUrlToBlobUrlCache.get(dataUrl);
        let blob = await fetch(dataUrl).then(r => r.blob()); 
        let blobUrl = URL.createObjectURL(blob);
        dataUrlToBlobUrlCache.set(dataUrl, blobUrl);
        return blobUrl;
      }

      async function createMessageElement(messageObj, opts={}) {

        let messageObjHash = await sha256Text(JSON.stringify(messageObj));

        if(messageObj.character) debugger;

        let thread = await db.threads.get(messageObj.threadId);

        let character = opts.character;

        if(!character && messageObj.characterId === -1) character = await getUserCharacterObj(messageObj.threadId)
        if(!character && messageObj.characterId === -2) character = await getSystemCharacterObj(messageObj.threadId);
        if(!character && messageObj.characterId >= 0) character = await db.characters.get(messageObj.characterId);

        let tmp = document.createElement("div");
        let currentVariantNumber = messageObj.variants.findIndex(v => v === null) + 1;

        let variantCtnCss;
        if(isMobile) {
          // on mobile we show when there are multiple variants
          if(messageObj.variants.length >= 2) {
            variantCtnCss = "margin-left:1rem;";
          } else {
            variantCtnCss = "margin-left:1rem; display:none;";
          }
        } else {
          // on desktop we show in hover:
          variantCtnCss = "display:none; position:absolute; bottom:1.4rem; padding: 0.125rem;";
        }

        let avatarUrl = character.avatar.url;
        if(thread.character.avatar.url) avatarUrl = thread.character.avatar.url;
        if(messageObj.avatar?.url) avatarUrl = messageObj.avatar.url;
        if(avatarUrl && avatarUrl.startsWith("data:")) {
          avatarUrl = await dataUrlToCachedBlobUrl(avatarUrl);
        }

        let avatarShape = character.avatar.shape;
        if(thread.character.avatar.shape) avatarShape = thread.character.avatar.shape;
        if(messageObj.avatar?.shape) avatarShape = messageObj.avatar.shape;

        let avatarSize = character.avatar.size;
        if(thread.character.avatar.size) avatarSize = thread.character.avatar.size;
        if(messageObj.avatar?.size !== undefined) avatarSize = messageObj.avatar.size;

        let wrapperStyle = messageObj.wrapperStyle || thread.messageWrapperStyle || "";

        // fall back to ai character's settings where appropriate:
        if(character.id < 0) {
          let thread = await db.threads.get(messageObj.threadId);
          let aiCharacter = await db.characters.get(thread.characterId);

          if(avatarSize === null || avatarSize === undefined) {
            avatarSize = aiCharacter.avatar.size;
          }
          if(avatarShape === null || avatarShape === undefined) {
            avatarShape = aiCharacter.avatar.shape;
          }
        }

        let avatarWidth = 50 * (avatarSize ?? 1);
        let avatarHeight = 50 * (avatarSize ?? 1);
        let avatarBorderRadius = "var(--border-radius)";
        if(avatarShape === "circle") {
          avatarBorderRadius = "50%";
        }
        if(avatarShape === "portrait") {
          avatarHeight *= 1.5;
        }

        let characterName = messageObjToCharacterName(messageObj, {thread, character});

        let showRecomputeWithAltButtonModel = false;
        if(thread.modelName === "gpt-3.5-turbo" || thread.modelName === "gpt-4") {
          if(textContainsAsALanguageModelText(messageObj.message + messageObj.variants.join(" "))) {
            showRecomputeWithAltButtonModel = true;
          }
        }

        tmp.innerHTML = `
          <div class="message ${messageObj.hiddenFrom?.includes("user") ? "hiddenFromUser" : ""}" data-id="${sanitizeHtml(messageObj.id)}" data-order="${sanitizeHtml(messageObj.order)}" data-character-id="${sanitizeHtml(messageObj.characterId)}" data-can-delete="true" data-hash="${messageObjHash}" style="${sanitizeHtml(wrapperStyle)}; position:relative;">
            <div style="text-align:center;"><button class="showHiddenMessageButton" style="cursor:pointer; font-size:0.65rem;">Show hidden message</button></div>
            <div class="bottomButtons">
              <div class="brainButton emojiButton">🧠</div>
            </div>
            <div class="messageWrap">
              <div class="avatar" style="${avatarUrl ? `background-image:url(${sanitizeHtml(avatarUrl)})` : ""};width:${sanitizeHtml(avatarWidth)}px; min-width:${sanitizeHtml(avatarWidth)}px; height:${sanitizeHtml(avatarHeight)}px; border-radius:${sanitizeHtml(avatarBorderRadius)};"></div>
              <div style="padding-left:0.5rem; min-width: 0; width:100%;">
                <div class="info" style="flex-grow:1; display:flex; font-size:80%; align-items:center; user-select:none;">
                  <div class="characterName" style="font-weight:bold;">${sanitizeHtml(characterName)}</div>
                  <!-- <div class="time" style="font-size:0.8rem; opacity:0.5; margin-left:0.5rem; display: flex; align-items: center;">${getDateTimeString(messageObj.creationTime)}</div> -->
                  <div class="editButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display: flex; align-items: center; cursor:pointer;">✏️</div>
                  <div class="deleteButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display: flex; align-items: center; cursor:pointer;">🗑️</div>
                  <div style="position:relative;display:flex; align-items:center;">
                    <div class="recomputeButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display:flex; align-items: center; cursor:pointer;">🔁</div>
                    <div class="recomputeWithAltModelButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display:${showRecomputeWithAltButtonModel ? "flex" : "none"}; align-items: center; cursor:pointer;" title="Regenerate this message with the davinci model (10x more expensive, but less filtered)">🙄</div>
                    <div class="messageVariantsCtn" style="user-select:none; background: var(--button-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius); min-width:max-content; ${sanitizeHtml(variantCtnCss)}">
                      <span class="prevMessageVariantButton emojiButton">◄</span>
                      <span class="currentVariantNumber">${sanitizeHtml(currentVariantNumber)}<span style="opacity:0.5">/${sanitizeHtml(messageObj.variants.length)}</span></span>
                      <span class="nextMessageVariantButton emojiButton">►</span>
                    </div>
                  </div>
                  ${messageObj.hiddenFrom?.includes("ai") ? `<div class="hiddenFromAiIcon" onclick="alert('This icon indicates that this message is hidden from the AI.')" title="The AI cannot see this message." style="font-size:0.8rem; margin-left:1rem; display:flex; align-items: center; cursor:pointer;">🙈</div>` : ""}
                  <div class="statusMessage" style="margin-left:1rem;display: flex;align-items: center;cursor:pointer;font-size: 0.7rem;opacity: 0.5;"></div>
                </div>
                <div class="messageText" style="overflow-wrap:break-word;"></div>
              </div>
            </div>
          </div>
        `;
        let el = tmp.firstElementChild;
        el.querySelector(".messageText").innerHTML = DOMPurify.sanitize(marked.parse(messageObj.message), domPurifyOptions);
        // el.querySelector(".messageText").querySelectorAll("pre > code").forEach(el => el.outerHTML = el.innerHTML); // not sure why `marked` is adding <pre><code>...</code></pre> around code blocks, but this fixes it
        
        highlightCodeBlocks(el.querySelector(".messageText"));

        // add 'copy' button to code blocks
        el.querySelectorAll('.messageText pre').forEach(pre => {
          const wrapper = document.createElement('div');
          const button = document.createElement('button');
          button.innerText = 'copy';
          button.style.cssText = 'font-size:80%; position:absolute; top:0.25rem; right:0.25rem;';
          wrapper.style.position = 'relative';
          pre.parentNode.insertBefore(wrapper, pre);
          wrapper.appendChild(pre);
          wrapper.appendChild(button);

          button.addEventListener('click', async () => {
            let text = pre.innerText.trim(); // trim removes trailing newlines from bash commands which is a very good idea
            await navigator.clipboard.writeText(text);
            button.innerText = 'copied!';
            setTimeout(() => {
              button.innerText = 'copy';
            }, 2000);
          });
        });
        return el;
      }


      function textContainsAsALanguageModelText(text) {
        let t = text.toLowerCase();
        return t.includes("as a language model")
          || t.includes("trained by openai")
          || t.includes("as a large language model")
          || t.includes("language model trained")
          || /\bas an ai\b/.test(t)
          || /\bi'm sorry.+(appropriate|acceptable)\b/.test(t)
          || /\bi apologi[zs]e.+(appropriate|acceptable)\b/.test(t)
          || /\b(i (can't|cannot) (assist|help)( you|) with that)\b/.test(t)
          || /\b(i'm |)sorry, i (can't|cannot)\b/.test(t.slice(0, 50))
          || /\bunfortunately,? i (can't|cannot)\b/.test(t.slice(0, 50))
          || /\bsorry.+(cannot|can't|won't be able to).+(generate|write|create|do that)\b/.test(t.slice(0, 50))
      }

      async function messageEditButtonClickHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        let messageEl = this.closest(".message");
        const messageId = parseInt(messageEl.dataset.id);
        const originalMessage = await db.messages.get(messageId);
        let threadId = originalMessage.threadId;
        const thread = await db.threads.get(threadId);

        let insertNewMessageEl = document.createElement("div");
        insertNewMessageEl.style.cssText = "margin-top: 1rem;";
        insertNewMessageEl.innerHTML = `<span style="font-size:85%;">insert new message:</span> <button class="insertAbove">above</button> <button class="insertBelow">below</button>`;
        async function insertMessageHandler(aboveOrBelow) {
          const result = await prompt2({
            content: {label: "message:", type: "text", height:"fit-content", focus:true},
            author: {label: "author:", type: "select", options:[{value:"user"}, {value:"ai"}, {value:"system"}], defaultValue: "user"},
            hiddenFrom: {hidden:true, label: "hidden from:", type: "select", options:[{value:"user"}, {value:"ai"}, {content:"both", value:"user,ai"}, {content:"neither", value:""}], defaultValue: originalMessage.hiddenFrom.join(",")},
          });
          if(!result) return;
          let characterId = result.author === "user" ? -1 : result.author === "system" ? -2 : thread.characterId;
          let messageObj = createMessageObj({threadId, message:result.content, characterId, hiddenFrom:result.hiddenFrom.split(",")});
          
          let messages = await db.messages.where({threadId}).toArray();
          messages.sort((a,b) => a.order - b.order);
          let messageIndex = messages.findIndex(m => m.id === messageId);
          let prevOrder, nextOrder;
          if(aboveOrBelow === "above") {
            prevOrder = messageIndex > 0 ? messages[messageIndex-1].order : messages[messageIndex].order-1;
            nextOrder = originalMessage.order;
          } else {
            prevOrder = originalMessage.order;
            nextOrder = messageIndex < messages.length-1 ? messages[messageIndex+1].order : messages[messageIndex].order+1;
          }
          messageObj.order = (prevOrder + nextOrder) / 2;
          messageObj.id = await addMessageToDb(messageObj);
          
          let opts = {};
          if(aboveOrBelow === "above") opts.insertBefore = messageEl;
          else opts.insertAfter = messageEl;

          await addMessageToFeed(messageObj, opts);

          await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId:messageObj.id}, eventName:"MessageInserted"});
        }
        insertNewMessageEl.querySelector(".insertAbove").addEventListener("click", insertMessageHandler.bind(null, "above"));
        insertNewMessageEl.querySelector(".insertBelow").addEventListener("click", insertMessageHandler.bind(null, "below"));
        
        let promptOpts = {
          // CAUTION: All non-none types must have a defaultValue, since we use it for change detection, below
          message: {label: "message:", type: "text", height:"fit-content", defaultValue: originalMessage.message, focus:true},
          instruction: {hidden:!!!originalMessage.instruction, label: "instruction:", type: "text", minHeight:"2rem", defaultValue: originalMessage.instruction || ""},
          hiddenFrom: {hidden:true, label: "hidden from:", type: "select", options:[{value:"user"}, {value:"ai"}, {content:"both", value:"user,ai"}, {content:"neither", value:""}], defaultValue: originalMessage.hiddenFrom.join(",")},
          insertMessage: {hidden:true, html: insertNewMessageEl, type: "none"},
        };
        const result = await prompt2(promptOpts, {submitButtonText:"save"});
        if(!result) return;

        let noChangesMade = true;
        for(let key of Object.keys(result)) {
          if(promptOpts[key].type === "none") continue;

          if(result[key] !== promptOpts[key].defaultValue) {
            noChangesMade = false;
            break;
          }
        }
        if(noChangesMade) return;

        result.hiddenFrom = result.hiddenFrom.split(",").filter(x => x);
        if(!result.instruction || !result.instruction.trim()) result.instruction = null;

        await db.messages.update(messageId, result);

        let newMessage = await db.messages.get(messageId);

        let shouldScrollDown = messageFeedIsNearBottom();
        await addMessageToFeed(newMessage, {inPlaceOf:messageEl});
        if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

        await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId}, eventName:"MessageEdited"});
      }


      async function messageDeleteButtonClickHandler(e) {
        let messageEl = this.closest(".message");
        if(messageEl.dataset.canDelete === "false") return; // it doesn't exist (just a "typing indicator" place holder) - deletion during that time is handled within the doBotReplyIfNeeded function
        let threadId = activeThreadId;
        e.preventDefault();
        e.stopPropagation();
        const messageId = parseInt(messageEl.dataset.id);

        let prevMessageEl = messageEl.previousElementSibling;
        while(prevMessageEl && !prevMessageEl.classList.contains("message")) prevMessageEl = prevMessageEl.previousElementSibling;
        
        let messageObj = await db.messages.get(messageId);

        // remove any exsiting undo buttons
        for(let undoButton of $.messageFeed.querySelectorAll(".undoMessageDeleteButton")) {
          undoButton.remove();
        }

        let undoBtn = document.createElement("div");
        undoBtn.innerHTML = `<div class="undoMessageDeleteButton" style="text-align:center;"><button>undo deletion</button></div>`;
        undoBtn.querySelector("button").addEventListener("click", async function() {
          // add message back to db.
          // NOTE: the message will no longer be referenced in messageIdsUsed of other messages (due to safelyDeleteMessagesByIds tidying up those references), but that's not a big deal. Can improve this later if needed.
          await db.messages.add(messageObj);

          let opts = {};
          if(prevMessageEl) opts.insertAfter = prevMessageEl;
          await addMessageToFeed(messageObj, opts);
          
          undoBtn.remove();

          await updateInlineReminderMessage();
          await updateThreadScene();
        });

        await safelyDeleteMessagesByIds([messageId]);
        messageEl.replaceWith(undoBtn);
        if(!$.messageFeed.querySelector(".message")) {
          showEl($.noMessagesNotice);
        }
        await updateInlineReminderMessage();
        await updateThreadScene();
        await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId}, eventName:"MessageDeleted", triggerBotReply:false});
      }

      const defaultUserName = "Anon";

      async function getUserCharacterObj(threadId) {
        // set defaults:
        let characterObj = {
          id: -1,
          name: (await db.misc.get("userName"))?.value || defaultUserName,
          // avatarUrl: (await db.misc.get("userAvatarUrl"))?.value || "",
          roleInstruction: "",
          reminderMessage: "",
          initialMessage: [],
          customCode: "",
          fitMessagesInContextMethod: "dropOld",
          avatar: {
            url: (await db.misc.get("userAvatarUrl"))?.value || "",
            // we leave `shape` and `size` as thread default
          },
          streamingResponse: true,
          maxTokensPerMessage: null,
        };
        // override with character and then thread-specific settings:
        let thread = await db.threads.get(threadId);
        applyObjectOverrides({object:characterObj, overrides:thread.userCharacter});

        return characterObj;
      }



      async function getSystemCharacterObj(threadId) {
        let characterObj = {
          id: -2,
          name: defaultSystemName,
          avatar: {
            url: null,
            shape: null, // null => default to character setting
            size: null,
          },
          maxTokensPerMessage: null,
        };
        // override with character and then thread-specific settings:
        let thread = await db.threads.get(threadId);
        applyObjectOverrides({object:characterObj, overrides:thread.systemCharacter});

        return characterObj;
      }

      {
        let debounceTimeout = null;
        $.messageInput.addEventListener("input", async function(e) {
          // debounce, and after 500ms, save current $.messageInput.value to thread.unsentMessageText
          if(debounceTimeout) clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(async function() {
            let threadId = activeThreadId;
            await db.threads.update(threadId, {unsentMessageText: $.messageInput.value});
          }, 500);
        });
      }


      async function sendButtonClickHandler() {
        $.sendButton.disabled = true;

        try {
          let threadId = activeThreadId;
          let thread = await db.threads.get(threadId);
          let characterId = thread.characterId;
          let threadCharacter = await db.characters.get(characterId);
          let message = $.messageInput.value;

          // This use used to detect if the browser is not allowing persistent storage, even if the user has been using the app for quite a while.
          // Can't just use e.g. message count because user could have just imported a bunch of messages.
          let datesApplicationWasUsedInThisBrowser = (await db.misc.get("datesApplicationWasUsedInThisBrowser"))?.value ?? [];
          datesApplicationWasUsedInThisBrowser.push(new Date().toISOString().slice(0,10));
          datesApplicationWasUsedInThisBrowser = [...new Set(datesApplicationWasUsedInThisBrowser)];
          await db.misc.put({key: "datesApplicationWasUsedInThisBrowser", value: datesApplicationWasUsedInThisBrowser});

          // if user sent message history contains message, move it to the end, otherwise add it to the end:
          let userMessageHistoryEntry = thread.userMessagesSentHistory.find(x => x.text === message);
          if(userMessageHistoryEntry) {
            thread.userMessagesSentHistory.splice(thread.userMessagesSentHistory.indexOf(userMessageHistoryEntry), 1);
          } else {
            userMessageHistoryEntry = {text:message, isPinned:false};
          }
          thread.userMessagesSentHistory.push(userMessageHistoryEntry);
          // ensure isPinned items are at the end of the array:
          thread.userMessagesSentHistory.sort((a,b) => a.isPinned === b.isPinned ? 0 : a.isPinned ? 1 : -1);
          // keep only the last 50 messages:
          thread.userMessagesSentHistory = thread.userMessagesSentHistory.slice(-30); 
          await db.threads.update(threadId, {userMessagesSentHistory:thread.userMessagesSentHistory});

          try {

            if(message.trim() === "/ai" || message.startsWith("/ai ")) {
              // $.messageInput.value = "";

              if(message.trim() === "/ai") {
                await doBotReplyIfNeeded({forceReply:true, expectsReply:false});
              } else {
                let replyInstruction = message.replace(/^\/ai /, "").trimStart();
                // extract char name and ID from start of message if it's present
                let charNameAndId = replyInstruction.match(/^@([^#]+)#([0-9]+)/);
                let characterOverride = null;
                if(charNameAndId) {
                  // let charName = charNameAndId[1];
                  let characterId = parseInt(charNameAndId[2]);
                  characterOverride = await db.characters.get(characterId);
                  if(!characterOverride) {
                    alert(`CharacterID not found: #${characterId}`);
                  }
                  replyInstruction = replyInstruction.replace(/^@([^#]+)#([0-9]+)/, "").trim() || null;
                }
                await doBotReplyIfNeeded({forceReply:true, replyInstruction, characterOverride, expectsReply:false});
              }

            } else if(message.trim() === "/user" || message.trim().startsWith("/user ")) {
              if(message.trim() === "/user") {
                let characterToReplyWith = await getUserCharacterObj(threadId);
                characterToReplyWith.modelName = thread.modelName; // use whatever model the thread character is using
                await doBotReplyInPlaceOfUser({characterToReplyWith, expectsReply:false});
                // await doBotReplyIfNeeded();
              } else {
                let replyInstruction = message.replace(/^\/user /, "").trimStart();
                // extract char name and ID from start of message if it's present
                let charNameAndId = replyInstruction.match(/^@([^#]+)#([0-9]+)/);
                let characterToReplyWith = null;
                if(charNameAndId) {
                  // let charName = charNameAndId[1];
                  let characterId = parseInt(charNameAndId[2]);
                  characterToReplyWith = await db.characters.get(characterId);
                  if(!characterToReplyWith) {
                    alert(`CharacterID not found: #${characterId}`);
                  }
                  replyInstruction = replyInstruction.replace(/^@([^#]+)#([0-9]+)/, "").trim() || null;
                }
                if(!characterToReplyWith) {
                  characterToReplyWith = await getUserCharacterObj(threadId);
                }
                await doBotReplyInPlaceOfUser({characterToReplyWith, replyInstruction, expectsReply:false});
              }
            } else if(message.trim() === "/sum") {
              // first ensure summary is up to date:
              let loadingModal = createLoadingModal("Please wait...");
              const onProgressMessage = (e) => loadingModal.updateContent("Please wait... "+e.message);
              let {summary, instructionHash, remainingMessages} = await computeAndSaveThreadSummaryIfNeeded({threadId, onProgressMessage});
              loadingModal.delete();
              if(summary === undefined) {
                return alert("No summary available for this thread yet. Wait until the thread gets longer.");
              }
              // now let them edit it:
              let result = await prompt2({summary: {label: "Summary:", type: "text", height:"fit-content", defaultValue: summary, focus:true}});
              if(result) {
                await db.summaries.update(instructionHash, {summary:result.summary});
                addToDebugLog(`<b>edited summary:</b> ${result.summary}`);
              }
            } else if(message.trim() === "/import") {
              let defaultValue = "";
              while(1) {
                let result = await prompt2({
                  messagesText: {label: "Add messages in the same format as <a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/initial-messages.md' target='blank'>initial messages</a> to add them to this thread:", type: "text", height:"fit-content", defaultValue: "", placeholder:"[USER]: Here's a user message.\n[SYSTEM]: Here's a system message.\n[AI]: Here's an AI message.\n[USER]: Messages can be multi-line\nlike this.", focus:true},
                });
                if(!result) break;
                let messages = parseMessagesFromTextFormat(result.messagesText);
                if(!messages) {
                  defaultValue = result.messagesText;
                  alert("Invalid message formating. Should start with either '[SYSTEM]:' or '[USER]:' or '[AI]:' (without the quotes).");
                } else {
                  let loadingModal = createLoadingModal("Please wait...");
                  let i = 0;
                  for(let message of messages) {
                    let messageCharacterId;
                    if(message.author === "ai") messageCharacterId = characterId;
                    else if(message.author === "user") messageCharacterId = -1;
                    else if(message.author === "system") messageCharacterId = -2;
                    else {
                      alert("There's a problem with parseMessagesFromTextFormat - it's producing an invalid 'author' value. Please report this problem on Github or the Discord server.");
                      defaultValue = result.messagesText;
                      continue;
                    }
                    let messageObj = createMessageObj({threadId, message:message.content, characterId:messageCharacterId, hiddenFrom:message.hiddenFrom || []});
                    messageObj.id = await addMessageToDb(messageObj);
                    i++;
                    if(i % 10 === 0) loadingModal.updateContent(`Please wait... (${i}/${messages.length})`);
                  }
                  await renderMessageFeed(threadId);
                  loadingModal.delete();
                  break;
                }
              }
              $.messageInput.value = "";
            } else if(message.trim() === "/mem") {
              let thread = await db.threads.get(threadId);
              let embeddingModelName = thread.textEmbeddingModelName;

              let originalGeneratedMemories = await db.memories.where({threadId, status:"current"}).toArray();
              originalGeneratedMemories.sort((a,b) => a.index - b.index);

              let textToMemoryObj = new Map();
              for(let entry of originalGeneratedMemories) {
                if(textToMemoryObj.has(entry.text)) {
                  // there's a duplicate, so for now we just hackily add a space to the end to avoid problems with mapping entries back to their object:
                  while(textToMemoryObj.has(entry.text)) {
                    entry.text += " ";
                  }
                  await db.memories.update(entry.id, {text:entry.text});
                }
                textToMemoryObj.set(entry.text, entry);
              }

              let textToEmbeddingCache = new Map();
              for(let entry of originalGeneratedMemories) {
                if(entry.embeddings[embeddingModelName] === undefined) { // <-- entry may not have an embedding if the embedding model was changed (or if there's a bug)
                  console.warn("Memory entry has no embedding for the current embedding model:", entry);
                } else {
                  textToEmbeddingCache.set(entry.text, entry.embeddings[embeddingModelName]);
                }
              }


              let originalGeneratedMemoriesText = originalGeneratedMemories.map(m => `${m.text}`).join("\n\n");

              let generatedDefaultValue = originalGeneratedMemoriesText;

              let loadingModal;

              let controls;

              async function regenerateMemoriesHandler() {
                if(!confirm("This DELETE all SUMMARIES and MEMORIES. Fresh summaries and memories will be regenerated during your character's next reply. Are you sure you want to delete all summaries and memories?")) return;
                let { instructionHashChain } = await computeAndSaveThreadSummaryIfNeeded({threadId, exitOnFirstHashMissAndReturnHashChain:true});
                await db.transaction('rw', [db.summaries, db.memories], async tx => {
                  await tx.table("summaries").where("hash").anyOf(instructionHashChain).delete();
                  await tx.table("memories").where({threadId}).delete();
                });
                controls.cancel();
              }

              while(1) {

                controls = {};

                let result = await prompt2({
                  generatedMemoriesText: {label: "Edit character 'memories'. Entries should be separated with a blank line. Edits should not significantly change the overall chronology. Use the <b>/lore</b> command to store non-chronological facts/things.", type: "text", height:"fit-content", defaultValue:generatedDefaultValue, placeholder:"If this box is empty, your character hasn't stored any memories yet because the chat thread isn't long enough to warrant it."},
                  reloadLoreUrlsButton: {hidden:true, type:"buttons", label:null, buttons:[{text:"delete &amp; regenerate all memories", onClick:regenerateMemoriesHandler}]},
                }, {submitButtonText:"save", controls});
                if(!result) break;
                
                // we set these so that if there's an error (e.g. while embedding, or with database) the while loop continues and they don't lose their edits
                generatedDefaultValue = result.generatedMemoriesText;

                // note: bit hacky, but we only trim newlines from start and end - NOT spaces, since we are using spaces to distinguish between different memories with the same text
                let newGeneratedMemoryTextEntries = result.generatedMemoriesText.replace(/\r/g, "").split(/\n{2,}/).map(m => m.replace(/^\n+|\n+$/g, "")).filter(m => m);

                loadingModal = createLoadingModal("Computing memory embeddings. Please wait...", $.middleColumn);

                let newTexts = [];
                for(let text of newGeneratedMemoryTextEntries) {
                  if(!textToEmbeddingCache.has(text)) {
                    newTexts.push(text);
                  }
                }

                try {

                  let newEmbeddings = await embedTexts({textArr:newTexts, modelName:embeddingModelName, shouldCache:true});
                  for(let i = 0; i < newTexts.length; i++) {
                    textToEmbeddingCache.set(newTexts[i], newEmbeddings[i]);
                  }

                  if(originalGeneratedMemoriesText !== result.generatedMemoriesText || newEmbeddings.length > 0) { // we need the `newEmbeddings.length > 0` bit because of stuff related to duplicate memories (possibly only due to since-fixed database upgrade bug)
                    let newMemoryObjs = [];
                    let index = 0;
                    let prevSummaryHash = originalGeneratedMemories[0]?.summaryHash ?? ""; // empty string as a summary hash indicates that the memory doesn't "belong" to any summary
                    for(let text of newGeneratedMemoryTextEntries) {
                      let embedding = textToEmbeddingCache.get(text);
                      let obj;
                      let existingObj = textToMemoryObj.get(text);
                      if(existingObj && !newMemoryObjs.includes(existingObj)) { // need to check if it's already in newMemoryObjs (and create a new one if so) otherwise we get a duplicate key error because the object has an id property
                        obj = textToMemoryObj.get(text);
                        prevSummaryHash = obj.summaryHash;
                        obj.index = index;
                        if(obj.embeddings[embeddingModelName] === undefined) obj.embeddings[embeddingModelName] = textToEmbeddingCache.get(text); // needed due to since-fixed bug
                      } else {
                        let embedding = textToEmbeddingCache.get(text);
                        // we group new memories under the previous memory hash. a valid summary hash is necessary because it's what we use to 'validate' that memories are 'current' during the summarization process.
                        obj = {summaryHash:prevSummaryHash, threadId, text, characterId:thread.characterId, embeddings:{[embeddingModelName]:embedding}, status:"current", index, triggers:[]};
                      }
                      newMemoryObjs.push(obj);
                      index++;
                    }

                    await db.transaction('rw', db.memories, async tx => {
                      // note: entries lose their original id if they are edited, which means references from message.memoryIdBatchesUsed are lost - that's okay, since it's just used for 'debugging' anyway - we just indicate to the user (in the 'brain icon modal') that the memory no longer exists.
                      await tx.table("memories").where({threadId, status:"current"}).delete();
                      await tx.table("memories").bulkAdd(newMemoryObjs);
                    });
                  }

                } catch(e) {
                  alert("There was an error while saving the memories:\n"+e.stack);
                  loadingModal.delete();
                  continue;
                }
                
                loadingModal.delete();
                break;
              }
              $.messageInput.value = "";
            } else if(message.trim().startsWith("/lore ")) {
              // text following /lore is a lore entry to add to db.lore
              let loadingModal = createLoadingModal("Computing lore embedding. Please wait...", $.middleColumn);
              let text = message.trim().slice("/lore ".length);
              let thread = await db.threads.get(threadId);
              let bookId = thread.loreBookId;
              let modelName = thread.textEmbeddingModelName;
              let embedding = await embedTexts({textArr:[text], modelName});
              let obj = {bookId, bookUrl:null, text, embeddings:{[modelName]:embedding[0]}, triggers:[]};
              await db.lore.add(obj);
              loadingModal.delete();
              $.messageInput.value = "";
            } else if(message.trim() === "/lore") {
              let thread = await db.threads.get(threadId);
              let character = await db.characters.get(thread.characterId);
              let loreBookId = thread.loreBookId;
              if(loreBookId === undefined) debugger;
              let originalLoreEntries = await db.lore.where({bookId:loreBookId}).toArray();

              let textToEmbeddingCache = new Map();
              for(let entry of originalLoreEntries) {
                textToEmbeddingCache.set(entry.text, entry.embedding);
              }

              let textToLoreObj = new Map();
              for(let entry of originalLoreEntries) {
                textToLoreObj.set(entry.text, entry);
              }

              let originalLoreEntriesText = originalLoreEntries.map(m => `${m.text}`).join("\n\n");

              let loreDefaultValue = originalLoreEntriesText;

              let loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(character.loreBookUrls).toArray();

              while(1) {
                let controls = {}; // this will get populated with `data` object that is proxied such that we can update the values of the inputs in reloadButtonClickHandler.

                async function reloadButtonClickHandler() {
                  await ensureLoreUrlsAreLoaded({loreBookUrls:character.loreBookUrls, modelName:thread.textEmbeddingModelName}).catch(e => {
                    console.error("Error loading lore urls:", e);
                    alert("Error loading lore urls: "+e);
                  });
                  loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(character.loreBookUrls).toArray();
                  controls.data.loreBookUrlEntriesText = loreBookUrlEntries.map(m => `${m.text}`).join("\n\n");
                }

                let result = await prompt2({
                  loreEntriesText: {label: "Add/edit lore entries for this thread. Entries should be separated with a blank line.", type: "text", height:"fit-content", defaultValue:loreDefaultValue, placeholder:"Here's an example lore entry.\n\nAnd here's another.\n\nAnd here's yet another. As you can see, lore entries should be separated with a blank line.", focus:true, infoTooltip:"Lorebook entries can be used to describe facts about your world, characters, towns, demographics, relationships, etc. The AI 'searches' the lorebook for relevant entries when it's trying to work out the most appropriate thing to say/write next. Use relevant words, phrases, character names, etc. in each entry to help it trigger it at the appropriate moments. Don't make lore entries too big - probably aim for a few sentences per entry, at most. You can add thousands of entries - it will NOT increase the price or slow down replies any more than if you only had e.g. 10 entries. You should think of lore entries like \"dynamic reminder messages\" which get read by the AI only when they're deemed relevant to the current situation in your story/chat."},
                  loreBookUrlEntriesText: {hidden:true, label: "Here are the entries loaded from this character's lorebook URLs. You can't edit these directly. Click the reload button below to pull in any changes that have been made to the character's lorebook URLs or the content at those URLs.", type: "text", disabled:true, height:"fit-content", defaultValue:loreBookUrlEntries.map(e => e.text).join("\n\n")},
                  reloadLoreUrlsButton: {hidden:true, type:"buttons", label:null, buttons:[{text:"Reload Lore URLs", onClick:reloadButtonClickHandler}]},
                }, {submitButtonText:"save", controls});
                if(!result) break;
                
                // we set these so that if there's an error (e.g. while embedding, or with database) the while loop continues and they don't lose their edits
                loreDefaultValue = result.loreEntriesText;

                let newLoreEntries = result.loreEntriesText.replace(/\r/g, "").split(/\n{2,}/).map(e => e.trim()).filter(e => e);

                // remove duplicates from newLoreEntries to prevent problems with our textToLoreObj mappings.
                // doesn't make sense to have duplicate memories anyway.
                newLoreEntries = [...new Set(newLoreEntries)];

                let loadingModal = createLoadingModal("Computing lore embeddings. Please wait...", $.middleColumn);

                let embeddingModelName = thread.textEmbeddingModelName;
                let newTexts = [];
                for(let text of newLoreEntries) {
                  if(!textToEmbeddingCache.has(text)) {
                    newTexts.push(text);
                  }
                }

                try {

                  let newEmbeddings = await embedTexts({textArr:newTexts, modelName:embeddingModelName});
                  for(let i = 0; i < newTexts.length; i++) {
                    textToEmbeddingCache.set(newTexts[i], newEmbeddings[i]);
                  }

                  if(originalLoreEntriesText !== result.loreEntriesText) {
                    let newLoreEntryObjs = [];
                    for(let text of newLoreEntries) {
                      let obj;
                      if(textToLoreObj.has(text)) {
                        obj = textToLoreObj.get(text);
                      } else {
                        let embedding = textToEmbeddingCache.get(text);
                        obj = {bookId:loreBookId, bookUrl:null, text, embeddings:{[embeddingModelName]:embedding}, triggers:[]};
                      }
                      newLoreEntryObjs.push(obj);
                    }

                    await db.transaction('rw', db.lore, async tx => {
                      // note: entries lose their original id if they are edited, which means references from message.loreIdsUsed are lost - that's okay, since it's just used for 'debugging' anyway - we just indicate to the user (in the 'brain icon modal') that the lore entry no longer exists.
                      await tx.table("lore").where({bookId:loreBookId}).delete();
                      await tx.table("lore").bulkAdd(newLoreEntryObjs);
                    });
                  }

                } catch(e) {
                  alert("There was an error while saving the lore entries:\n"+e.stack);
                  continue;
                }
                
                loadingModal.delete();
                break;
              }
              $.messageInput.value = "";
            } else if(message.startsWith("/name ") || message.startsWith("/avatar ")) {
              let arg = message.replace(/^\/(name|avatar) /, "");
              let thread = await db.threads.get(threadId);
              if(message.startsWith("/name ")) {
                let regex = new RegExp(characterNameValidationPattern);
                if(regex.test(arg)) {
                  thread.userCharacter.name = arg;
                  alert(`Your name has been changed to "${arg}" for this particular thread.`);
                } else {
                  alert(`Names must only contain letters, numbers, spaces, hyphens and underscores, and must be 64 characters or less. This is due to OpenAI API limitations.`);
                }

                // warn about changing name after summarization has started:
                let summaryCount = await db.summaries.where("threadId").equals(threadId).count();
                if(summaryCount > 0 && threadCharacter.fitMessagesInContextMethod === "summarizeOld") {
                  let warningMessage = `Warning: This character has summaries enabled which means that the summaries may contain references to your old name. You can see and edit the summary by typing /sum in the chat.`;
                  if(threadCharacter.associativeMemoryMethod !== "none") warningMessage += ` This is also the case for character memories. You can see and edit memories by typing /mem in the chat.`;
                  warningMessage += `\n\nIt's best to do any name changes at the start of the thread, before summaries${threadCharacter.associativeMemoryMethod !== "none" ? " and memories" : ""} start to be computed/stored.`;
                  alert(warningMessage);
                }
              } else if(message.startsWith("/avatar ")) {
                thread.userCharacter.avatar.url = arg;
              }
              await db.threads.update(threadId, {userCharacter: thread.userCharacter});
              await renderMessageFeed(threadId, {forceFullRender:true});
              $.messageInput.value = "";
            } else {

              let senderCharacterId = -1;
              if(message.startsWith("/sys ")) {
                message = message.replace(/^\/sys /, "");
                senderCharacterId = -2;
              }
              if(message.startsWith("/system ")) {
                message = message.replace(/^\/system /, "");
                senderCharacterId = -2;
              }

              let lastLineCommand = null;
              if(senderCharacterId === -1) {
                // user can end message with /ai <instruction> to give instruction to the AI for their reply:
                let messageLines = message.trim().split("\n");
                let lastLine = messageLines.pop();
                if(lastLine?.startsWith("/ai ") || lastLine?.startsWith("/user ")) {
                  message = messageLines.join("\n");
                  lastLineCommand = lastLine;
                }
              }

              let messageObj = createMessageObj({threadId, message, characterId:senderCharacterId});
              
              let id = await addMessageToDb(messageObj);
              messageObj.id = id;
              
              let character;
              if(messageObj.characterId === -1) character = await getUserCharacterObj(threadId);
              if(messageObj.characterId === -2) character = await getSystemCharacterObj(threadId);

              await addMessageToFeed(messageObj, {character});
              
              $.messageInput.value = "";
              $.messageInput.style.height = "";
              await triggerMessageActionCustomCodeEvent({threadId, eventData:{}, eventName:"MessageAdded", triggerBotReply:false});

              if(lastLineCommand) {
                $.messageInput.value = lastLineCommand;
                await sendButtonClickHandler();
              } else {
                await doBotReplyIfNeeded(); // note that we can't just pass the replyInstruction here because doBotReplyIfNeeded can get called in the process of executing triggerMessageActionCustomCodeEvent, so we use the global instructionForNextBotReply instead
              }
            }
          } catch(e) {
            console.error(e);
            alert("sendButtonClickHandler error: "+e.stack);
            $.messageInput.value = message;
          }

          await db.threads.update(threadId, {unsentMessageText:$.messageInput.value});

          if(threadCharacter.fitMessagesInContextMethod === "summarizeOld") {
            // we don't `await` this because we want it to happen in the background
            computeAndSaveThreadSummaryIfNeeded({threadId});
          }

          let messageCount = await db.messages.count();
          if(await db.threads.count() === 1 && (messageCount === 4 || messageCount === 5)) {
            await prompt2({message:{type:"none", html:dedent(`
              <div style="white-space: pre-wrap;"><b>Looks like this is your first thread on OpenCharacters, so here are some quick tips:</b>

              <b>1.</b> It's very important that you edit the AI's responses (with the pencil icon) if it says something you don't like - especially for the first few messages of a conversation. This is the most powerful way to control the AI's behavior. Much more powerful than the reminder note or the instruction because the AI will mostly tend to behave as it has previously behaved.

              <b>2.</b> Experiment with the reminder note. E.g. if your character's messages are a bit dull, remind it with something like "your writing should be imaginative and engaging", or "be the best roleplayer in the world", or if it's getting repetitive/cliche with its expressions, tell it to avoid doing that. Also try putting your reminders in the instruction and leaving the reminder blank - some users have reported that this works better for them.

              <b>3.</b> It can be helpful to "lock" the AI into a specific reply style by adding something like this to the instruction or reminder:

              <div style="opacity:0.5;">Messages should follow this pattern:
              "Hello!" - dialogue
              [Is she watching me?] - inner thoughts
              *He jumps out of the bushes.* - action</div>
              <b>4.</b> Look at the instructions and reminders of 'starter characters' for ideas, and visit the <a href="https://discord.com/channels/1085784427495432262/1098562307300278433" target="_blank">#share-guides</a> channel in our Discord server for guides/tips on achieving specific behavior and/or avoiding annoying issues.</div>`)}
            }, {cancelButtonText:null, submitButtonText:"Okay, got it"});
          }

        } finally {
          $.sendButton.disabled = false;
        }

      } 

      async function queueUpAutoReplies(replies) {
        for(let reply of replies) {
          $.messageInput.value = reply;
          await sendButtonClickHandler();
        }
      }

      function getDateTimeString(utcMs) {
        let now = new Date();
        if(now-utcMs > 1000*60*60*24) return new Date(utcMs).toISOString().split('T')[0].replace(/-/g, "/")+" "+new Date(utcMs).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}).replace(/^0([0-9]):/, "$1:");
        else return new Date(utcMs).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}).replace(/^0([0-9]):/, "$1:");
      }

      // db naming --> public custom code API naming
      const characterPropertiesVisibleToCustomCode = {
        name: "name",
        avatar: "avatar",
        roleInstruction: "roleInstruction",
        reminderMessage: "reminderMessage",
        initialMessages: "initialMessages",
        customCode: "customCode",
        temperature: "temperature",
        topP: "topP",
        frequencyPenalty: "frequencyPenalty",
        presencePenalty: "presencePenalty",
        // bestOf: "bestOf",
        // maxTokens: "maxTokens",
        stopSequences: "stopSequences",
        modelName: "modelName",
        // note: we DO NOT expose `character.userCharacter` (and same for character.systemCharacter) - custom code instead edits thread.userCharacter, which is a copy of character.userCharacter that's created at the start of a new thread
        // scene: "scene", // not exposing `scene` yet because I think it should probably be like userCharacter - i.e. instantiated as a thread property. but devs can edit scene by adding to messages anyway so no rush here.
        streamingResponse: "streamingResponse",
        customData: "customData",
        maxTokensPerMessage: "maxTokensPerMessage",
      };

      
      const customCodeIframes = {}; // threadId -> iframe
      async function createNewCustomCodeIframeForThread(threadId) {

        let thread = await db.threads.get(threadId);
        let character = await db.characters.get(thread.characterId);
        let customCode = (await db.characters.get(thread.characterId)).customCode || "";

        if(customCodeIframes[threadId]) {
          delete customCodeIframes[threadId];
        }

        let iframe = document.createElement("iframe");

        let pageLoadId = Math.random().toString();
        let iframeLoadPromise = new Promise((resolve, reject) => {
          function handler(e) {
            if(e.data._id === pageLoadId) {
              resolve();
              window.removeEventListener("message", handler);
            }
          }
          window.addEventListener("message", handler);
        });

        iframe.setAttribute("sandbox", "allow-scripts");
        // we MUST NOT set display:none here, because otherwise window.innerWidth/innerHeight are zero on init, which can confuse plugin devs.
        // instead we set opacity:0 and pointer-events:none, and then switch to display:none after load.
        iframe.style.cssText = "border:0; width:100%; height:100%; pointer-events:none; opacity:0; display:absolute; background:var(--background);";
        iframe.dataset.threadId = threadId;
        
        // let floatingWindow = createFloatingWindow({header:character.name, closeButtonAction:"hide"});
        // floatingWindow.bodyEl.appendChild(iframe);
        // floatingWindow.hide();

        $.customCodeIframeCtn.appendChild(iframe);
        customCodeIframes[threadId] = iframe;

        let srcDoc = dedent(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width">
          <base target="_blank">
        </head>
        <body>
        <script type="module">
          window.___dataInitializationFINISHED_836283628 = false;

          // Proxy fetch to remove CORS restrictions
          const proxyHandler = {
            apply: async function (target, thisArg, argumentsList) {
              let url;
              if(typeof argumentsList[0] === "object") url = argumentsList[0].url;
              else url = argumentsList[0];

              if(url.startsWith("blob:") || url.startsWith("data:")) return target.call(thisArg, ...argumentsList);

              let origin = new URL(url).origin;

              // for performance, exclude some CDNs that don't need CORS proxying
              if(
                origin.endsWith("jsdelivr.net")
                || origin.endsWith("catbox.moe")
                || (origin.endsWith("huggingface.co") && url.includes("/resolve/"))
                || origin === "https://raw.githubusercontent.com"
              ) {
                return target.call(thisArg, ...argumentsList);
              }

              // Note: This proxy server's code is public - you can see the code here: https://replit.com/@joe64/opencharacters-cors-proxy
              // It's what allows characters to make arbitrary requests to resources on the internet.
              // DO NOT use this URL directly in your code. The URL may change in future and your code will break.
              // Just use 'fetch' as normal and this proxy will be used automatically.
              // Note: I was originally trying a normal fetch and then only falling back to this CORS proxy if it failed, but the problem with that is that this would hit the endpoint twice, which may have side effects, and the user might not want that.
              // I may eventually have to add manual "exemptions" to skip proxying certain URLs that don't need it - like huggingface models, for example, since we could start to become bandwidth limited.
              const proxiedUrl = "https://opencharacters-cors-proxy.joe64.repl.co?url=" + encodeURIComponent(url);
              try {
                if(typeof argumentsList[0] === "object") {
                  argumentsList[0] = new Request(proxiedUrl, argumentsList[0]);
                  return target.call(thisArg, ...argumentsList);
                } else {
                  return target.call(thisArg, proxiedUrl, ...argumentsList.slice(1));
                }
              } catch(e) {
                console.error(e);
                return target.call(thisArg, ...argumentsList); // try unproxied if proxied fails
              }
            },
          };
          const originalFetch = window.fetch;
          window.fetch = new Proxy(fetch, proxyHandler);

          (function() {
            let userHandlers = {
              messageadded: [],
              messageedited: [],
              messagedeleted: [],
              messageinserted: [],
              streamingmessagechunk: [],
              streamingmessage: [],
            };
            let dataChangedByCustomCode = false;
            let dataSnapshotWhenLastSentToMainThread = null;
            
            window.oc = {
              thread: Object.seal({
                name: undefined,
                messages: [],
                userCharacter: Object.seal({
                  name: undefined,
                  avatar: Object.seal({
                    url: undefined,
                    size: undefined,
                    shape: undefined,
                  }),
                }),
                systemCharacter: Object.seal({
                  name: undefined,
                  avatar: Object.seal({
                    url: undefined,
                    size: undefined,
                    shape: undefined,
                  }),
                }),
                character: Object.seal({
                  name: undefined,
                  avatar: Object.seal({
                    url: undefined,
                    size: undefined,
                    shape: undefined,
                  }),
                  reminderMessage: undefined,
                  roleInstruction: undefined,
                }),
                customData: null,
                messageWrapperStyle: null,
                on: function(eventName, callback) {
                  userHandlers[eventName.toLowerCase()].push(callback);
                },
                off: function(eventName, callback) {
                  let i = userHandlers[eventName.toLowerCase()].indexOf(callback);
                  if(i !== -1) userHandlers[eventName.toLowerCase()].splice(i, 1);
                },
                once: function(eventName, callback) {
                  let handler = function() {
                    callback.apply(this, arguments);
                    this.off(eventName, handler);
                  }.bind(this);
                  this.on(eventName, handler);
                },
              }),
              character: Object.seal({
              ${Object.values(characterPropertiesVisibleToCustomCode).map(prop => `
                ${prop}: null,
              `).join("\n")}
                avatarUrl: null, // for backwards-compat
              }),
              window: Object.seal({
                show: function(args={}) {
                  window.parent.postMessage({type:"showWindow", threadId:${threadId}, args}, "*");
                },
                hide: function(args={}) {
                  window.parent.postMessage({type:"hideWindow", threadId:${threadId}, args}, "*");
                },
              }),
              //getCompletion: async function(options) {
              //  let data = {type:"getCompletion", options};
              //  return callParentWindow(data);
              //},
              getChatCompletion: async function(options) {
                let data = {type:"getChatCompletion", options};
                return callParentWindow(data);
              },
              messageRenderingPipeline: [],
            };


            // Construct StreamingMessage event out of StreamingMessageChunk events:
            class AsyncQueue {
              constructor() {
                this.queue = [];
                this.resolvers = [];
              }
              push(value) {
                if(this.resolvers.length > 0) this.resolvers.shift()(value);
                else this.queue.push(value);
              }
              async pop() {
                if(this.queue.length > 0) return this.queue.shift();
                return new Promise((resolve) => { this.resolvers.push(resolve); });
              }
            }
            async function* readChunks(streamId, queue) {
              while (true) {
                const chunk = await queue.pop();
                if(!chunk) break;
                yield chunk;
                if(chunk.last) {
                  streamQueues.delete(streamId);
                  break;
                }
              }
            }
            const streamQueues = new Map();
            oc.thread.on("StreamingMessageChunk", async function (chunk) {
              const { streamId } = chunk;
              let queue = streamQueues.get(streamId);
              if(!queue) {
                queue = new AsyncQueue();
                streamQueues.set(streamId, queue);
                for(let handler of userHandlers.streamingmessage) {
                  handler({ streamId, chunks: readChunks(streamId, queue) });
                }
              }
              queue.push(chunk);
            });

            function callParentWindow(data) {
              let _id = Math.random().toString()+Math.random().toString();
              return new Promise((resolve, reject) => {
                window.parent.postMessage({_id, data, threadId:${threadId}}, "*");
                function handler(e) {
                  if(e.data._id === _id) {
                    window.removeEventListener("message", handler);
                    if(e.data.success) resolve(e.data.result);
                    else reject(e.data.result);
                  }
                }
                window.addEventListener("message", handler);
              });
            }

            const originalOcObject = window.oc;

            // function watchObject(obj, callback) {
            //   let proxy = new Proxy(obj, {
            //     set: function(target, prop, value) {
            //       target[prop] = value;
            //       callback(prop, value);
            //       return true;
            //     }
            //   });
            //   return proxy;
            // }
            // function watchArray(arr, callback) {
            //   // note that we need to watch set and get because get is called for push/pop/etc.
            //   let proxy = new Proxy(arr, {
            //     set: function(target, prop, value) {
            //       target[prop] = value;
            //       callback(prop);
            //       return true;
            //     },
            //     get: function(target, prop) {
            //       if(isNaN(Number(prop))) { // ignore array indexing
            //         callback(prop); 
            //       }
            //       return target[prop];
            //     }
            //   });
            //   return proxy;
            // }

            // TODO: later we can track changes in a more fine-grained way to reduce data transfer between this frame and parent

            // oc.thread.messages = watchArray(oc.thread.messages, (prop) => {
            //   dataChangedByCustomCode = true;
            // });
            // let currentThreadMessagesArray = oc.thread.messages;
            // let ignoreMessagePropSetter = false;
            // window.oc.thread = watchObject(oc.thread, (prop, value) => {
            //   if(ignoreMessagePropSetter) return;
            //   // if they set the messages prop to a new array, we need to watch that array:
            //   if(prop === "messages" && value && value !== currentThreadMessagesArray) { // NOTE: oc.thread.messages is *already* set to 'value', so we need to track with currentThreadMessagesArray
            //     ignoreMessagePropSetter = true; // need to ignore because we're about to change oc.thread.messages which would cause infinite loop
            //     oc.thread.messages = watchArray(value, (prop) => {
            //       dataChangedByCustomCode = true;
            //     });
            //     ignoreMessagePropSetter = false;
            //     currentThreadMessagesArray = oc.thread.messages;
            //   }
            //   dataChangedByCustomCode = true;
            // });
            // window.oc.character = watchObject(oc.character, (prop) => {
            //   dataChangedByCustomCode = true;
            // });


            // https://stackoverflow.com/a/58983264/11950764
            // This tracks all changes to the object, including nested objects, and including new objects/arrays that are added as properties.
            let deepOnChangeProxyCache = new WeakMap();
            function createDeepOnChangeProxy(target, onChange) {
              return new Proxy(target, {
                get(target, property) {
                  const item = target[property];
                  if (item && typeof item === 'object') {
                    if (deepOnChangeProxyCache.has(item)) return deepOnChangeProxyCache.get(item);
                    const proxy = createDeepOnChangeProxy(item, onChange);
                    deepOnChangeProxyCache.set(item, proxy);
                    return proxy;
                  }
                  return item;
                },
                set(target, property, newValue) {
                  target[property] = newValue;
                  onChange();
                  return true;
                },
              });
            }


            window.oc.character = createDeepOnChangeProxy(window.oc.character, function() {
              dataChangedByCustomCode = true;
            });
            window.oc.thread = createDeepOnChangeProxy(window.oc.thread, function() {
              dataChangedByCustomCode = true;
            });

            window.oc = Object.freeze(window.oc);




            function getCurrentData() {
              // we need to ignore the Proxy trigger while we do this:
              let origFlag = dataChangedByCustomCode;
              let data = JSON.parse(JSON.stringify(oc));
              dataChangedByCustomCode = origFlag;
              return data;
            }
            function getChangedData() {
              let origFlag = dataChangedByCustomCode;
              let prevData = dataSnapshotWhenLastSentToMainThread;
              let changedData = getCurrentData();
              // delete any values of changedData that were the same as existing data so we only send back changes:
              for(let key in prevData.thread) {
                if(typeof prevData.thread[key] === "object") {
                  // need to stringify to test sameness of arrays and other non-primitives:
                  // TODO: maybe make this more efficient at some point - stringifying a huge thread could be sluggish
                  // TODO: and it should really just send back a *delta*, rather than whole messages array
                  if(JSON.stringify(prevData.thread[key]) === JSON.stringify(changedData.thread[key])) delete changedData.thread[key];
                } else {
                  if(prevData.thread[key] === changedData.thread[key]) delete changedData.thread[key];
                }
              }
              for(let key in prevData.character) {
                if(typeof prevData.character[key] === "object") {
                  if(JSON.stringify(prevData.character[key]) === JSON.stringify(changedData.character[key])) delete changedData.character[key];
                } else {
                  if(prevData.character[key] === changedData.character[key]) delete changedData.character[key];
                }
              }
              dataChangedByCustomCode = origFlag;
              return changedData;
            }
            async function sendBackDataUpdatesIfNeeded() {
              if(dataChangedByCustomCode) {
                let changedData = getChangedData();
                // if(changedData.thread.messages && new Set(changedData.thread.messages.map(m => m.content)).size < changedData.thread.messages.length) {
                //   debugger;
                // }
                dataChangedByCustomCode = false;
                dataSnapshotWhenLastSentToMainThread = getCurrentData();
                console.log("Custom code changed character/thread data:", changedData);
                await callParentWindow({type:"dataChanged", data:changedData})
              }
            }

            let currentlyProcessingMessageActionHandlers = false;
            (async function() {
              while(1) {
                try {
                  // TODO: make this more efficient - polling is not ideal
                  await new Promise(r => setTimeout(r, 100));

                  // MessageAdded/MessageEdited event is special in that it sends data back immediately afterwards,
                  // so to prevent any weirdness, we wait for it to finish:
                  while(currentlyProcessingMessageActionHandlers) {
                    await new Promise(r => setTimeout(r, 100));
                  }

                  if(dataChangedByCustomCode) {
                    await sendBackDataUpdatesIfNeeded();
                  }
                } catch(e) {
                  console.error(e);
                }
              }
            })();




            window.addEventListener("message", async function(e) {
              if(e.source !== window.parent || e.origin !== "${window.location.origin}") return;

              if(e.data.eventName?.toLowerCase() !== "streamingmessagechunk") {
                console.log("customCode iframe received message (note: streamingmessagechunk messages are not logged):", e.data);
              }

              if(!e.data._id) return;
              if(window.oc !== originalOcObject) {
                // oc is frozen and oc.character/thread are sealed, but they can still overwrite window.oc - however, this is a security issue, since oc gets JSONified and sent back to the main thread when data changes, and I don't want to have to deal with unexpected properties on the main thread because it could be dangerous
                window.parent.postMessage({_id:e.data._id, success:false, result:"oc has been modified. Please do not modify window.oc."}, "${window.location.origin}");
                return;
              }

              if(e.data.type === "function") {
                try {
                  let fn = new Function(\`return (\${e.data.functionText})\`)();
                  let output = await fn(e.data.functionArg);
                  window.parent.postMessage({_id:e.data._id, success:true, result:output}, "${window.location.origin}");
                } catch(err) {
                  console.error(err);
                  window.parent.postMessage({_id:e.data._id, success:false, result:err.message+"\\n"+err.stack}, "${window.location.origin}");
                }
              }

              if(e.data.type === "event") {
                let eventName = e.data.eventName.toLowerCase();
                
                if(eventName === "messageadded" || eventName === "messageedited"  || eventName === "messagedeleted" || eventName === "messageinserted") {
                  currentlyProcessingMessageActionHandlers = true; // <-- we use this variable to pause the normal data update polling.
                  let returnData = null;
                  try {
                    let updates = e.data.data.updates;
                    let eventData = e.data.data.eventData;

                    let userFacingEventData = {};

                    // this must come *before* overwriting oc.thread.messages because after that point we can't get the original message object
                    if(eventName === "messagedeleted") {
                      userFacingEventData.message = oc.thread.messages.find(m => m.id === eventData.messageId);
                      userFacingEventData.originalIndex = oc.thread.messages.findIndex(m => m.id === eventData.messageId);
                    }
                    
                    let origFlag = dataChangedByCustomCode;
                    oc.thread.messages = updates.thread.messages;
                    dataChangedByCustomCode = origFlag;

                    // this must come *after* overwriting oc.thread.messages because we want event.message to be an actual reference to the message object that's currently in the oc.thread.messages array.
                    if(eventName !== "messagedeleted") {
                      if(eventName === "messageadded") {
                        userFacingEventData.message = oc.thread.messages.at(-1);
                      } else {
                        userFacingEventData.message = oc.thread.messages.find(m => m.id === eventData.messageId);
                      }
                    }
                    
                    await Promise.all(userHandlers[eventName].map(handler => handler(userFacingEventData)));
                    
                    if(dataChangedByCustomCode) {
                      returnData = getChangedData();
                      dataChangedByCustomCode = false;
                      dataSnapshotWhenLastSentToMainThread = getCurrentData();
                    }
                  } catch(e) {
                    console.error(\`There was an error while processing the \${eventName} event:\`);
                    console.error(e);
                  }
                  console.log("custom code iframe sending back:", returnData);
                  window.parent.postMessage({_id:e.data._id, success:true, result:returnData}, "${window.location.origin}");
                  currentlyProcessingMessageActionHandlers = false;
                }

                if(eventName === "streamingmessagechunk") {
                  let data = e.data.data;
                  await Promise.all(userHandlers.streamingmessagechunk.map(handler => handler(data)));
                }

              }

              if(e.data.type === "init") {

                function applyObjectOverrides({object, overrides}) {
                  for(let key in overrides) {
                    if(Array.isArray(overrides[key])) {
                      object[key] = structuredClone(overrides[key]); // arrays are treated as "final" values - we don't go "into" them
                    } else if(typeof overrides[key] === "object" && overrides[key] !== null) {
                      if (!object.hasOwnProperty(key) || typeof object[key] !== "object" || object[key] === null) {
                        object[key] = {};
                      }
                      applyObjectOverrides({object:object[key], overrides:overrides[key]});
                    } else {
                      object[key] = overrides[key];
                    }
                  }
                }

                let data = e.data.initialData;
                applyObjectOverrides({object:oc.thread, overrides:data.thread});
                applyObjectOverrides({object:oc.character, overrides:data.character});
                window.___dataInitializationFINISHED_836283628 = true;
                dataChangedByCustomCode = false;
                dataSnapshotWhenLastSentToMainThread = getCurrentData();

                // it's important that we wait for custom code to finish loading before we indicate that init has finished.
                let loopDelay = 5;
                let waitedTime = 0;
                while(1) {
                  if(window.__customCodeInitializationIsComplete_846298638) {
                    break;
                  }
                  if(waitedTime > 10 && !window.__customCodeInitializationSTARTED_846298638) {
                    // it should at least *START* in milliseconds, so this almost certainly indicates they had a syntax error in their code which prevented the whole script tag from executing at all.
                    // note: *non-syntax* errors are caught by a try/catch loop. this is just for syntax errors.
                    break; // <-- break to prevent endless loading screen
                  }
                  await new Promise(r => setTimeout(r, loopDelay));
                  waitedTime += loopDelay;
                }
                
                window.parent.postMessage({_id:e.data._id, success:true, result:null}, "${window.location.origin}");
              }
            });
          })();

          // this must come before the wait-for-initialization below, because it's what ends up triggering initialization
          window.addEventListener("load", () => {
            window.parent.postMessage({_id:"${pageLoadId}"}, "${window.location.origin}");
          });

        <\/script>

        <!-- note: this must be a separate code block from above, because otherwise static imports are initialised before window.oc exists -->
        <script type="module" class="customCodeScriptElement">
          window.__customCodeInitializationSTARTED_846298638 = true;

          // we need to wait for the oc data to load because they may immediately reference it in their custom code
          while(1) {
            if(window.___dataInitializationFINISHED_836283628) break;
            await new Promise(r => setTimeout(r, 5));
          }
          console.log("Data initialization of sandboxed iframe is complete.");
          try {
            // currently the only reason this is wrapped in an async function is to throw an error if the user's code contains a static import, since static imports are pre-loaded and thus jump ahead of initialization
            // oh and maybe we need it to be able to catch wrap this try/catch around it too?
            await (async () => {
              {{customCode}}
            })();
          } catch(e) {
            console.error(e);
          }

          // backwards-compat with old processMessages function:
          if(window.processMessages) {
            oc.thread.on("MessageAdded", async function() {
              await window.processMessages(window.oc.thread.messages);
            });
          }
          window.__customCodeInitializationIsComplete_846298638 = true;
        <\/script>

        <!-- some code for helping devs with custom code bugs/problems: -->
        <script type="module">
          await new Promise(r => setTimeout(r, 100));

          let customCodeScriptElementText = document.querySelector(".customCodeScriptElement")?.textContent || ""; // optional chaining is needed since they may have deleted it via document.body.innerHTML=...

          if(!window.__customCodeInitializationSTARTED_846298638) { // if it hasn't *started* after 1 second, it's almost certainly a parsing bug
            let staticImportRegex = ${/(^|\s)import(\s+(\*\s+as\s+\w+|{[^}]*})?\s+from)?\s*['"][^'"]+\.js['"]\s*;?/.toString()};
            if(staticImportRegex.test(customCodeScriptElementText)) {
              console.warn("It looks like your character's custom code may have static import statements like:\\n\\nimport 'foo.js';  or  import { abc } from 'foo.js';\\n\\nIf so, please change them to dynamic imports like this:\\n\\nawait import('foo.js');  or  let { abc } = await import('foo.js');\\n\\nFor technical reasons, static imports are not supported in custom code.");
            }
          }
        <\/script>

        </body>
        </html>`); // need to escape the closing script tag so it doesn't close the script tag that this code is within
        
        // using template+split+join so dedent works properly
        iframe.srcdoc = srcDoc.split("{{customCode}}").join(customCode);

        await iframeLoadPromise;

        iframe.style.pointerEvents = "";
        iframe.style.opacity = "";
        iframe.style.display = "none";

        if(isMobile && activeThreadId === threadId && thread.customCodeWindow.visible && $.rightColumn.dataset.visible === "no") {
          // this is necessary (and must come before the triggerInitCustomCodeEvent call, below) because some iframes will require user interaction to initialize the thread - if dev shows the iframe, then they probably want the mobile user to see it first (new users probably wouldn't know to click the button that shows the iframe)
          $.toggleRightColumnButton.click();
        }

        await triggerInitCustomCodeEvent(threadId);

      }

      let customCodeResolvers = {}; // id -> resolver
      window.addEventListener("message", function(e) {
        let resolver = customCodeResolvers[e.data._id];
        if(resolver) {
          if(e.data.success) {
            resolver(e.data.result);
          } else {
            console.error(e);
            alert("There was a problem with this character's custom code:\n\n"+e.data.result);
            resolver(null);
          }
          delete customCodeResolvers[e.data._id];
        }
      });

      window.addEventListener("message", async function(e) {
        let threadId = e.data.threadId;
        let args = e.data.args;
        let types = ["showWindow", "hideWindow"];
        if(types.includes(e.data?.type) && customCodeIframes[threadId]?.contentWindow === e.source) {
          let visible = null;
          if(e.data.type === "showWindow") visible = true;
          if(e.data.type === "hideWindow") visible = false;
          let thread = await db.threads.get(threadId);
          thread.customCodeWindow.visible = visible;
          if(args.width !== undefined && typeof args.width === "number" || typeof args.width === "string") {
            thread.customCodeWindow.width = args.width;
          }
          await db.threads.update(threadId, {customCodeWindow: thread.customCodeWindow});
          await updateCustomCodeIframeVisibility();
        }
      });


      async function updateCustomCodeIframeVisibility() {
        let visibleThreadId = null;
        if($.messageFeed.offsetWidth > 0 && activeThreadId !== null) {
          visibleThreadId = activeThreadId;
        }
        let visibleThread = null;
        if(visibleThreadId !== null) visibleThread = await db.threads.get(visibleThreadId);

        let character = null;
        if(visibleThread !== null) character = await db.characters.get(visibleThread.characterId);

        $.customCodeIframeCtn.querySelectorAll(`iframe`).forEach(iframe => iframe.style.display = "none");
        $.customCodeColumn.style.display = "none";

        if(visibleThread !== null && character.customCode.trim() && visibleThread.customCodeWindow.visible === true) {
          customCodeIframes[visibleThreadId].style.display = "block";
          let width = visibleThread.customCodeWindow.width ?? "300px";
          if(typeof width === "number") width = width+"px";
          $.customCodeIframeCtn.style.width = width;
          $.customCodeColumn.style.display = "flex";
          if(isMobile) {
            $.toggleRightColumnButton.style.display = "flex";
            $.customCodeIframeCtn.style.width = "100%";
            if($.rightColumn.dataset.visible === "no") {
              $.toggleRightColumnButton.click();
            }
          }
        } else {
          if(isMobile) {
            $.toggleRightColumnButton.style.display = "none";
            if($.rightColumn.dataset.visible === "yes") {
              $.toggleRightColumnButton.click();
            }
          }
        }
      }

      $.customCodeIframeHorizontalResizeBar.addEventListener("mousedown", function(e) {
        e.preventDefault();

        // display an element that covers the entire screen, so that the user can drag the mouse over the iframe without losing mouse events:
        let cover = document.createElement("div");
        cover.style.cssText = "position:fixed;top:0;left:0;right:0;bottom:0;z-index:99";
        document.body.appendChild(cover);
        cover.addEventListener("mouseup", function() {
          cover.remove();
        });

        let startX = e.clientX;
        let startWidth = $.customCodeIframeCtn.offsetWidth;
        let mousemove = function(e) {
          let newWidth = startWidth - (e.clientX - startX);
          $.customCodeIframeCtn.style.width = newWidth+"px";
        };
        let mouseup = async function(e) {
          window.removeEventListener("mousemove", mousemove);
          window.removeEventListener("mouseup", mouseup);
          let visibleThreadId = activeThreadId;
          let visibleThread = await db.threads.get(visibleThreadId);
          visibleThread.customCodeWindow.width = $.customCodeIframeCtn.offsetWidth;
          await db.threads.update(visibleThreadId, {customCodeWindow: visibleThread.customCodeWindow});
        };
        window.addEventListener("mousemove", mousemove);
        window.addEventListener("mouseup", mouseup);
      });


      let botIsCurrentlyReplyingPromise = null;


      // TODO: make this a user setting (in misc db)
      const customCodeCompletionTokenWarnLimit = 5_000_000; // $10 at current turbo-3.5 prices

      const customCodeCompletionUsage = {}; // token counts for each thread
      const threadIdsAllowedToGoOverTokenLimit = new Set();
      const threadIdsBlockedFromGoingOverTokenLimit = new Set();
      window.addEventListener("message", async function(e) {
        let threadId = e.data.threadId;
        let types = ["getChatCompletion", "dataChanged"];
        const data = e.data.data;
        if(data && types.includes(data.type) && customCodeIframes[threadId]?.contentWindow === e.source) {
          let thread = await db.threads.get(threadId);
          let character = await db.characters.get(thread.characterId);
          
          if(data.type === "getChatCompletion") {
            let options = data.options;
            let messages = options.messages;

            if(!messages || !messages[0].content || !messages[0].author) {
              let result = "Invalid parameter: The first input to oc.getChatCompletion should be an options object, and 'options.messages' must be an array of objects with 'content' and 'author' properties.";
              customCodeIframes[e.data.threadId].contentWindow.postMessage({_id:e.data._id, success:false, result}, "*");
              return;
            }

            // transform and clean the options data:
            options.messages.forEach(m => {
              m.content = m.content+"";
              m.role = m.author==="user"?"user" : m.author==="ai"?"assistant" : m.author==="system"?"system" : "system";
              if(m.name) m.name = m.name+"";
              let allowedKeys = ["content", "role", "name"];
              for(let key in m) {
                if(!allowedKeys.includes(key)) delete m[key];
              }
            });
            let o = {
              messages: options.messages,
              modelName: thread.modelName,
              temperature: options.temperature === undefined ? undefined : Number(options.temperature),
              stopSequences: Array.isArray(options.stopSequences) ? options.stopSequences.map(s => s+"") : undefined,
              topP: options.topP === undefined ? undefined : Number(options.topP),
              frequencyPenalty: options.frequencyPenalty === undefined ? undefined : Number(options.frequencyPenalty),
              presencePenalty: options.presencePenalty === undefined ? undefined : Number(options.presencePenalty),
            };
            if(!customCodeCompletionUsage[threadId]) customCodeCompletionUsage[threadId] = 0;
            let tokens = await countTokensInMessages(o.messages, thread.modelName);
            customCodeCompletionUsage[threadId] += tokens;
            if(customCodeCompletionUsage[threadId] > customCodeCompletionTokenWarnLimit && !threadIdsAllowedToGoOverTokenLimit.has(threadId)) {
              if(threadIdsBlockedFromGoingOverTokenLimit.has(threadId)) {
                return;
              }
              if(confirm(`This character's custom code has used ${customCodeCompletionUsage[threadId].toLocaleString()} tokens. Would you like to continue?`)) {
                threadIdsAllowedToGoOverTokenLimit.add(threadId);
              } else {
                threadIdsBlockedFromGoingOverTokenLimit.add(threadId);
                return;
              }
            }

            
            o.threadId = threadId; // this is just for tracking token usage

            let result = await getChatCompletion(o);
            customCodeCompletionUsage[threadId] += await countTokens(result, thread.modelName);
            customCodeIframes[e.data.threadId].contentWindow.postMessage({_id:e.data._id, success:true, result}, "*");
          }


          if(data.type === "dataChanged") {
            let receivedData = data.data;
            if(botIsCurrentlyReplyingPromise) {
              await botIsCurrentlyReplyingPromise; // otherwise we'll render the feed and thus delete the "typing indicator" placeholder or the streaming response
            }
            await updateDbWithNewDataFromCustomCode({threadId, receivedData});
            await renderMessageFeed(threadId);
            customCodeIframes[e.data.threadId].contentWindow.postMessage({_id:e.data._id, success:true, result:null}, "*");
          }

        }
      });
      
      async function sendCustomCodeIframeMessage(threadId, data) {
        let iframe = customCodeIframes[threadId];
        let _id = Math.random().toString()+Math.random().toString();
        data._id = _id;
        iframe.contentWindow.postMessage(data, "*");
        return new Promise(r => {
          customCodeResolvers[_id] = r;
        });
      }

      // this is for onclick handlers in messages
      window.runCodeInCustomCodeIframe = function(code) {
        let threadId = activeThreadId;
        let functionText = `function() {
          ${code}
        }`;
        sendCustomCodeIframeMessage(threadId, {type:"function", functionText, functionArg:undefined});
      };

      async function getDataForCustomCode(threadId) {
        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);

        let userCharacter = await getUserCharacterObj(threadId); // note that this function takes threadId as input because it thread-specific overrides, like for name and avatar url

        if(!threadCharacter.customCode?.trim()) return;

        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        // console.log("@@@@@@@@@@@ getDataForCustomCode: messages before formatting for custom code: ", messages);
        let formattedMessages = await messagesToCustomCodeFormat({messages});
        let data = {
          thread: {
            name: thread.name,
            messages: formattedMessages,
            userCharacter: thread.userCharacter,
            systemCharacter: thread.systemCharacter,
            customData: thread.customData,
            character: thread.character,
            messageWrapperStyle: thread.messageWrapperStyle,
          },
          character: {},
        };
        for(let key in characterPropertiesVisibleToCustomCode) {
          data.character[characterPropertiesVisibleToCustomCode[key]] = threadCharacter[key];
        }

        // backwards-compat properties:
        data.character.avatarUrl = threadCharacter.avatar.url;
        
        return {data, originalMessages:messages};
      }

      async function triggerInitCustomCodeEvent(threadId) {
        let {data, originalMessages} = await getDataForCustomCode(threadId);
        await sendCustomCodeIframeMessage(threadId, {type:"init", initialData:data});
      }

      // this function runs after every message is added: https://github.com/josephrocca/OpenCharacters/blob/main/docs/custom-code.md
      async function triggerMessageActionCustomCodeEvent({threadId, eventData, eventName, triggerBotReply=true}={}) {
        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);

        if(!threadCharacter.customCode) return;

        $.statusNotifier.innerHTML = "<span style='opacity: 0.6; font-size: 0.9rem;'>⌛ custom code processing</span><div style='width:0.5rem;'></div>"+createTypingIndicatorHtml();
        showEl($.statusNotifier);

        let { data, originalMessages } = await getDataForCustomCode(threadId);
        let updates = data;
        console.log(`@@@@@@@@@@@ Data sent to custom code for ${eventName} handler:`, updates);
        let receivedData = await sendCustomCodeIframeMessage(threadId, {type:"event", eventName:eventName.toLowerCase(), data:{updates, eventData}});
        console.log(`@@@@@@@@@@@ Data received from custom code after ${eventName} handler:`, receivedData);
        if(receivedData) await updateDbWithNewDataFromCustomCode({threadId, receivedData, originalMessages});
        $.statusNotifier.innerHTML = "";
        hideEl($.statusNotifier);

        let currentThreadId = activeThreadId;
        if(threadId === currentThreadId) { // <-- since user may have switched threads
          await renderMessageFeed(threadId, {triggerBotReply});
        }
      }

      async function triggerStreamingMessageChunkCustomCodeEvent(threadId, chunkData) {
        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);
        if(!threadCharacter.customCode) return;
        
        await sendCustomCodeIframeMessage(threadId, {type:"event", eventName:"streamingmessagechunk", data:chunkData});
      }

      // let alreadyCurrentlyUpdatingDbWithNewDataFromCustomCode = false;
      async function updateDbWithNewDataFromCustomCode({threadId, receivedData, originalMessages}) {

        // backwards-compat:
        if(receivedData.character?.avatarUrl) {
          if(!receivedData.character?.avatar?.url?.trim()) {
            if(!receivedData.character.avatar) receivedData.character.avatar = {};
            receivedData.character.avatar.url = receivedData.character.avatarUrl;
          }
          delete receivedData.character.avatarUrl;
        }

        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);

        // THREAD MESSAGES:
        if(receivedData.thread?.messages) {
          // note that originalMessages will only be defined if this is part of the MessageHandler process - because in that case we actually sent the messages, whereas in the data polling updates, we didn't send anything
          // currentMessages and originalMessages can differ because e.g. a message could have been deleted by the user while the custom code was processing
          let currentMessages = await db.messages.where("threadId").equals(threadId).toArray();
          currentMessages.sort((a,b) => a.order - b.order);
          let outputMessageObjs = await messagesFromCustomCodeFormat({messages:receivedData.thread.messages, originalMessages: originalMessages ?? currentMessages, threadId});
          // console.log("@@@@@@@@@@@ Messages back in db format:", outputMessageObjs);

          // order the messages (from the db's perspective) according to how the custom code ordered the oc.thread.messages array
          let order = 0;
          for(let m of outputMessageObjs) {
            m.order = order++;
          }

          for(let m of outputMessageObjs) {
            if(typeof m.id !== "number") {
              delete m.id;
            }
          }

          // they may have duplicated an object, which means there'll be an id collision, so we remove all later duplicate ids
          let idsGotAlready = [];
          for(let m of outputMessageObjs) {
            if(idsGotAlready.includes(m.id)) {
              delete m.id;
            } else {
              idsGotAlready.push(m.id);
            }
          }

          // if they have added an id that's not an id that exists in currentMessages, we remove that message's id:
          let currentMessageIds = currentMessages.map(m => m.id);
          for(let m of outputMessageObjs) {
            if(typeof m.id === "number" && !currentMessageIds.includes(m.id)) {
              delete m.id;
            }
          } 

          // if messages have been deleted, then we need to set those m.messageIdsUsed to -1
          for(let m of outputMessageObjs) {
            m.messageIdsUsed = m.messageIdsUsed.map(referencedId => {
              if(currentMessageIds.includes(referencedId)) return referencedId;
              else return -1;
              // if(!originalOrCurrentMessageIds.includes(referencedId) && referencedId !== -1) {
              //   // this is fine (i.e. not an error) if we *don't* have originalMessages (i.e. if we're relying on a fresh db request right at this moment) because it's possible that e.g. the user deleted a message while the custom code was processing.
              //   // but if we *do* have originalMessages, then something is wrong - why would messageIdsUsed (which isn't exposed to custom code, to be clear) contain ids of messages that don't exist in the *original* messages that we sent to the custom code iframe?
              //   if(originalMessages) {
              //     throw new Error("messageIdsUsed should only contain ids of messages that exist in the original messages");
              //   } else {
              //     return -1;
              //   }
              // }
              // if(deletedMessageIds.includes(referencedId)) return -1;
              // else return referencedId;
            });
          }

          // note that messagesFromCustomCodeFormat re-numbers `message.order` so it matches the order of the oc.thread.messages array that was returned.

          // replace messages in the database with the new messages
          // we need to make sure that no other db.messages code runs between .delete and .bulkAdd, so we use a transaction that gets a read-write lock on the messages table.
          // otherwise e.g. another call to updateDbWithNewDataFromCustomCode could run between them, and that would cause `db.messages.where("threadId").equals(threadId).toArray()` to incorrectly return zero messages.
          await db.transaction('rw', db.messages, async (tx) => {
            let existingMessageIds = await tx.table("messages").where("threadId").equals(threadId).toArray().then(arr => arr.map(m => m.id));
            await safelyDeleteMessagesByIds(existingMessageIds, {tx});

            let ids = outputMessageObjs.filter(m => m.id !== undefined).map(m => m.id);
            if(new Set(ids).size !== ids.length) {
              throw new Error("Duplicate message ids after custom code processing. This is a bug.");
            }

            await tx.table("messages").bulkAdd(outputMessageObjs).catch(e => {
              console.error(e);
              alert("There was an error during custom code handling - updateDbWithNewDataFromCustomCode.\n\n"+e.stack);
            });
          });

          // let newMessages = await db.messages.where("threadId").equals(threadId).toArray();
          // debugger;
        }
        
        // OTHER THREAD STUFF:
        let threadListChanged = false;
        await db.transaction('rw', db.threads, async tx => {
          let thread = await tx.table("threads").get(threadId);
          let changed = false;
          if(receivedData.thread?.userCharacter) {
            applyObjectOverrides({object:thread.userCharacter, overrides:receivedData.thread.userCharacter});
            changed = true;
          }
          if(receivedData.thread?.systemCharacter) {
            applyObjectOverrides({object:thread.systemCharacter, overrides:receivedData.thread.systemCharacter});
            changed = true;
          }
          if(receivedData.thread?.character) {
            applyObjectOverrides({object:thread.character, overrides:receivedData.thread.character});
            changed = true;
          }
          if(receivedData.thread?.customData) {
            thread.customData = receivedData.thread.customData;
            changed = true;
          }
          if(receivedData.thread?.messageWrapperStyle) {
            thread.messageWrapperStyle = receivedData.thread.messageWrapperStyle;
            changed = true;
          }
          if(receivedData.thread?.name) {
            thread.name = receivedData.thread.name;
            threadListChanged = true;
            changed = true;
          }
          if(changed) {
            await tx.table("threads").put(thread);
          }
        });

        if(threadListChanged) {
          await renderThreadList();
        }


        // CHARACTER updates:
        let characterKeysChanged = Object.keys(receivedData.character);
        for(let key in characterPropertiesVisibleToCustomCode) {
          let k = characterPropertiesVisibleToCustomCode[key]; // since "public api" naming is different to db naming
          if(characterKeysChanged.includes(k)) {
            if(key === "customCode" && threadCharacter.customCode !== receivedData.character.customCode) {
              // custom code has changed, so we need to reload the iframe
              await createNewCustomCodeIframeForThread(threadId);
            }
            threadCharacter[key] = receivedData.character[k];
          }
        }
        await db.characters.put(threadCharacter);

      }


      $.sendButton.addEventListener("click", sendButtonClickHandler);

      async function doBotReplyInPlaceOfUser({characterToReplyWith, replyInstruction=null, signals=null, expectsReply=undefined, result={}}={}) {
        let threadCharacter = await db.characters.get(activeCharacterId);
        let threadId = activeThreadId;

        let messageObj = createMessageObj({threadId, message:"...", characterId:-1, instruction:replyInstruction});
        messageObj.name = characterToReplyWith.name;
        messageObj.avatar = structuredClone(characterToReplyWith.avatar);
        
        let messageEl = await addMessageToFeed(messageObj, {character:characterToReplyWith, skipReaderRendering:true});
        messageEl.querySelector(".messageText").innerHTML = createPaddedTypingIndicatorHtml();
        
        if(!signals) signals = {stop:false, wasDeleted:false};
        messageEl.querySelector(".info .deleteButton").addEventListener("click", async e => {
          e.preventDefault(); e.stopPropagation();
          signals.stop = true;
          signals.wasDeleted = true;
          messageEl.remove();
        });

        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);

        $.statusNotifier.innerHTML = "<button style='font-size: 0.9rem; margin-top:1.5rem;'>🛑 stop response</button>";
        $.statusNotifier.querySelector("button").addEventListener("click", async (e) => {
          e.preventDefault(); e.stopPropagation();
          signals.stop = true;
          if(!characterToReplyWith.streamingResponse || (characterToReplyWith.streamingResponse && streamingChunkCount === 0)) {
            messageEl.remove();
            signals.wasDeleted = true;
          }
          $.statusNotifier.innerHTML = "";
          hideEl($.statusNotifier);
        });
        showEl($.statusNotifier);

        let streamingChunkCount = 0;
        function onStreamingReplyChunk(c) {
          handleStreamingReplyChunk(c, messageEl);
          streamingChunkCount++;
        }
        
        const onProgressMessage = (e) => messageEl.querySelector(".statusMessage").innerHTML=e.message;
        let {message, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed} = await getBotReply({messages, replyingCharacter:characterToReplyWith, replyInstruction, threadId, onProgressMessage, onStreamingReplyChunk, signals}).catch(e => {
          if(e.name !== "AbortError") {
            alert("There was an error during doBotReplyInPlaceOfUser:\n\n"+e.stack);
          }
          messageEl.remove();
          return {};
        });
        messageEl.querySelector(".statusMessage").innerHTML = "";

        hideEl($.statusNotifier);
        $.statusNotifier.innerHTML = "";

        if(signals.wasDeleted || message === undefined) {
          return;
        }

        messageObj.memoryIdBatchesUsed = memoryIdBatchesUsed;
        messageObj.loreIdsUsed = loreIdsUsed;
        messageObj.summaryHashUsed = summaryHashUsed;
        messageObj.memoryQueriesUsed = memoryQueriesUsed;
        messageObj.messageIdsUsed = messageIdsUsed;

        messageObj.expectsReply = expectsReply;

        // if `message` is falsy, it means the bot failed to reply, so delete the message
        if(typeof message !== "string") {
          messageEl.remove();
          return false;
        } else {
          messageObj.message = message;
          result.message = message;

          messageObj.id = await addMessageToDb(messageObj);

          let shouldScrollDown = messageFeedIsNearBottom();
          await addMessageToFeed(messageObj, {character:characterToReplyWith, inPlaceOf:messageEl});
          if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

          await triggerMessageActionCustomCodeEvent({threadId, eventData:{}, eventName:"MessageAdded"});
        }
        return true;
      }

      $.threadOptionsButton.addEventListener("click", async function() {
        showEl($.threadOptionsPopup);
      });

      // if user clicks anywhere other than $.threadOptionsPopup, hide it:
      window.addEventListener("click", function(e) {
        if(!$.threadOptionsPopup.contains(e.target) && !$.threadOptionsButton.contains(e.target)) {
          hideEl($.threadOptionsPopup);
        }
      });

      $.addShortcutButton.addEventListener("click", async function() {
        let shortcut = await prompt2({
          intro: {html: `<div style="font-size: 0.85rem;margin-bottom: 0.5rem;">Shortcuts are buttons that appear above the text box which can be used to easily/quickly send a commonly-used message.</div>`, type:"none"},
          name: {label: "Shortcut name:", type: "textLine", placeholder:"user reply"},
          message: {label: "Message text:", type: "text", height:"fit-content", minHeight:"2rem", placeholder:"/user write an intersting first-person reply"},
          insertionType: {label: "Insertion type:", type: "select", options:[{content:"Replace existing text", value:"replace"}, {content: "Add to 𝗲𝗻𝗱 of existing text", value:"append"}, {content: "Add to 𝘀𝘁𝗮𝗿𝘁 of existing text", value:"prepend"}]},
          autoSend: {label: "Auto-send?", type: "select", options:[{content:"Yes, send on click", value:"yes"}, {content: "No, just put it in the text box", value:"no"}]},
        });
        if(!shortcut) return;
        shortcut.autoSend = (shortcut.autoSend === "yes");
        shortcut.type = "message";
        let thread = await db.threads.get(activeThreadId);
        thread.shortcutButtons.push(shortcut);
        await db.threads.update(thread.id, {shortcutButtons: thread.shortcutButtons});
        await renderShortcutButtons(thread);
      });

      // $.replyLoopButton.addEventListener("click", async function() {
        
      // });

      // let alreadyAutoReplying = false;
      // $.replyWithButton.addEventListener("click", async function() {
      //   if(alreadyAutoReplying) {
      //     return;
      //   }
      //   alreadyAutoReplying = true;
      //   $.sendButton.disabled = true;
      //   $.replyWithButton.disabled = true;

      //   let threadId = activeThreadId;

      //   let availableVoiceNames = speechSynthesis.getVoices().map(v => v.name).sort((a,b) => a.toLowerCase().includes("english") ? -1 : 1);

      //   // get list of characters, sorting by lastMessageTime
      //   const characters = await db.characters.orderBy("lastMessageTime").reverse().toArray();
      //   const promptResult = await prompt2({
      //     characterId: {label: "Choose a character to reply with:", type: "select", options:characters.map(c => ({content:`${c.name} #${c.id}`, value:c.id}))},
      //     repeat: {label: "How many replies?", type: "textLine", defaultValue: "10"},
      //     textToSpeechVoicesEnabled: {label: "Text-to-Speech Voices?", type: "select", options: [{content: "Disabled", value: "disabled"}, {content: "Enabled", value: "enabled"}]},
      //     threadCharVoiceName: {show:d=>d.textToSpeechVoicesEnabled==="enabled", label: "Existing chatacter voice:", type: "select", options:availableVoiceNames.map(v => ({content: v, value: v})) },
      //     otherCharVoiceName: {show:d=>d.textToSpeechVoicesEnabled==="enabled", label: "Reply-with character voice:", type: "select", options:availableVoiceNames.map(v => ({content: v, value: v})) },
      //   });
      //   if(!promptResult) {
      //     alreadyAutoReplying = false;
      //     $.replyWithButton.disabled = false;
      //     $.sendButton.disabled = false;
      //     return;
      //   }
      
      //   let ttsEnabled = promptResult.textToSpeechVoicesEnabled === "enabled";
      //   let threadCharVoiceName = promptResult.threadCharVoiceName;
      //   let otherCharVoiceName = promptResult.otherCharVoiceName;

      //   let characterToReplyWith = await db.characters.get(parseInt(promptResult.characterId));
      //   let repeat = parseInt(promptResult.repeat);
      //   let i = 0;
      //   let signals, result;
      //   while(i < repeat) {
      //     signals = {stop:false, wasDeleted:false};
      //     result = {};
      //     let success = await doBotReplyInPlaceOfUser({characterToReplyWith, signals, result});
      //     if(!success) break;

      //     if(signals.stop) {
      //       break;
      //     }

      //     if(threadId !== activeThreadId) {
      //       break; // if the user clicked into a different thread, stop replying
      //     }

      //     if(ttsEnabled) {
      //       // chrome has a bug that occurs if you try to speak text that's too long
      //       // so we split message up into sentences and speak each one
      //       let sentences = result.message.match(/[^\.!\?]+[\.!\?]+/g)?.map(s => s.trim()) ?? [result.message];
      //       for(let sentence of sentences) {
      //         let result = await textToSpeech({text: sentence, voiceName: otherCharVoiceName}).catch(e => {
      //           console.error(e);
      //           alert("There was an error with speech synthesis. You may need to close this tab and re-open it (not just refresh) if you're using Chrome due to a weird bug that sometimes causes this.\n\n"+e.toString());
      //           return false;
      //         });
      //         if(result === false) break;
      //       }
      //     }

      //     await delay(100);

      //     signals = {stop:false, wasDeleted:false};
      //     result = {};
      //     await doBotReplyIfNeeded({signals, result});

      //     if(signals.stop) {
      //       break;
      //     }

      //     if(ttsEnabled) {
      //       let sentences = result.message.match(/[^\.!\?]+[\.!\?]+/g)?.map(s => s.trim()) ?? [result.message];
      //       for(let sentence of sentences) {
      //         let result = await textToSpeech({text: sentence, voiceName: threadCharVoiceName}).catch(e => {
      //           console.error(e);
      //           alert("There was an error with speech synthesis. You may need to close this tab and re-open it (not just refresh) if you're using Chrome due to a weird bug that sometimes causes this.\n\n"+e.toString());
      //           return false;
      //         });
      //         if(result === false) break;
      //       }
      //     }

      //     // // wait for the other bot to respond
      //     // while(1) {
      //     //   await delay(100);
      //     //   let messages = await db.messages.where("threadId").equals(threadId).toArray();
      //     //   messages.sort((a,b) => a.order - b.order);
      //     //   // get characterId of this thread
      //     //   let thread = await db.threads.get(threadId);
      //     //   let thisThreadCharacterId = thread.characterId;
      //     //   let lastMessage = messages[messages.length-1];
      //     //   if(lastMessage.characterId === thisThreadCharacterId) {
      //     //     if(ttsEnabled) {
      //     //       let sentences = lastMessage.message.match(/[^\.!\?]+[\.!\?]+/g);
      //     //       for(let sentence of sentences) {
      //     //         let result = await textToSpeech({text: sentence, voiceName: threadCharVoiceName}).catch(e => {
      //     //           console.error(e);
      //     //           alert("There was an error with speech synthesis. You may need to close this tab and re-open it (not just refresh) if you're using Chrome due to a weird bug that sometimes causes this.\n\n"+e.toString());
      //     //           return false;
      //     //         });
      //     //         if(result === false) break;
      //     //       }
      //     //     }
      //     //     break;
      //     //   }
      //     // }

      //     i++;
      //   }
      //   alreadyAutoReplying = false;
      //   $.replyWithButton.disabled = false;
      //   $.sendButton.disabled = false;
      // });

      $.newThreadButton.addEventListener("click", async function() {
        document.querySelectorAll("#middleColumn > .middleColumnScreen").forEach(el => hideEl(el));
        showEl($.characterSelection);
        
        activeThreadId = null;
        if(threadLoadingModal) {
          threadLoadingModal.delete();
        }

        await updateCustomCodeIframeVisibility();
        // deselect selected thread
        document.querySelectorAll("#chatThreads .thread").forEach(el => el.classList.remove("selected"));
        await renderCharacterList();
        
        if(isMobile) {
          closeLeftColumn();
        } else {
          hideEl($.characterSelectionOpenLeftColumnButton);
        }
      });


      $.threadSearchButton.addEventListener("click", async function() {
        let query = $.threadSearchInput.value.trim();
        if(query) {
          await renderThreadList({filterWithQuery: query});
        } else {
          // show all threads
          await renderThreadList();
        }
      });
      $.threadSearchInput.addEventListener("keydown", async e => {
        if(e.key === "Enter") {
          $.threadSearchButton.click();
        }
      });
      // if user deletes all text from the search input, show all threads
      $.threadSearchInput.addEventListener("input", async e => {
        if(!$.threadSearchInput.value.trim()) {
          await renderThreadList();
        }
      });

      function resizeMessageInputTextAreaToFitContent() {
        $.messageInput.style.height = "";
        let height = Math.min(window.innerHeight*0.75, $.messageInput.scrollHeight);
        $.messageInput.style.height = height + "px";
      }

      // this executes on page load, so it should give us the full height.
      // note that if the user zooms on the page, it will change, so it's not full-proof for detecting e.g. on-screen keyboard, as we do below
      window.fullVisualViewportHeight = window.visualViewport.height;

      function isTouchDevice() {
        return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
      }

      $.messageInput.addEventListener("keydown", async e => {
        if(isMobile) return; // on mobile, if enter/returns triggers send, then people can't add linebreaks
        if(isTouchDevice() && window.visualViewport.height < window.fullVisualViewportHeight*0.9) return; // likely indicates that onscreen keyboard is open, so we want to allow them to create a new line with 'enter' (shift+enter on a touch-screen keyboard is not ergonomic/possible)

        if(e.key === "Enter") {
          if(e.shiftKey) {
            // if shift is held, wait a moment (so the text area can have the new line added), then increase the height of the text area to match the full height of the content
            await delay(10);
            resizeMessageInputTextAreaToFitContent();
          } else {
            e.preventDefault();
            $.sendButton.click();
          }
        }
      });
      // if user pastes text into the message input, increase the height of the text area to match the full height of the content
      $.messageInput.addEventListener("paste", async e => {
        await delay(10);
        resizeMessageInputTextAreaToFitContent();
      });

      $.messageInput.addEventListener("input", async e => {
        if($.messageInput.value.length % 10 === 0) {
          await delay(10);
          resizeMessageInputTextAreaToFitContent();
        }
      });

      $.clearDataButton.addEventListener("click", async function() {
        if(!confirm("🚨 Are you sure you want to DELETE ALL DATA? This cannot be undone. 🚨")) {
          return;
        }
        await delay(1000);
        if(!confirm("🚨 Click OK again to confirm FULL DELETION of all your data. 🚨")) {
          return;
        }
        await db.delete();
        window.location.reload();
      });

      // User messages sent history:
      {
        let lastTapTime = 0;
        let lastClickTime = 0;

        $.messageInput.addEventListener('touchstart', handleDoubleTap);
        $.messageInput.addEventListener('click', handleDoubleClick);

        function handleDoubleTap(e) {
          let currentTime = new Date().getTime();
          let tapInterval = currentTime - lastTapTime;
          
          if (tapInterval < 300 && tapInterval > 0) {
            onDoubleTapOrClick();
          }
          lastTapTime = currentTime;
        }

        function handleDoubleClick(e) {
          e.preventDefault();
          let currentTime = new Date().getTime();
          let clickInterval = currentTime - lastClickTime;
          
          if (clickInterval < 300 && clickInterval > 0) {
            onDoubleTapOrClick();
          }
          lastClickTime = currentTime;
        }

        async function onDoubleTapOrClick() {
          console.log('Double-tap/double-click on message input textarea detected');
          let threadId = activeThreadId;
          let thread = await db.threads.get(threadId);
          if(thread.userMessagesSentHistory.length === 0) return;
          // sort so isPinned items are at the end:
          thread.userMessagesSentHistory.sort((a, b) => {
            if(a.isPinned && !b.isPinned) return 1;
            if(!a.isPinned && b.isPinned) return -1;
            return 0;
          });
          // create the history messages element:
          let ctn = document.createElement("div");
          ctn.innerHTML = thread.userMessagesSentHistory.map(m => `<div class="historyItem" data-is-pinned="${m.isPinned}" data-message-text="${encodeURIComponent(m.text)}"><span class="pinButton">📌</span><span class="text">${m.text.slice(0, 500).replaceAll("\n", " ")}</span><span class="deleteButton">🗑️</span></div>`).join("");
          // position it above the message input text area, with same width:
          ctn.style.cssText = `
            max-height: min(40vh, 200px);
            overflow: auto;
            background: var(--textarea-bg);
            border: 1px solid var(--button-border-color);
            border-radius: var(--border-radius);
            padding: 5px;
            position: absolute;
            bottom: 0;
            width: 100%;
          `;

          // if user clicks the pin button, toggle the fav status of the message and save the userMessagesSentHistory
          ctn.querySelectorAll(".historyItem .pinButton").forEach(el => {
            el.addEventListener("click", async function(e) {
              e.stopPropagation();
              let messageText = decodeURIComponent(el.parentElement.dataset.messageText);
              let message = thread.userMessagesSentHistory.find(m => m.text === messageText);
              message.isPinned = !message.isPinned;
              await db.threads.update(threadId, {userMessagesSentHistory:thread.userMessagesSentHistory});
              el.closest(".historyItem").dataset.isPinned = message.isPinned;
            });
          });

          ctn.querySelectorAll(".historyItem .deleteButton").forEach(el => {
            el.addEventListener("click", async function(e) {
              e.stopPropagation();
              let messageText = decodeURIComponent(el.parentElement.dataset.messageText);
              let message = thread.userMessagesSentHistory.find(m => m.text === messageText);
              thread.userMessagesSentHistory.splice(thread.userMessagesSentHistory.indexOf(message), 1);
              await db.threads.update(threadId, {userMessagesSentHistory:thread.userMessagesSentHistory});
              el.closest(".historyItem").remove();
            });
          });

          // add it to the DOM:
          $.userMessagesSentHistoryCtn.appendChild(ctn);
          // when the user clicks anywhere else, remove it from the DOM:
          function clickAnywhereElseHandler(e) {
            if(e.target === ctn || ctn.contains(e.target)) return;
            window.removeEventListener("click", clickAnywhereElseHandler);
            ctn.remove();
          }
          window.addEventListener("click", clickAnywhereElseHandler);
          // when user clicks a message, add it to the message input text area:
          ctn.querySelectorAll(".historyItem").forEach(el => {
            el.addEventListener("click", function() {
              $.messageInput.value = decodeURIComponent(el.dataset.messageText);
              $.messageInput.focus();
              window.removeEventListener("click", clickAnywhereElseHandler);
              ctn.remove();
            });
          });

          // scroll to bottom of ctn:
          ctn.scrollTop = ctn.scrollHeight;
        }
      }


      // $.statsButton.addEventListener("click", async function() {
      //   let entries = await db.usageStats.toArray();
      //   let dayToSpendMap = {};
      //   for(let entry of entries) {
      //     entry.daysSinceEpoch = Math.floor(entry.dateHour / (1000 * 60 * 60 * 24));
      //   }
      //   let spent = usageStatsEntriesToCost(entries);

      //   await prompt2({
      //     chart: {html: "", type: "none"}
      //   });

      //   let Chart = await import('https://cdn.jsdelivr.net/npm/chart.js@4.2.1/+esm').then(m => m.default);
      //   const chart = new Chart(ctx, {
      //     type: 'line',
      //     data: {
      //       datasets: [{
      //         data: entries.map(),
      //       }],
      //     },
      //     options: {
      //       scales: {
      //         x: {
      //           type: 'time',
      //           time: {
      //             unit: 'day'
      //           }
      //         }
      //       }
      //     }
      //   });
      // });


      $.settingsButton.addEventListener("click", async function() {
        // use prompt2 to collect user's name and avatar, using defaults from db.misc
        let userNameOriginal = (await db.misc.get("userName"))?.value || defaultUserName;
        let userAvatarUrlOriginal = (await db.misc.get("userAvatarUrl"))?.value || "";
        let openAiApiKeyOriginal = (await db.misc.get("openAiApiKey"))?.value || "";
        let customModelConfigsOriginal = (await db.misc.get("customModelConfigs"))?.value || [];
        let showInlineReminderOriginal = (await db.misc.get("showInlineReminder"))?.value || "yes";
        let customPostPageLoadMainThreadCodeOriginal = (await db.misc.get("customPostPageLoadMainThreadCode"))?.value || "";
        const result = await prompt2({
          userName: {label: "Your name:", type: "textLine", defaultValue: userNameOriginal},
          userAvatarUrl: {label: "Your avatar URL:", type: "textLine", placeholder: "(optional)", defaultValue: userAvatarUrlOriginal},
          openAiApiKey: {label: "OpenAI API secret key (<a href='https://platform.openai.com/account/api-keys' target='_blank'>from here</a>):", type: "textLine", placeholder:"sk-...", defaultValue: openAiApiKeyOriginal},
          showInlineReminder: {hidden:true, label: "Show 'inline' reminder edit button:", type: "select", options:[{value:"yes"}, {value:"no"}], defaultValue: showInlineReminderOriginal},
          customModelConfigs: {hidden:true, cssText:"white-space:pre; font-family:monospace;", label: "Custom model configs (<a href='https://github.com/josephrocca/OpenCharacters/blob/main/docs/custom-models.md' target='_blank'>follow this guide</a>):", type: "text", placeholder:`{name:"...", endpointUrl:"..."}\n{name:"...", endpointUrl:"...", apiKey:"..."}\n...`, defaultValue: customModelConfigsOriginal.map(o => JSON5.stringify(o)).join("\n")},
          customPostPageLoadMainThreadCode: {hidden:true, height:"fit-content", cssText:"white-space:pre; font-family:monospace;", label: "This code will be run on this page after page load. You can use it to mod the OpenCharacters UI, or to e.g. <a href='https://gist.github.com/josephrocca/a82216e2f2fdf54ad8dd79dbd4cfd625' target='_blank'>proxy all `fetch` requests</a>, or whatever. Note that there are no backwards-compatibility guarantees on the main thread UI, so your code may break eventually. <b>This code can access all your data</b> - make sure it's from a trustworthy source if you didn't write it yourself (maybe ask GPT-4 what it does if you don't know how to code and are weary). Refresh the page after saving for your code to take effect.", placeholder:"// add code here", type: "text", defaultValue: customPostPageLoadMainThreadCodeOriginal},
        }, {showHiddenInputsText: "show advanced settings"});
        if(!result) return;
        let { userName, userAvatarUrl, openAiApiKey, customModelConfigs, customPostPageLoadMainThreadCode } = result;

        customModelConfigs = customModelConfigs.split("\n").map(s => s.trim()).filter(s => s).map(s => JSON5.parse(s));
        for(let config of customModelConfigs) {
          config.endpointUrl = config.endpointUrl.trim();
          config.name = config.name.trim();
          if(!config.modelUrl) {
            config.modelUrl = `https://huggingface.co/${config.name}`;
          }
          config.modelUrl = config.modelUrl.trim().replace(/\/$/, ""); // remove trailing slash
          if(!config.name || !config.endpointUrl) {
            alert("Invalid custom model config. Must include at least name and endpointUrl:\n\n" + JSON5.stringify(config));
          }
          if(!config.type) {
            if(/v1\/completions\/?/.test(config.endpointUrl)) {
              config.type = "completion";
            } else if(/v1\/chat\/completions\/?/.test(config.endpointUrl)) {
              config.type = "chat-completion";
            } else {
              alert("Warning: If endpointUrl doesn't end with v1/completions or v1/chat/completions, then you need to specify a 'type' parameter that is either 'completion' or 'chat-completion'. You should choose 'chat-completion' if the model accepts the 'messages' parameter, or choose 'completion' if it accepts the 'prompt' parameter. The model has been assumed to be a 'completion' model. Here's the config line causing this warning:\n\n" + JSON5.stringify(config));
              config.type = "completion";
            }
          }
          if(!config.maxSequenceLength) {
            let modelConfigJson;
            modelConfigJson = await fetch(config.modelUrl+"/raw/main/config.json").then(r => r.json()).catch(e => null);
            if(modelConfigJson) {
              config.maxSequenceLength = modelConfigJson.ctx_len || modelConfigJson.max_position_embeddings || modelConfigJson.n_positions || modelConfigJson.max_position_embeddings || modelConfigJson.max_sequence_length;
            }
            if(!config.maxSequenceLength) {
              alert("Warning: maxSequenceLength was not provided, and could not be loaded from Hugging Face. It has been assumed to be 4096. Here's the config line causing this warning:" + JSON5.stringify(config));
              config.maxSequenceLength = 4096;
            }
          }
          if(!config.tokenPricing) {
            config.tokenPricing = {prompt:0, completion:0};
          }
          if(!config.apiKey && config.endpointUrl.startsWith("https://api.openai.com")) {
            config.apiKey = "<OPENAI>";
          }
        }

        let showInlineReminder = result.showInlineReminder;

        // save to db
        await db.misc.put({key: "userName", value: userName});
        await db.misc.put({key: "userAvatarUrl", value: userAvatarUrl});
        await db.misc.put({key: "openAiApiKey", value: openAiApiKey});
        await db.misc.put({key: "customModelConfigs", value: customModelConfigs});
        await db.misc.put({key: "showInlineReminder", value: showInlineReminder});
        await db.misc.put({key: "customPostPageLoadMainThreadCode", value: customPostPageLoadMainThreadCode});
        
        await updateModelList();

        // update the user's name and avatar in the message feed:
        if($.messageFeed.offsetHeight > 0) {
          let threadId = activeThreadId;
          await renderMessageFeed(threadId);
        }
      });

      async function getCharacterHash(characterObj) {
        let char = structuredClone(characterObj);
        delete char.id;
        delete char.creationTime;
        delete char.lastMessageTime;
        delete char.uuid;
        delete char.folderPath;
        for(let key in char) {
          if(key.startsWith("$")) { // special `dexie-export-import` properties start with `$` (only exists in exported json data)
            delete char[key];
          }
        } 
        let entries = Object.entries(char);
        entries.sort((a,b) => a[0].localeCompare(b[0]));
        let hash = await sha256Text(JSON.stringify(entries));
        return hash;
      }

      // import data if they click import button
      $.importDataFileInput.addEventListener("change", async function() {

        let options = await prompt2({
          keepExistingData: {label: "Keep existing data?", type: "select", options:[{value:"yes", content:"Yes, keep."}, {value:"no", content:"No, DELETE existing data."}], defaultValue: "yes"},
        }, {submitButtonText:"import data"});

        if(!options) {
          $.importDataFileInput.value = "";
          return;
        }

        // warn about overwrite:
        if(options.keepExistingData === "no" && !confirm("Are you sure you want to DELETE all of your existing data? You should create an export of your data first! This cannot be undone.")) {
          $.importDataFileInput.value = "";
          return;
        }

        let file = $.importDataFileInput.files[0];

        $.importDataFileInput.value = "";

        let loadingModal = createLoadingModal(`Importing data...<br><span style="font-size:80%; opacity:0.6;">This could take a while if the file is large.</span>`);
        await delay(50); // give the loading modal a chance to render

        let success = false;
        try {
          if(await tryImportingDexieFile(file, options).catch(e => "fail") === "finished") {
            success = true;
          } else if(await tryImportingTavernAIThreadFile(file, options).catch(e => "fail") === "finished") {
            success = true;
          } else if(await tryImportingExternalCharacterFileFormat(file, options).catch(e => "fail") === "finished") {
            success = true;
          }
        } catch(e) {}

        loadingModal.delete();

        if(!success) {
          alert("The file that you're importing doesn't seem to be a valid format, or something went wrong during import. If you think your file is valid, please report this as a bug on Github or Discord.");
        }

        await updateModelList();

      });

      async function tryImportingDexieFile(file, options) {
        // backup existing data just in cast this wrecks the db for some reason (used in catch block below):
        const originalDbJsonBlob = await db.export({prettyJson:true, numRowsPerChunk:100});

        let singleThreadImportId = null;

        try {

          try {
            let json = JSON.parse(await new Blob([file]).text());
            if(!json.formatName && json.type === "application/json" && json.uri?.startsWith("file:///")) {
              alert("The file you provided is invalid. It's likely you tried to upload it to Discord, or something like that, and instead of actually uploading the file itself, Discord uploaded a *reference* to the file. I'm not sure why Discord does this, but you might want to try a different method of transferring the file. To check if your file is valid, you can open it up with a text editor and check that it starts with: {\"formatName\":\"dexie\", ...");
              return "finished";
            }
          } catch(e) {
            return "fail";
          }

          if(options.keepExistingData === "no") {
            await db.delete();
            await db.open();
            // db = await Dexie.import(file); // this wasn't doing a version upgrade, and I'm not sure how to trigger it, so I'm just using the code below which was written for partial imports (but also works for full imports), and does the version upgrade manually
          }

          let json = await new Response(new Blob([file])).json(); // a hack to go straight from blob to json to avoid maximum string length errors
          // let json = JSON.parse(await new Blob([file]).text());

          if(!json.data || !json.data.data) return "fail";

          // TODO: I should probably convert IDs to UUIDs so I don't need to do this sort of thing, but this is fine for now. Note: If you do this, you need to update the export modal because it currently uses comma-separated IDs
          
          // we need to re-number all ids in the imported data to be higher than the current max ids.

          // get current maximum id for each table
          let maxThreadId = (await db.threads.orderBy("id").last())?.id ?? -1;
          let maxMessageId = (await db.messages.orderBy("id").last())?.id ?? -1;
          let maxCharacterId = (await db.characters.orderBy("id").last())?.id ?? -1;
          let maxMemoryId = (await db.memories.orderBy("id").last())?.id ?? -1;
          let maxLoreId = (await db.lore.orderBy("id").last())?.id ?? -1;
          let maxLoreBookId = (await db.lore.orderBy("bookId").last())?.bookId ?? -1;
          // note: summaries don't have an id (we index by hash), so we don't need to re-number their ids (but note that we do need to renumber their thread ids to match the new thread ids)

          let importedCharacters = json.data.data.find(d => d.tableName === "characters").rows;
          let importedThreads = json.data.data.find(d => d.tableName === "threads").rows;
          let importedMessages = json.data.data.find(d => d.tableName === "messages").rows;
          let importedSummaries = json.data.data.find(d => d.tableName === "summaries")?.rows;
          let importedUsageStats = json.data.data.find(d => d.tableName === "usageStats")?.rows;
          let importedMemories = json.data.data.find(d => d.tableName === "memories")?.rows;
          let importedLore = json.data.data.find(d => d.tableName === "lore")?.rows;
          let importedTextCompressionCacheEntries = json.data.data.find(d => d.tableName === "textCompressionCache")?.rows;
          
          const existingCharacters = await db.characters.toArray();

          // hash existing characters, and new characters, so we can map ids of new characters to ones that may already exist
          let existingCharacterHashToId = {};
          let newCharacterIdToHash = {};
          for(let character of existingCharacters) {
            let hash = await getCharacterHash(character);
            existingCharacterHashToId[hash] = character.id;
          }
          for(let character of importedCharacters) {
            let hash = await getCharacterHash(character);
            newCharacterIdToHash[character.id] = hash;
          }

          // old id -> new id maps
          let characterIdMap = {};
          let threadIdMap = {};
          let messageIdMap = {};
          let summaryIdMap = {};
          let memoryIdMap = {};
          let loreIdMap = {};
          let loreBookIdMap = {};

          let charactersThatWeAlreadyHave = [];

          // re-number character ids
          for(let character of importedCharacters) {
            let existingCharacterId = existingCharacterHashToId[newCharacterIdToHash[character.id]];
            if(existingCharacterId !== undefined) {
              characterIdMap[character.id] = existingCharacterId;
              charactersThatWeAlreadyHave.push(character);
              continue;
            }
            // no existing character with this hash, so we need to create a new entry:
            maxCharacterId++;
            characterIdMap[character.id] = maxCharacterId;
            character.id = maxCharacterId;
          }

          // remove all the `charactersThatWeAlreadyHave` characters from the `importedCharacters`, since we don't need to import them:
          importedCharacters = importedCharacters.filter(c => !charactersThatWeAlreadyHave.includes(c));

          // re-number thread ids
          for(let thread of importedThreads) {
            maxThreadId++;
            threadIdMap[thread.id] = maxThreadId;
            thread.id = maxThreadId;
            // re-number character id of each thread
            thread.characterId = characterIdMap[thread.characterId];
          }

          if(importedLore) {
            // re-number lore ids
            for(let entry of importedLore) {
              maxLoreId++;
              loreIdMap[entry.id] = maxLoreId;
              entry.id = maxLoreId;
            }
            for(let message of importedMessages) {
              message.loreIdsUsed = message.loreIdsUsed.map(id => loreIdMap[id]);
            }

            // re-number lore bookIds
            for(let thread of importedThreads) {
              if(loreBookIdMap[thread.loreBookId] === undefined) {
                maxLoreBookId++;
                loreBookIdMap[thread.loreBookId] = maxLoreBookId;
              }
              thread.loreBookId = loreBookIdMap[thread.loreBookId];
            }
            for(let entry of importedLore) {
              if(typeof entry.bookId == "number") { // <-- bookId is null for bookUrl-based entries
                entry.bookId = loreBookIdMap[entry.bookId];
              }
            }
          }

          let importedThreadIdToCharacterId = {};
          for(let thread of importedThreads) {
            importedThreadIdToCharacterId[thread.id] = thread.characterId;
          }

          // re-number message ids
          for(let message of importedMessages) {
            maxMessageId++;
            messageIdMap[message.id] = maxMessageId;
            message.id = maxMessageId;
            // re-number thread id of each message
            message.threadId = threadIdMap[message.threadId];
            // re-number author/character id of each message
            if(message.characterId >= 0) { // remember, user messages have characterId = -1, and system messages have characterId = -2
              message.characterId = characterIdMap[message.characterId];
              if(message.characterId === undefined) { // this is possible due to an old bug in safelyDeleteCharacterById where I wasn't updating the characterId of messages in threads where the deleted character was included in a thread via `/ai @CharName#123` rather than actually being the main character of the thread.
                message.characterId = importedThreadIdToCharacterId[message.threadId]; // just set the ID to the characterId of the thread's main character
              }
            }
          }

          // re-number memory ids
          if(importedMemories) {
            for(let memory of importedMemories) {
              maxMemoryId++;
              memoryIdMap[memory.id] = maxMemoryId;
              memory.id = maxMemoryId;
            }
          }

          // re-number message.memoryIdBatchesUsed
          for(let message of importedMessages) {
            if(message.memoryIdBatchesUsed) { // <-- old exports won't have this
              message.memoryIdBatchesUsed = message.memoryIdBatchesUsed.map(b => b.map(id => memoryIdMap[id]));
            }
          }
          // (note: we don't need to do the same as above for summaryHashUsed since it obviously uses a hash instead of an id)

          // re-number message.messageIdsUsed
          for(let message of importedMessages) {
            if(message.messageIdsUsed) { // <-- old exports won't have this
              message.messageIdsUsed = message.messageIdsUsed.map(id => id === -1 ? -1 : messageIdMap[id]);
            }
          }

          if(importedSummaries) {
            // delete summaries that don't have messageIds (from an old version of the app)
            importedSummaries = importedSummaries.filter(s => s.messageIds !== undefined);

            // convert old summary thread/message ids to new ones
            for(let summary of importedSummaries) {
              summary.threadId = threadIdMap[summary.threadId];
              summary.messageIds = summary.messageIds.map(id => messageIdMap[id]);
            }

            // get existing summary hashes from db
            let existingSummaryHashes = new Set((await db.summaries.toArray()).map(s => s.hash));
            // remove summaries we already have
            importedSummaries = importedSummaries.filter(s => !existingSummaryHashes.has(s.hash));
          }

          if(importedUsageStats) {
            // convert old usageStats thread and character ids to new ones
            for(let entry of importedUsageStats) {
              entry.threadId = threadIdMap[entry.threadId];
              entry.characterId = characterIdMap[entry.characterId];
            }
          }

          if(importedMemories) {
            for(let memory of importedMemories) {
              memory.threadId = threadIdMap[memory.threadId];
              memory.characterId = characterIdMap[memory.characterId];
            }
          }

          if(importedTextCompressionCacheEntries) {
            
            let existingEntries = await db.textCompressionCache.toArray();
            let alreadyGotEntryKeys = new Set(existingEntries.map(entry => entry.uncompressedTextHash + "-<<-|->>-" + entry.modelName + "-<<-|->>-" + entry.tokenLimit));

            for(let entry of importedTextCompressionCacheEntries) {
              entry.threadId = threadIdMap[entry.threadId];
              let uniqueKey = entry.uncompressedTextHash + "-<<-|->>-" + entry.modelName + "-<<-|->>-" + entry.tokenLimit;
              if(alreadyGotEntryKeys.has(uniqueKey)) {
                entry.__shouldRemove = true;
              } else {
                alreadyGotEntryKeys.add(uniqueKey);
              }
            }
            importedTextCompressionCacheEntries = importedTextCompressionCacheEntries.filter(entry => !entry.__shouldRemove);
          }

          // if there's just one thread, then we assume it was from a single-thread export
          // and in that case we probably don't want isFav to persist, and we also probably
          // want that thread to be at the top - i.e. lastMessageTime = now
          if(importedThreads.length === 1) {
            importedThreads[0].isFav = false;
            importedThreads[0].lastViewTime = Date.now();
            importedThreads[0].lastMessageTime = Date.now();
            singleThreadImportId = importedThreads[0].id;
          }


          // UPGRADES:
          // TODO: shouldn't dexie's .upgrade function handle this? doesn't seem to be doing it. check again - I could be wrong.
          for(let character of importedCharacters) {
            upgradeCharacterFromOldVersion(character);
          }
          let allCharacters = [...existingCharacters, ...importedCharacters];
          for(let thread of importedThreads) {
            await upgradeThreadFromOldVersion(thread, {characters:allCharacters});
          }
          for(let message of importedMessages) {
            upgradeMessageFromOldVersion(message);
          }
          if(importedUsageStats) {
            importedUsageStats = importedUsageStats.filter(entry => entry.threadId !== undefined);
          }
          if(importedSummaries) {
            importedSummaries = importedSummaries.filter(entry => entry.messageIds !== undefined);
          }
          let loreEntriesToAddAfterImport = [];
          if(importedMemories) {
            let userWrittenMemories = importedMemories.filter(m => m.type === "user-written");
            if(userWrittenMemories.length > 0) {
              for(let m of userWrittenMemories) {
                if(importedLore) {
                  maxLoreId++;
                  importedLore.push({ id:maxLoreId, bookId:m.threadId, text:m.text, embedding:m.embedding, triggers:[] });
                } else {
                  loreEntriesToAddAfterImport.push({ bookId:m.threadId, text:m.text, embedding:m.embedding, triggers:[] });
                }
              }
              importedMemories = importedMemories.filter(m => m.type !== "user-written");
            }

            let memoryIdToIndexMap = createMemoryIdToIndexMapForIncorrectlyIndexedOrUnindexedMemories(importedMemories);
            for(let memory of importedMemories) {
              let opts = {};
              if(memoryIdToIndexMap[memory.id] !== undefined) opts.index = memoryIdToIndexMap[memory.id];
              upgradeMemoryFromOldVersion(memory, opts);
            }
          }
          if(importedLore) {
            for(let entry of importedLore) {
              upgradeLoreFromOldVersion(entry);
            }
          }
          for(let entry of loreEntriesToAddAfterImport) {
            upgradeLoreFromOldVersion(entry);
          }

          if(json.data.data.find(d => d.tableName === "textEmbeddingCache")) {
            let existingEntries = await db.textEmbeddingCache.toArray();
            let entries = json.data.data.find(d => d.tableName === "textEmbeddingCache").rows;
            for(let e of entries) {
              delete e.id;
            }
            // remove duplicate embeddings (duplicates were possible in older versions of the app, but are now disallowed)
            let seen = new Set(existingEntries.map(entry => entry.textHash + "-<<-|->>-" + entry.modelName));
            entries = entries.filter(entry => {
              let key = entry.textHash + "-<<-|->>-" + entry.modelName;
              if(seen.has(key)) return false;
              seen.add(key);
              return true;
            });
            json.data.data.find(d => d.tableName === "textEmbeddingCache").rows = entries;
          }
          

          json.data.data.find(d => d.tableName === "characters").rows = importedCharacters;
          json.data.data.find(d => d.tableName === "threads").rows = importedThreads;
          json.data.data.find(d => d.tableName === "messages").rows = importedMessages;
          if(importedSummaries) {
            json.data.data.find(d => d.tableName === "summaries").rows = importedSummaries;
          }
          if(importedUsageStats) {
            json.data.data.find(d => d.tableName === "usageStats").rows = importedUsageStats;
          }
          if(importedMemories) {
            json.data.data.find(d => d.tableName === "memories").rows = importedMemories;
          }
          if(importedLore) {
            json.data.data.find(d => d.tableName === "lore").rows = importedLore;
          }
          if(importedTextCompressionCacheEntries) {
            json.data.data.find(d => d.tableName === "textCompressionCache").rows = importedTextCompressionCacheEntries;
          }

          // delete old apiUsage table/data
          json.data.data = json.data.data.filter(d => d.tableName !== "apiUsage");
          json.data.tables = json.data.tables.filter(d => d.name !== "apiUsage");

          // check which misc keys user already has, and remove them from the misc table that we're importing:
          let existingMiscKeys = (await db.misc.toArray()).map(m => m.key);
          let miscData = json.data.data.find(d => d.tableName === "misc");
          miscData.rows = miscData.rows.filter(m => !existingMiscKeys.includes(m.key));

          // convert json back to blob and import
          // let blob = new Blob([JSON.stringify(json)], {type: "application/json"});
          let blob = jsonToBlob(json);
          
          await db.import(blob, {acceptVersionDiff:true, acceptMissingTables:true});

          if(loreEntriesToAddAfterImport.length > 0) {
            await db.lore.bulkAdd(loreEntriesToAddAfterImport); // we add these after import because there was no 'lore' table in the original JSON
          }

          // instead of importing the whole textEmbeddingCache, we just import the ones that are currently attached to memories/lore, which helpfully cleans out any unused entries in the cache
          {
            let importedMemoriesAndLore = [...(importedLore || []), ...(importedMemories || [])];
            let importedMemoryAndLoreTextHashes = await Promise.all(importedMemoriesAndLore.map(entry => sha256Text(entry.text)));
            let textEmbeddingsToAddToCache = [];
            for(let i = 0; i < importedMemoriesAndLore.length; i++) {
              for(let modelName of Object.keys(importedMemoriesAndLore[i].embeddings)) {
                textEmbeddingsToAddToCache.push({
                  text: importedMemoriesAndLore[i].text,
                  textHash: importedMemoryAndLoreTextHashes[i],
                  modelName: modelName,
                  embedding: importedMemoriesAndLore[i].embeddings[modelName],
                });
              }
            }
            let alreadyGotEmbeddings = await db.textEmbeddingCache.toArray();
            let alreadyGotTextHashModelNamePairs = new Set(alreadyGotEmbeddings.map(e => `${e.textHash}-<<-|->>-${e.modelName}`));
            
            textEmbeddingsToAddToCache = textEmbeddingsToAddToCache.filter(e => {
              let keep = !alreadyGotTextHashModelNamePairs.has(`${e.textHash}-<<-|->>-${e.modelName}`);
              alreadyGotTextHashModelNamePairs.add(`${e.textHash}-<<-|->>-${e.modelName}`);
              return keep;
            });
            await db.textEmbeddingCache.bulkAdd(textEmbeddingsToAddToCache).catch(e => {
              console.error("Something went wrong while adding text embeddings to cache. Not a critical error, but does indicate a bug in above code:", e);
            });
          }


          // TODO: should probably update the lastMessageTime of each charactersThatWeAlreadyHave to be the time of their last message, since this could be wrong now 

        } catch(e) {
          console.error(e);
          let yyyymmdd = new Date().toISOString().split("T")[0];
          downloadTextOrBlob(originalDbJsonBlob, `opencharacters-export-${yyyymmdd}.json`);
          await delay(1000);
          alert(`There was an error importing your data. Your data has been downloaded as a backup. Please share this error message on Github:\n\n${e.message}\n\n${e.stack}`);
          return "fail";
        }
        
        await renderCharacterList(); // <-- in case they're currently on the character screen
        await renderThreadList();
        if(singleThreadImportId !== null) {
          await showThread(singleThreadImportId);
        }
        return "finished";
      }

      async function tryImportingExternalCharacterFileFormat(file, options) {
        let text;
        let json;
        try {
          text = await new Blob([file]).text();
          json = JSON.parse(text);
        } catch(e) {}

        if(!json && file.name.endsWith(".json")) return "fail";

        // wasn't a json file - try parsing as webp/png
        if(!json) {
          try {
            let loadingModal = createLoadingModal("Loading parser...");
            let ExifReader = await import('https://cdn.jsdelivr.net/npm/exifreader@4.12.0/+esm');
            loadingModal.delete();

            let tags = await ExifReader.load(file);
            if(tags.chara) {
              json = JSON5.parse(atob(tags.chara.value));
            } else if(tags.UserComment) {
              json = JSON5.parse(tags.UserComment.value[0]);
            }
            // the image file itself is the avatar image, so:
            if(!json.avatar || json.avatar === "none") {
              // convert `file` to a data URL:
              let reader = new FileReader();
              let dataUrl = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });
              json.avatar = dataUrl;
            }
          } catch(e) {
            return "fail";
          }
        }

        if(!json) return "fail";

        if(options.keepExistingData === "no") {
          if(!confirm("You're importing an external character format, but you've requested that all existing data be deleted. This is not currently supported when importing external formats. Existing data will NOT be deleted.")) {
            return "finished";
          }
        }

        let character = {avatar:{}};

        // tavern/pyg/text-gen:
        if(json.name || json.char_name) {
          let name = json.name ?? json.char_name;
          let personality = json.personality ?? json.char_persona ?? null;
          let description = json.description ?? null;
          let firstAIMessage = json.char_greeting ?? json.first_mes ?? null;
          let exampleDialogue = json.example_dialogue ?? json.mes_example ?? ""
          let scenario = json.scenario ?? json.world_scenario ?? "";
          let avatarUrl = json.avatar === undefined || json.avatar === "none" || json.avatar === "" ? "" : json.avatar;
        

          let exampleDialogueChunks = [];
          if(exampleDialogue) {
            if(exampleDialogue.includes("<START>")) {
              exampleDialogueChunks = exampleDialogue.split("<START>").map(c => c.trim()).filter(c => c);
            } else {
              exampleDialogueChunks = [exampleDialogue];
            }
          }

          let roleInstructionChunks = [];
          if(description) roleInstructionChunks.push(`# Description of {{char}}:\n${description}`);
          if(personality) roleInstructionChunks.push(`# {{char}}'s Personality:\n${personality}`);

          character.name = name;
          character.avatar.url = avatarUrl;
          character.roleInstruction = roleInstructionChunks.join("\n\n");
          character.initialMessages = [];
          if(exampleDialogueChunks.length > 0) character.initialMessages.push({author:"system", content:`### Example Dialogue:\n${exampleDialogueChunks.map(c => `---start example---\n${c}\n---end example---`).join("\n\n")}`, hiddenFrom:["user"]});
          if(scenario) character.initialMessages.push({author:"system", content:"Scenario: "+scenario});
          if(firstAIMessage) character.initialMessages.push({author:"ai", content:firstAIMessage});
        } else if(json.character?.name) {
          character.name = json.character.name;
          let roleInstructionChunks = [];
          if(json.character.title) roleInstructionChunks.push(`# Title:\n${json.character.title}`);
          if(json.character.description) roleInstructionChunks.push(`# Description of ${character.name}:\n${json.character.description}`);
          if(json.character.definition) roleInstructionChunks.push(`# Character Definition:\n${json.character.definition}`);
          character.roleInstruction = roleInstructionChunks.join("\n\n");
          character.initialMessages = [{author:"ai", content:json.character.greeting}];
          character.avatar.url = "https://characterai.io/i/400/static/avatars/"+json.character.avatar_file_name;
        } else {
          return "fail";
        }

        let result = await characterDetailsPrompt(character);
        if(result) {
          const character = await addCharacter(result);
          await createNewThreadWithCharacterId(character.id);
        }
        
        return "finished";
      }

      async function tryImportingTavernAIThreadFile(file, options) {
        let text = await new Blob([file]).text();
        // parse text as jsonl format (lines are json objects):
        let jsonl = text.trim().split("\n").map(line => JSON.parse(line));
        // check if it's jsonl format:
        if(!jsonl.every(obj => typeof obj === "object" && obj !== null)) {
          return "fail";
        }
        // check if it's TavernAI thread format (first line is header/meta):
        let seemsValid = jsonl[0].user_name!==undefined && jsonl[0].character_name!==undefined && jsonl[0].create_date!==undefined && jsonl.slice(1).every(m => m.name!==undefined && m.is_user!==undefined && m.mes!==undefined && m.send_date!==undefined);
        if(!seemsValid) {
          return "fail";
        }

        if(options.keepExistingData === "no") {
          if(!confirm("You're importing a TavernAI thread, but you've requested that all existing data be deleted. This is not supported when importing TavernAI threads. Existing data will NOT be deleted.")) {
            return "finished";
          }
        }

        // if so, ask user which character it corresponds to, and then add it as a thread
        const characters = await db.characters.orderBy("lastMessageTime").reverse().toArray();
        let tavernOptions = await prompt2({
          characterId: {label: "You're importing a TavernAI thread. Choose the character for this thread. If you haven't created/imported it yet, you should click cancel and do that first.", type: "select", options:characters.map(c => ({content:`${c.name} #${c.id}`, value:c.id}))},
        }, {submitButtonText:"submit"});
        if(!tavernOptions) {
          return "finished";
        }
        tavernOptions.characterId = parseInt(tavernOptions.characterId);
        let character = await db.characters.get(tavernOptions.characterId);
        let thread = await addThread({name:defaultThreadName, characterId:character.id});
        for(let m of jsonl.slice(1)) {
          let characterId;
          if(m.is_user) characterId = -1;
          else characterId = character.id;
          let data = {threadId:thread.id, message:m.mes, characterId, creationTime:m.send_date};
          let messageObj = createMessageObj(data);
          await addMessageToDb(messageObj)
        }
        await renderThreadList();
        await showThread(thread.id);
        return "finished";
      }

      // parse url hash as json
      let ignoreHashChange = false;
      async function checkForHashCommand() {
        const urlHash = window.location.hash.slice(1);
        const urlHashJson = urlHash ? JSON.parse(decodeURIComponent(urlHash)) : {};
        if(urlHashJson.addCharacter) {
          $.newThreadButton.click();
          let character = urlHashJson.addCharacter;
          
          // UPGRADES (should be the same as the dexie db.upgrade code):
          upgradeCharacterFromOldVersion(character);

          let uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
          if(character.uuid && !uuidRegex.test(character.uuid)) {
            alert("The character you're trying to load has an invalid UUID. It will be imported without a UUID. Please see correct UUID format here:\n\nhttps://en.wikipedia.org/wiki/Universally_unique_identifier");
            delete character.uuid;
          }

          let editingExistingCharacter = false;
          if(character.uuid && await db.characters.get({uuid:character.uuid})) {
            editingExistingCharacter = true;
          }

          let submitButtonText = "add character";
          if(editingExistingCharacter) {
            submitButtonText = "save edits";
          }

          delete character.folderPath;

          let result = await characterDetailsPrompt(character, {editingExistingCharacter, submitButtonText});
          if(result) {
            if(editingExistingCharacter) {
              await db.characters.where({uuid:character.uuid}).modify(result);
              const editedCharacter = await db.characters.get({uuid:character.uuid});
              await createNewThreadWithCharacterId(editedCharacter.id);
            } else {
              const newCharacter = await addCharacter(result);
              await createNewThreadWithCharacterId(newCharacter.id);
            }
          }
          ignoreHashChange = true;
          window.location.hash = "";
          ignoreHashChange = false;
          return "addCharacter";
        } else {
          return null;
        }
      }
      window.addEventListener('hashchange', (event) => {
        if(!ignoreHashChange) {
          checkForHashCommand();
        }
      });

      await renderThreadList();

      let customPostPageLoadMainThreadCode = (await db.misc.get("customPostPageLoadMainThreadCode"))?.value || "";
      if(customPostPageLoadMainThreadCode.trim()) {
        eval(customPostPageLoadMainThreadCode);
      }

      if(await checkForHashCommand() === null) {
        // if there are no threads, show the character selection screen
        if(!$("#chatThreads .thread")) {
          $.newThreadButton.click();
        } else {
          // otherwise click the most recently-interacted-with thread
          let allThreads = await db.threads.orderBy("lastViewTime").reverse().toArray();
          let thread = allThreads[0];
          if($.chatThreads.dataset.currentFolderPath !== thread.folderPath) {
            $.chatThreads.dataset.currentFolderPath = thread.folderPath;
            await renderThreadList();
          }
          let el = $.chatThreads.querySelector(`.thread[data-thread-id="${thread.id}"]`);
          if(!el) el = $.chatThreads.querySelector(`.thread`); // in case the 'last viewed' thread is in a different folder to the 'last messaged' thread (renderThreadList shows last messaged thread)
          el.click();
        }
      }

      try {
        await navigator.storage.persist().then(async (persistent) => {
          if(persistent) {
            console.log("Storage will not be cleared except by explicit user action.");
          } else {
            console.warn("Storage may be cleared by the browser under storage pressure.");
            // Can't just use e.g. message count because they could have just imported a bunch of messages.
            let datesApplicationWasUsedInThisBrowser = (await db.misc.get("datesApplicationWasUsedInThisBrowser"))?.value ?? [];
            if(datesApplicationWasUsedInThisBrowser.length > 10) {
              alert("Your browser is not allowing OpenCharacters to store data in a way that is 100% permanent. Your browser may clear your OpenCharacters data if your hard drive is nearly full. The browser will eventually grant permission once it recognises that you are a regular user of this site (i.e. once you demonstrate that you trust this site), but until then, please be sure to backup/export your data often. If you're a regular user of OpenCharacters and you're still seeing this message after a week or so of use, please submit a bug report on our Discord server."); 
            }
          }
        });
      } catch(e) {
        console.error(e);
      }

      console.log("Finished initialization.");

   
    </script>

    <script>
      try {
        let isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;
        let isTouchScreen = window.matchMedia("(pointer: coarse)").matches;
        if(isSafari && window.innerWidth < 800 && isTouchScreen) {
          let viewportMetaEl = document.querySelector("[name=viewport]");
          if(!viewportMetaEl.getAttribute("content").includes("maximum-scale")) {
            viewportMetaEl.setAttribute("content", viewportMetaEl.getAttribute("content") + ", maximum-scale=1");
          }
          console.log("Safari iOS detected. Added maximum-scale attribute to prevent zooming:", viewportMetaEl.getAttribute("content"));
        }
      } catch(e) {
        console.error(e);
      }
    </script>

  </body>
</html>
